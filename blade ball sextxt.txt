-- Load required services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local SoundService = game:GetService("SoundService")
local Lighting = game:GetService("Lighting")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildOfClass("Humanoid")
local Alive = workspace:WaitForChild("Alive")
local Camera = workspace.CurrentCamera

-- Enhanced variables for remote events and parry control
local Remotes = {}
local Parry_Key = nil
local Parry_Data = nil
local Parry_Type = "Camera" -- Default parry type
local Cooldown = 0
local IsParried = false
local Connection = nil
local IsAutoParryEnabled = true
local ParryRadius = 15
local PredictionTime = 0.2
local Parries = 0
local Last_Input = UserInputService:GetLastInputType()
local AntiCurveEnabled = true
local VisualFeedbackEnabled = true
local HitboxVisualizationEnabled = false
local ParrySuccessCounter = 0
local PingCompensationEnabled = true
local ConfigSaved = false
local ParryAccuracy = 85
local RandomizedParryAccuracy = false
local InfinityDetection = true
local DeathSlashDetection = true
local TimeHoleDetection = true
local SlashOfFuryDetection = true
local AntiPhantomEnabled = true
local CooldownProtectionEnabled = true
local AutoAbilityEnabled = false
local NotifyEnabled = true
local SpamParryEnabled = false
local ManualSpamParryEnabled = false
local TriggerBotEnabled = false
local BallTpEnabled = false
local InstantBallTpEnabled = false
local LobbyApEnabled = false
local SpinbotEnabled = false
local FlyEnabled = false
local PlayerFollowEnabled = false
local CustomSkyEnabled = false
local BallTrailEnabled = false
local AbilityEspEnabled = false
local NoRenderEnabled = false
local CustomAnnouncerEnabled = false
local BallStatsEnabled = false
local VisualizerEnabled = false
local AutoClaimRewardsEnabled = false
local DisableQuantumArenaEffectsEnabled = false
local SkinChangerEnabled = false
local StreamerModeEnabled = false

-- Configuration settings
local Config = {
    AutoParry = true,
    AntiCurve = true,
    ParryRadius = 15,
    PredictionTime = 0.2,
    VisualFeedback = true,
    HitboxVisualization = false,
    PingCompensation = true,
    ParryAccuracy = 85,
    RandomizedParryAccuracy = false,
    InfinityDetection = true,
    DeathSlashDetection = true,
    TimeHoleDetection = true,
    SlashOfFuryDetection = true,
    AntiPhantom = true,
    CooldownProtection = true,
    AutoAbility = false,
    Notify = true,
    SpamParry = false,
    ManualSpamParry = false,
    TriggerBot = false,
    BallTp = false,
    InstantBallTp = false,
    LobbyAp = false,
    Spinbot = false,
    Fly = false,
    PlayerFollow = false,
    CustomSky = false,
    BallTrail = false,
    AbilityEsp = false,
    NoRender = false,
    CustomAnnouncer = false,
    BallStats = false,
    Visualizer = false,
    AutoClaimRewards = false,
    DisableQuantumArenaEffects = false,
    SkinChanger = false,
    StreamerMode = false,
    Keybinds = {
        ToggleUI = Enum.KeyCode.RightControl,
        ToggleAutoParry = Enum.KeyCode.P,
        ManualParry = Enum.KeyCode.F,
        SpamParry = Enum.KeyCode.G,
        ManualSpamParry = Enum.KeyCode.H,
        TriggerBot = Enum.KeyCode.T,
        BallTp = Enum.KeyCode.B,
        InstantBallTp = Enum.KeyCode.N,
        LobbyAp = Enum.KeyCode.L
    },
    ParryType = "Camera"
}

-- Capture remotes via debug
task.spawn(function()
    for _, Value in pairs(getgc()) do
        if type(Value) == "function" and islclosure(Value) then
            if debug.getupvalues(Value) then
                local Protos = debug.getprotos(Value)
                local Upvalues = debug.getupvalues(Value)
                local Constants = debug.getconstants(Value)
                if #Protos == 4 and #Upvalues == 24 and #Constants == 104 then
                    Remotes[debug.getupvalue(Value, 16)] = debug.getconstant(Value, 62)
                    Parry_Key = debug.getupvalue(Value, 17)
                    Remotes[debug.getupvalue(Value, 18)] = debug.getconstant(Value, 64)
                    Remotes[debug.getupvalue(Value, 19)] = debug.getconstant(Value, 65)
                    break
                end
            end
        end
    end
end)

-- Enhanced ball detection with special ability recognition
local function GetBall()
    local balls = workspace:FindFirstChild("Balls")
    if not balls then return nil end

    -- First try to find the real ball by attribute
    for _, Ball in ipairs(balls:GetChildren()) do
        if Ball:GetAttribute("realBall") then
            return Ball
        end
    end

    -- If no ball with attribute found, try to find by velocity
    for _, Ball in ipairs(balls:GetChildren()) do
        if Ball:IsA("BasePart") and Ball:FindFirstChild("zoomies") then
            return Ball
        end
    end

    return nil
end

-- Special ability detection
local function DetectSpecialAbility(Ball)
    if not Ball then return "Normal" end
    
    -- Check for Infinity ability
    if InfinityDetection and Ball:GetAttribute("Infinity") then
        return "Infinity"
    end
    
    -- Check for Death Slash
    if DeathSlashDetection and Ball:GetAttribute("DeathSlash") then
        return "DeathSlash"
    end
    
    -- Check for Time Hole
    if TimeHoleDetection and Ball:GetAttribute("TimeHole") then
        return "TimeHole"
    end
    
    -- Check for Slash of Fury
    if SlashOfFuryDetection and Ball:GetAttribute("SlashFury") then
        return "SlashFury"
    end
    
    return "Normal"
end

local function ResetConnection()
    if Connection then
        Connection:Disconnect()
        Connection = nil
    end
end

-- Enhanced ball monitoring
workspace:WaitForChild("Balls").ChildAdded:Connect(function(ball)
    task.wait(0.1) -- Wait for attributes to be set
    local Ball = GetBall()
    if not Ball then return end

    ResetConnection()
    Connection = Ball:GetAttributeChangedSignal("target"):Connect(function()
        IsParried = false
    end)
    
    -- Add ball trail if enabled
    if BallTrailEnabled then
        local trail = Instance.new("Trail")
        trail.Lifetime = 0.5
        trail.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),
            ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 255, 0)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 255, 0))
        })
        trail.Transparency = NumberSequence.new({
            NumberSequenceKeypoint.new(0, 0),
            NumberSequenceKeypoint.new(1, 1)
        })
        trail.WidthScale = NumberSequence.new(1)
        trail.Parent = Ball
        
        local attachment1 = Instance.new("Attachment")
        attachment1.Position = Vector3.new(0, 0, -0.5)
        attachment1.Parent = Ball
        
        local attachment2 = Instance.new("Attachment")
        attachment2.Position = Vector3.new(0, 0, 0.5)
        attachment2.Parent = Ball
        
        trail.Attachment0 = attachment1
        trail.Attachment1 = attachment2
    end
end)

-- Greatly improved ball position prediction with enhanced anti-curve
local function PredictBallPosition(Ball, TimeAhead)
    if not Ball then return Vector3.new(0, 0, 0) end
    
    local Velocity = (Ball:FindFirstChild("zoomies") and Ball.zoomies.VectorVelocity) or Vector3.new(0, 0, 0)
    local HRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    
    if not HRP then return Ball.Position + Velocity * TimeAhead end
    
    -- Enhanced anti-curve logic
    if AntiCurveEnabled then
        -- Calculate the direction to the player
        local dirToPlayer = (HRP.Position - Ball.Position).Unit
        local currentVelDir = Velocity.Unit
        
        -- Calculate dot product to see if ball is curving
        local dotProduct = dirToPlayer:Dot(currentVelDir)
        
        -- If ball is curving (not directly heading to player)
        if dotProduct < 0.9 then
            -- Advanced curve detection - analyze ball's recent positions
            local ballType = DetectSpecialAbility(Ball)
            local curveStrength = 0.5 -- Default curve compensation
            
            -- Adjust curve strength based on ball type
            if ballType == "Infinity" then
                curveStrength = 0.8
            elseif ballType == "DeathSlash" then
                curveStrength = 0.7
            elseif ballType == "TimeHole" then
                curveStrength = 0.6
            elseif ballType == "SlashFury" then
                curveStrength = 0.9
            end
            
            -- Calculate curve acceleration (second derivative of position)
            local curveAccel = dirToPlayer * Velocity.Magnitude * curveStrength
            
            -- Adjust velocity to account for curve with acceleration
            local adjustedVelocity = Velocity + curveAccel * TimeAhead
            return Ball.Position + adjustedVelocity * TimeAhead
        end
    end

    return Ball.Position + Velocity * TimeAhead
end

-- Function to show visual feedback when parrying
local function ShowParryFeedback(ballType)
    if not VisualFeedbackEnabled then return end
    
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "ParryFeedback"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    
    local Flash = Instance.new("Frame")
    Flash.Size = UDim2.new(1, 0, 1, 0)
    Flash.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Flash.BackgroundTransparency = 0.7
    Flash.BorderSizePixel = 0
    Flash.Parent = ScreenGui
    
    -- Text indicator
    local SuccessText = Instance.new("TextLabel")
    SuccessText.Size = UDim2.new(0, 300, 0, 80)
    SuccessText.Position = UDim2.new(0.5, -150, 0.4, 0)
    SuccessText.BackgroundTransparency = 1
    
    -- Customize text based on ball type
    if ballType == "Normal" then
        SuccessText.Text = "PARRIED!"
        SuccessText.TextColor3 = Color3.fromRGB(0, 255, 0)
    elseif ballType == "Infinity" then
        SuccessText.Text = "INFINITY PARRIED!"
        SuccessText.TextColor3 = Color3.fromRGB(255, 0, 255)
    elseif ballType == "DeathSlash" then
        SuccessText.Text = "DEATH SLASH PARRIED!"
        SuccessText.TextColor3 = Color3.fromRGB(255, 0, 0)
    elseif ballType == "TimeHole" then
        SuccessText.Text = "TIME HOLE PARRIED!"
        SuccessText.TextColor3 = Color3.fromRGB(0, 255, 255)
    elseif ballType == "SlashFury" then
        SuccessText.Text = "SLASH FURY PARRIED!"
        SuccessText.TextColor3 = Color3.fromRGB(255, 255, 0)
    end
    
    SuccessText.TextStrokeTransparency = 0
    SuccessText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    SuccessText.TextSize = 36
    SuccessText.Font = Enum.Font.GothamBold
    SuccessText.Parent = ScreenGui
    
    -- Play sound effect
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://6895079853" -- Parry success sound
    sound.Volume = 0.5
    sound.Parent = ScreenGui
    sound:Play()
    
    -- Fade out effect with bounce
    TweenService:Create(Flash, TweenInfo.new(0.2), {BackgroundTransparency = 1}):Play()
    
    -- Bounce animation for text
    TweenService:Create(SuccessText, TweenInfo.new(0.1, Enum.EasingStyle.Bounce), {Position = UDim2.new(0.5, -150, 0.38, 0)}):Play()
    task.wait(0.1)
    TweenService:Create(SuccessText, TweenInfo.new(0.1, Enum.EasingStyle.Bounce), {Position = UDim2.new(0.5, -150, 0.4, 0)}):Play()
    task.wait(0.1)
    TweenService:Create(SuccessText, TweenInfo.new(0.3), {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
    
    Debris:AddItem(ScreenGui, 0.5)
end

-- Function to visualize hitbox
local function VisualizeHitbox(Ball, Radius)
    if not HitboxVisualizationEnabled or not Ball then return end
    
    local HitboxPart = Instance.new("Part")
    HitboxPart.Name = "ParryHitbox"
    HitboxPart.Shape = Enum.PartType.Ball
    HitboxPart.Size = Vector3.new(Radius * 2, Radius * 2, Radius * 2)
    HitboxPart.Position = Ball.Position
    HitboxPart.Anchored = true
    HitboxPart.CanCollide = false
    HitboxPart.Transparency = 0.8
    HitboxPart.Material = Enum.Material.ForceField
    HitboxPart.Color = Color3.fromRGB(0, 255, 0)
    HitboxPart.Parent = workspace
    
    Debris:AddItem(HitboxPart, 0.1)
end

-- Function to check if parry should succeed based on accuracy
local function ShouldParrySucceed()
    if RandomizedParryAccuracy then
        return math.random(1, 100) <= ParryAccuracy
    else
        return true
    end
end

-- Function to perform a parry
local function PerformParry()
    -- Update parry data before firing
    updateParryData(Parry_Type)
    
    for Remote, Args in pairs(Remotes) do
        Remote:FireServer(Args, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
    end
    
    if NotifyEnabled then
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Parry",
            Text = "Manual parry performed",
            Duration = 1
        })
    end
end

-- Function to teleport to ball
local function TeleportToBall(instant)
    local Ball = GetBall()
    if not Ball then return end
    
    local Character = LocalPlayer.Character
    if not Character then return end
    
    local HRP = Character:FindFirstChild("HumanoidRootPart")
    if not HRP then return end
    
    local targetPosition = Ball.Position
    
    if instant then
        HRP.CFrame = CFrame.new(targetPosition)
    else
        -- Smooth teleport
        local startPosition = HRP.Position
        local distance = (targetPosition - startPosition).Magnitude
        local duration = math.min(distance / 100, 1) -- Cap duration at 1 second
        
        TweenService:Create(HRP, TweenInfo.new(duration, Enum.EasingStyle.Quad), {
            CFrame = CFrame.new(targetPosition)
        }):Play()
    end
    
    if NotifyEnabled then
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Ball TP",
            Text = instant and "Instant teleported to ball" or "Teleported to ball",
            Duration = 1
        })
    end
end

-- Spam parry function
local function SpamParry()
    if not SpamParryEnabled then return end
    
    while SpamParryEnabled do
        PerformParry()
        task.wait(0.1) -- Spam interval
    end
end

-- Manual spam parry function
local function ManualSpamParry()
    if not ManualSpamParryEnabled then return end
    
    while ManualSpamParryEnabled and UserInputService:IsKeyDown(Config.Keybinds.ManualSpamParry) do
        PerformParry()
        task.wait(0.05) -- Faster spam interval for manual
    end
end

-- Triggerbot function
local function TriggerBot()
    if not TriggerBotEnabled then return end
    
    local Ball = GetBall()
    if not Ball then return end
    
    local ballType = DetectSpecialAbility(Ball)
    if ballType == "Infinity" and InfinityDetection then
        PerformParry()
    end
end

-- Spinbot function
local function Spinbot()
    if not SpinbotEnabled then return end
    
    local Character = LocalPlayer.Character
    if not Character then return end
    
    local HRP = Character:FindFirstChild("HumanoidRootPart")
    if not HRP then return end
    
    -- Spin the character
    HRP.CFrame = HRP.CFrame * CFrame.Angles(0, math.rad(10), 0)
end

-- Fly function
local function ToggleFly()
    local Character = LocalPlayer.Character
    if not Character then return end
    
    local HRP = Character:FindFirstChild("HumanoidRootPart")
    if not HRP then return end
    
    if FlyEnabled then
        -- Enable fly
        local BodyVelocity = Instance.new("BodyVelocity")
        BodyVelocity.Name = "FlyVelocity"
        BodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
        BodyVelocity.Velocity = Vector3.new(0, 0, 0)
        BodyVelocity.Parent = HRP
        
        local BodyGyro = Instance.new("BodyGyro")
        BodyGyro.Name = "FlyGyro"
        BodyGyro.MaxTorque = Vector3.new(math.huge, math.huge, math.huge)
        BodyGyro.P = 9000
        BodyGyro.D = 250
        BodyGyro.CFrame = HRP.CFrame
        BodyGyro.Parent = HRP
    else
        -- Disable fly
        local BodyVelocity = HRP:FindFirstChild("FlyVelocity")
        if BodyVelocity then
            BodyVelocity:Destroy()
        end
        
        local BodyGyro = HRP:FindFirstChild("FlyGyro")
        if BodyGyro then
            BodyGyro:Destroy()
        end
    end
end

-- Player follow function
local function PlayerFollow()
    if not PlayerFollowEnabled then return end
    
    local Character = LocalPlayer.Character
    if not Character then return end
    
    local HRP = Character:FindFirstChild("HumanoidRootPart")
    if not HRP then return end
    
    -- Find closest player
    local closestPlayer = nil
    local closestDistance = math.huge
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local playerChar = player.Character
            if playerChar then
                local playerHRP = playerChar:FindFirstChild("HumanoidRootPart")
                if playerHRP then
                    local distance = (playerHRP.Position - HRP.Position).Magnitude
                    if distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end
    
    if closestPlayer and closestPlayer.Character then
        local targetHRP = closestPlayer.Character:FindFirstChild("HumanoidRootPart")
        if targetHRP then
            -- Move towards target
            local direction = (targetHRP.Position - HRP.Position).Unit
            local targetPosition = targetHRP.Position - (direction * 5) -- Stay 5 studs away
            
            local humanoid = Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:MoveTo(targetPosition)
            end
        end
    end
end

-- Custom sky function
local function SetCustomSky()
    if CustomSkyEnabled then
        -- Create custom sky
        local sky = Instance.new("Sky")
        sky.Name = "CustomSky"
        sky.SkyboxBk = "rbxassetid://8107841671"
        sky.SkyboxDn = "rbxassetid://8107841671"
        sky.SkyboxFt = "rbxassetid://8107841671"
        sky.SkyboxLf = "rbxassetid://8107841671"
        sky.SkyboxRt = "rbxassetid://8107841671"
        sky.SkyboxUp = "rbxassetid://8107841671"
        sky.StarCount = 5000
        sky.SunAngularSize = 21
        sky.SunTextureId = "rbxassetid://1084351190"
        sky.MoonAngularSize = 30
        sky.MoonTextureId = "rbxassetid://1075087760"
        sky.Parent = Lighting
    else
        -- Remove custom sky
        local customSky = Lighting:FindFirstChild("CustomSky")
        if customSky then
            customSky:Destroy()
        end
    end
end

-- Ability ESP function
local function UpdateAbilityESP()
    if not AbilityEspEnabled then
        -- Remove existing ESP
        for _, player in pairs(Players:GetPlayers()) do
            local espLabel = player:FindFirstChild("AbilityESP")
            if espLabel then
                espLabel:Destroy()
            end
        end
        return
    end
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            -- Check if player already has ESP
            local espLabel = player:FindFirstChild("AbilityESP")
            if not espLabel then
                espLabel = Instance.new("BillboardGui")
                espLabel.Name = "AbilityESP"
                espLabel.AlwaysOnTop = true
                espLabel.Size = UDim2.new(0, 200, 0, 50)
                espLabel.StudsOffset = Vector3.new(0, 3, 0)
                espLabel.Parent = player
                
                local textLabel = Instance.new("TextLabel")
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
                textLabel.TextStrokeTransparency = 0
                textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
                textLabel.TextSize = 14
                textLabel.Font = Enum.Font.GothamBold
                textLabel.Parent = espLabel
            end
            
            -- Update ESP text with player's ability
            local textLabel = espLabel:FindFirstChildOfClass("TextLabel")
            if textLabel then
                local ability = player:GetAttribute("Ability") or "Unknown"
                textLabel.Text = player.Name .. "\n" .. ability
            end
        end
    end
end

-- No render function
local function UpdateNoRender()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local character = player.Character
            if character then
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") or part:IsA("Decal") or part:IsA("Texture") then
                        part.Transparency = NoRenderEnabled and 1 or 0
                    end
                end
            end
        end
    end
end

-- Auto claim rewards function
local function AutoClaimRewards()
    if not AutoClaimRewardsEnabled then return end
    
    -- Attempt to claim daily rewards
    local rewardsRemote = ReplicatedStorage:FindFirstChild("RewardsRemote")
    if rewardsRemote then
        rewardsRemote:FireServer("ClaimDaily")
    end
    
    -- Attempt to claim other rewards
    local gamepassRemote = ReplicatedStorage:FindFirstChild("GamepassRemote")
    if gamepassRemote then
        gamepassRemote:FireServer("ClaimRewards")
    end
end

-- Disable quantum arena effects
local function DisableQuantumArenaEffects()
    if not DisableQuantumArenaEffectsEnabled then return end
    
    -- Find and disable effects
    for _, effect in pairs(workspace:GetDescendants()) do
        if effect:IsA("ParticleEmitter") or effect:IsA("Trail") or effect:IsA("Beam") then
            effect.Enabled = false
        end
    end
end

-- Improved auto parry with better timing and special ability detection
local function AutoParry()
    if not IsAutoParryEnabled then return end

    local Ball = GetBall()
    local Character = LocalPlayer.Character
    if not Ball or not Character then return end

    local HRP = Character:FindFirstChild("HumanoidRootPart")
    if not HRP then return end

    -- Visualize hitbox if enabled
    VisualizeHitbox(Ball, ParryRadius)

    -- Check if ball is targeting the player
    if Ball:GetAttribute("target") == LocalPlayer.Name and not IsParried then
        -- Detect special abilities
        local ballType = DetectSpecialAbility(Ball)
        
        -- Calculate prediction time based on ball type
        local adjustedPredictionTime = PredictionTime
        if ballType == "Infinity" then
            adjustedPredictionTime = PredictionTime * 0.8
        elseif ballType == "DeathSlash" then
            adjustedPredictionTime = PredictionTime * 0.7
        elseif ballType == "TimeHole" then
            adjustedPredictionTime = PredictionTime * 1.2
        elseif ballType == "SlashFury" then
            adjustedPredictionTime = PredictionTime * 0.6
        end
        
        local PredictedPosition = PredictBallPosition(Ball, adjustedPredictionTime)
        local DistanceToPredicted = (HRP.Position - PredictedPosition).Magnitude
        
        -- Calculate dynamic parry radius based on ball velocity and type
        local Velocity = (Ball:FindFirstChild("zoomies") and Ball.zoomies.VectorVelocity) or Vector3.new(0, 0, 0)
        local VelocityMagnitude = Velocity.Magnitude
        local DynamicRadius = ParryRadius + (VelocityMagnitude / 10)
        
        -- Adjust radius based on ball type
        if ballType == "Infinity" then
            DynamicRadius = DynamicRadius * 1.2
        elseif ballType == "DeathSlash" then
            DynamicRadius = DynamicRadius * 1.1
        elseif ballType == "TimeHole" then
            DynamicRadius = DynamicRadius * 1.3
        elseif ballType == "SlashFury" then
            DynamicRadius = DynamicRadius * 1.15
        end
        
        -- Apply ping compensation if enabled
        if PingCompensationEnabled then
            local Ping = LocalPlayer:GetNetworkPing() * 1000 -- Convert to ms
            DynamicRadius = DynamicRadius + (Ping / 100) -- Adjust radius based on ping
        end
        
        -- Apply anti-phantom
        if AntiPhantomEnabled then
            -- Anti-phantom logic to prevent missed parries
            if Ball:GetAttribute("lastParried") and tick() - Ball:GetAttribute("lastParried") < 1 then
                DynamicRadius = DynamicRadius * 1.5 -- Increase radius after recent parry
            end
        end
        
        if DistanceToPredicted <= DynamicRadius then
            -- Check parry accuracy
            if ShouldParrySucceed() then
                -- Apply cooldown protection
                if CooldownProtectionEnabled then
                    local lastParryTime = Ball:GetAttribute("lastParryTime") or 0
                    if tick() - lastParryTime < 0.5 then
                        DynamicRadius = DynamicRadius * 1.2 -- Increase radius during cooldown
                    end
                end
                
                -- Update parry data based on selected type
                updateParryData(Parry_Type)
                
                -- Fire all parry remotes
                for Remote, Args in pairs(Remotes) do
                    Remote:FireServer(Args, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
                end
                
                IsParried = true
                Cooldown = tick()
                ParrySuccessCounter = ParrySuccessCounter + 1
                ShowParryFeedback(ballType)
                
                -- Auto ability after parry
                if AutoAbilityEnabled then
                    local abilityRemote = ReplicatedStorage:FindFirstChild("AbilityRemote")
                    if abilityRemote then
                        abilityRemote:FireServer("UseAbility")
                    end
                end
                
                -- Set last parry time attribute
                Ball:SetAttribute("lastParryTime", tick())
            end
        end
    end

    -- Reset parry state after cooldown
    if IsParried and (tick() - Cooldown) >= 1 then
        IsParried = false
    end
end

RunService.PreSimulation:Connect(AutoParry)

-- Update parry data based on selected curve type
local function updateParryData(parryType)
    local Vector3_Mouse_Location
    if Last_Input == Enum.UserInputType.MouseButton1 or
       Last_Input == Enum.UserInputType.MouseButton2 or
       Last_Input == Enum.UserInputType.Keyboard then
        local Mouse_Location = UserInputService:GetMouseLocation()
        Vector3_Mouse_Location = {Mouse_Location.X, Mouse_Location.Y}
    else
        Vector3_Mouse_Location = {Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2}
    end

    local Events = {}
    for _, v in pairs(Alive:GetChildren()) do
        if v:FindFirstChild("PrimaryPart") then
            Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
        end
    end

    local data  
    if parryType == "Camera" then  
        data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}  
    elseif parryType == "Random" then  
        data = {0, CFrame.new(Camera.CFrame.Position, Vector3.new(math.random(-3000,3000), math.random(-3000,3000), math.random(-3000,3000))), Events, Vector3_Mouse_Location}  
    elseif parryType == "Backwards" then  
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.LookVector * 1000)), Events, Vector3_Mouse_Location}  
    elseif parryType == "Dot" then  
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.LookVector * 1000)), Events, Vector3_Mouse_Location}  
    elseif parryType == "High" then  
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.UpVector * 1000)), Events, Vector3_Mouse_Location}  
    elseif parryType == "Right" then  
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.RightVector * 1000)), Events, Vector3_Mouse_Location}  
    elseif parryType == "Left" then  
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.RightVector * 1000)), Events, Vector3_Mouse_Location}  
    else  
        data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}  
    end  

    Parry_Data = data
    Config.ParryType = parryType
}

-- Save and load configuration
local function SaveConfig()
    local ConfigData = HttpService:JSONEncode(Config)
    writefile("EnhancedAutoParryConfig.json", ConfigData)
    ConfigSaved = true
}

local function LoadConfig()
    if isfile("EnhancedAutoParryConfig.json") then
        local ConfigData = readfile("EnhancedAutoParryConfig.json")
        local LoadedConfig = HttpService:JSONDecode(ConfigData)
        
        -- Update config with loaded values
        for key, value in pairs(LoadedConfig) do
            Config[key] = value
        end
        
        -- Apply loaded settings
        IsAutoParryEnabled = Config.AutoParry
        AntiCurveEnabled = Config.AntiCurve
        ParryRadius = Config.ParryRadius
        PredictionTime = Config.PredictionTime
        VisualFeedbackEnabled = Config.VisualFeedback
        HitboxVisualizationEnabled = Config.HitboxVisualization
        PingCompensationEnabled = Config.PingCompensation
        ParryAccuracy = Config.ParryAccuracy
        RandomizedParryAccuracy = Config.RandomizedParryAccuracy
        InfinityDetection = Config.InfinityDetection
        DeathSlashDetection = Config.DeathSlashDetection
        TimeHoleDetection = Config.TimeHoleDetection
        SlashOfFuryDetection = Config.SlashOfFuryDetection
        AntiPhantomEnabled = Config.AntiPhantom
        CooldownProtectionEnabled = Config.CooldownProtection
        AutoAbilityEnabled = Config.AutoAbility
        NotifyEnabled = Config.Notify
        SpamParryEnabled = Config.SpamParry
        ManualSpamParryEnabled = Config.ManualSpamParry
        TriggerBotEnabled = Config.TriggerBot
        BallTpEnabled = Config.BallTp
        InstantBallTpEnabled = Config.InstantBallTp
        LobbyApEnabled = Config.LobbyAp
        SpinbotEnabled = Config.Spinbot
        FlyEnabled = Config.Fly
        PlayerFollowEnabled = Config.PlayerFollow
        CustomSkyEnabled = Config.CustomSky
        BallTrailEnabled = Config.BallTrail
        AbilityEspEnabled = Config.AbilityEsp
        NoRenderEnabled = Config.NoRender
        CustomAnnouncerEnabled = Config.CustomAnnouncer
        BallStatsEnabled = Config.BallStats
        VisualizerEnabled = Config.Visualizer
        AutoClaimRewardsEnabled = Config.AutoClaimRewards
        DisableQuantumArenaEffectsEnabled = Config.DisableQuantumArenaEffects
        SkinChangerEnabled = Config.SkinChanger
        StreamerModeEnabled = Config.StreamerMode
        Parry_Type = Config.ParryType
        
        ConfigSaved = true
        return true
    end
    return false
end

-- Try to load config
pcall(LoadConfig)

-- Create UI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "EnhancedAutoParryUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Main frame with transparency
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 600, 0, 400)
MainFrame.Position = UDim2.new(0.5, -300, 0.5, -200)
MainFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 15)
MainFrame.BackgroundTransparency = 0.2
MainFrame.BorderSizePixel = 0
MainFrame.Parent = ScreenGui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = MainFrame

-- Gradient background with glow effect
local UIGradient = Instance.new("UIGradient")
UIGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 45)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(15, 15, 25))
})
UIGradient.Rotation = 45
UIGradient.Parent = MainFrame

-- Add blur effect behind the UI
local BlurEffect = Instance.new("BlurEffect")
BlurEffect.Size = 10
BlurEffect.Parent = game.Lighting

-- Header with glass effect
local Header = Instance.new("Frame")
Header.Name = "Header"
Header.Size = UDim2.new(1, 0, 0, 40)
Header.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
Header.BackgroundTransparency = 0.2
Header.BorderSizePixel = 0
Header.Parent = MainFrame

local HeaderCorner = Instance.new("UICorner")
HeaderCorner.CornerRadius = UDim.new(0, 10)
HeaderCorner.Parent = Header

-- Fix the bottom corners of header
local HeaderFix = Instance.new("Frame")
HeaderFix.Size = UDim2.new(1, 0, 0, 10)
HeaderFix.Position = UDim2.new(0, 0, 1, -10)
HeaderFix.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
HeaderFix.BackgroundTransparency = 0.2
HeaderFix.BorderSizePixel = 0
HeaderFix.Parent = Header

-- Title with glow effect
local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, -20, 1, 0)
Title.Position = UDim2.new(0, 10, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "HYPER AUTO PARRY"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 18
Title.Font = Enum.Font.GothamBold
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.Parent = Header

-- Glow effect for title
local TitleGlow = Instance.new("ImageLabel")
TitleGlow.Size = UDim2.new(1.2, 0, 1.2, 0)
TitleGlow.Position = UDim2.new(0.5, 0, 0.5, 0)
TitleGlow.AnchorPoint = Vector2.new(0.5, 0.5)
TitleGlow.BackgroundTransparency = 1
TitleGlow.Image = "rbxassetid://4996891970" -- Radial gradient
TitleGlow.ImageColor3 = Color3.fromRGB(255, 0, 128)
TitleGlow.ImageTransparency = 0.7
TitleGlow.ZIndex = -1
TitleGlow.Parent = Title

-- Stats display
local StatsFrame = Instance.new("Frame")
StatsFrame.Size = UDim2.new(0, 150, 0, 30)
StatsFrame.Position = UDim2.new(0.5, -75, 0, 5)
StatsFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 45)
StatsFrame.BackgroundTransparency = 0.5
StatsFrame.BorderSizePixel = 0
StatsFrame.Parent = Header

local StatsCorner = Instance.new("UICorner")
StatsCorner.CornerRadius = UDim.new(0, 6)
StatsCorner.Parent = StatsFrame

local ParryCounterLabel = Instance.new("TextLabel")
ParryCounterLabel.Size = UDim2.new(1, 0, 1, 0)
ParryCounterLabel.BackgroundTransparency = 1
ParryCounterLabel.Text = "Parries: 0"
ParryCounterLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
ParryCounterLabel.TextSize = 14
ParryCounterLabel.Font = Enum.Font.GothamSemibold
ParryCounterLabel.Parent = StatsFrame

-- Tab buttons container
local TabButtonsFrame = Instance.new("Frame")
TabButtonsFrame.Name = "TabButtonsFrame"
TabButtonsFrame.Size = UDim2.new(1, -20, 0, 30)
TabButtonsFrame.Position = UDim2.new(0, 10, 0, 45)
TabButtonsFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
TabButtonsFrame.BackgroundTransparency = 0.5
TabButtonsFrame.BorderSizePixel = 0
TabButtonsFrame.Parent = MainFrame

local TabButtonsCorner = Instance.new("UICorner")
TabButtonsCorner.CornerRadius = UDim.new(0, 6)
TabButtonsCorner.Parent = TabButtonsFrame

-- Create tab buttons
local function CreateTabButton(text, position, isActive)
    local TabButton = Instance.new("TextButton")
    TabButton.Size = UDim2.new(0.25, -5, 1, -6)
    TabButton.Position = position
    TabButton.BackgroundColor3 = isActive and Color3.fromRGB(255, 0, 128) or Color3.fromRGB(40, 40, 60)
    TabButton.BackgroundTransparency = isActive and 0.2 or 0.5
    TabButton.BorderSizePixel = 0
    TabButton.Text = text
    TabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    TabButton.TextSize = 14
    TabButton.Font = Enum.Font.GothamSemibold
    TabButton.Parent = TabButtonsFrame
    
    local TabButtonCorner = Instance.new("UICorner")
    TabButtonCorner.CornerRadius = UDim.new(0, 4)
    TabButtonCorner.Parent = TabButton
    
    return TabButton
end

local BlatantButton = CreateTabButton("Blatant", UDim2.new(0, 3, 0, 3), true)
local PlayerButton = CreateTabButton("Player", UDim2.new(0.25, 3, 0, 3), false)
local WorldButton = CreateTabButton("World", UDim2.new(0.5, 3, 0, 3), false)
local MiscButton = CreateTabButton("Misc", UDim2.new(0.75, 3, 0, 3), false)

-- Content container
local ContentContainer = Instance.new("Frame")
ContentContainer.Name = "ContentContainer"
ContentContainer.Size = UDim2.new(1, -20, 1, -85)
ContentContainer.Position = UDim2.new(0, 10, 0, 80)
ContentContainer.BackgroundTransparency = 1
ContentContainer.BorderSizePixel = 0
ContentContainer.Parent = MainFrame

-- Create tab content frames
local function CreateTabContent(name, visible)
    local TabContent = Instance.new("ScrollingFrame")
    TabContent.Name = name .. "Tab"
    TabContent.Size = UDim2.new(1, 0, 1, 0)
    TabContent.BackgroundTransparency = 1
    TabContent.BorderSizePixel = 0
    TabContent.ScrollBarThickness = 4
    TabContent.ScrollBarImageColor3 = Color3.fromRGB(255, 0, 128)
    TabContent.CanvasSize = UDim2.new(0, 0, 0, 600) -- Will be updated based on content
    TabContent.Visible = visible
    TabContent.Parent = ContentContainer
    
    return TabContent
end

local BlatantTab = CreateTabContent("Blatant", true)
local PlayerTab = CreateTabContent("Player", false)
local WorldTab = CreateTabContent("World", false)
local MiscTab = CreateTabContent("Misc", false)

-- Tab switching logic
BlatantButton.MouseButton1Click:Connect(function()
    BlatantTab.Visible = true
    PlayerTab.Visible = false
    WorldTab.Visible = false
    MiscTab.Visible = false
    
    BlatantButton.BackgroundColor3 = Color3.fromRGB(255, 0, 128)
    BlatantButton.BackgroundTransparency = 0.2
    PlayerButton.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    PlayerButton.BackgroundTransparency = 0.5
    WorldButton.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    WorldButton.BackgroundTransparency = 0.5
    MiscButton.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    MiscButton.BackgroundTransparency = 0.5
end)

PlayerButton.MouseButton1Click:Connect(function()
    BlatantTab.Visible = false
    PlayerTab.Visible = true
    WorldTab.Visible = false
    MiscTab.Visible = false
    
    BlatantButton.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    BlatantButton.BackgroundTransparency = 0.5
    PlayerButton.BackgroundColor3 = Color3.fromRGB(255, 0, 128)
    PlayerButton.BackgroundTransparency = 0.2
    WorldButton.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    WorldButton.BackgroundTransparency = 0.5
    MiscButton.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    MiscButton.BackgroundTransparency = 0.5
end)

WorldButton.MouseButton1Click:Connect(function()
    BlatantTab.Visible = false
    PlayerTab.Visible = false
    WorldTab.Visible = true
    MiscTab.Visible = false
    
    BlatantButton.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    BlatantButton.BackgroundTransparency = 0.5
    PlayerButton.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    PlayerButton.BackgroundTransparency = 0.5
    WorldButton.BackgroundColor3 = Color3.fromRGB(255, 0, 128)
    WorldButton.BackgroundTransparency = 0.2
    MiscButton.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    MiscButton.BackgroundTransparency = 0.5
end)

MiscButton.MouseButton1Click:Connect(function()
    BlatantTab.Visible = false
    PlayerTab.Visible = false
    WorldTab.Visible = false
    MiscTab.Visible = true
    
    BlatantButton.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    BlatantButton.BackgroundTransparency = 0.5
    PlayerButton.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    PlayerButton.BackgroundTransparency = 0.5
    WorldButton.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    WorldButton.BackgroundTransparency = 0.5
    MiscButton.BackgroundColor3 = Color3.fromRGB(255, 0, 128)
    MiscButton.BackgroundTransparency = 0.2
end)

-- Create section header
local function CreateSectionHeader(parent, text, position)
    local SectionHeader = Instance.new("Frame")
    SectionHeader.Size = UDim2.new(1, 0, 0, 30)
    SectionHeader.Position = position
    SectionHeader.BackgroundColor3 = Color3.fromRGB(255, 0, 128)
    SectionHeader.BackgroundTransparency = 0.7
    SectionHeader.BorderSizePixel = 0
    SectionHeader.Parent = parent
    
    local SectionCorner = Instance.new("UICorner")
    SectionCorner.CornerRadius = UDim.new(0, 6)
    SectionCorner.Parent = SectionHeader
    
    local SectionLabel = Instance.new("TextLabel")
    SectionLabel.Size = UDim2.new(1, -10, 1, 0)
    SectionLabel.Position = UDim2.new(0, 10, 0, 0)
    SectionLabel.BackgroundTransparency = 1
    SectionLabel.Text = text
    SectionLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    SectionLabel.TextSize = 14
    SectionLabel.Font = Enum.Font.GothamBold
    SectionLabel.TextXAlignment = Enum.TextXAlignment.Left
    SectionLabel.Parent = SectionHeader
    
    return SectionHeader
end

-- Create toggle switch
local function CreateToggle(parent, text, position, defaultState, callback)
    local Container = Instance.new("Frame")
    Container.Size = UDim2.new(1, 0, 0, 40)
    Container.Position = position
    Container.BackgroundTransparency = 1
    Container.Parent = parent

    local Label = Instance.new("TextLabel")
    Label.Size = UDim2.new(0.7, 0, 1, 0)
    Label.BackgroundTransparency = 1
    Label.Text = text
    Label.TextColor3 = Color3.fromRGB(200, 200, 200)
    Label.TextSize = 14
    Label.Font = Enum.Font.GothamSemibold
    Label.TextXAlignment = Enum.TextXAlignment.Left
    Label.Parent = Container

    local ToggleBackground = Instance.new("Frame")
    ToggleBackground.Size = UDim2.new(0, 50, 0, 24)
    ToggleBackground.Position = UDim2.new(1, -60, 0.5, -12)
    ToggleBackground.BackgroundColor3 = defaultState and Color3.fromRGB(255, 0, 128) or Color3.fromRGB(60, 60, 60)
    ToggleBackground.BackgroundTransparency = 0.3
    ToggleBackground.BorderSizePixel = 0
    ToggleBackground.Parent = Container

    local ToggleCorner = Instance.new("UICorner")
    ToggleCorner.CornerRadius = UDim.new(1, 0)
    ToggleCorner.Parent = ToggleBackground

    local ToggleCircle = Instance.new("Frame")
    ToggleCircle.Size = UDim2.new(0, 18, 0, 18)
    ToggleCircle.Position = defaultState and UDim2.new(1, -21, 0.5, -9) or UDim2.new(0, 3, 0.5, -9)
    ToggleCircle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ToggleCircle.BorderSizePixel = 0
    ToggleCircle.Parent = ToggleBackground

    local ToggleCircleCorner = Instance.new("UICorner")
    ToggleCircleCorner.CornerRadius = UDim.ne
