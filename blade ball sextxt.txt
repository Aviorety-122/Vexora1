--[[
  ______              ______ _           _      
 |  ____|            |  ____|_|         | |     
 | |__ ___ _ __ ___  | |__   _ _ __   __| | ___ 
 |  __/ _ \ '_ ` _ \ |  __| | | '_ \ / _` |/ _ \
 | | |  __/ | | | | || |____| | | | | (_| |  __/
 |_|  \___|_| |_| |_||______|_|_| |_|\__,_|\___|
                                                
  _____                      _                     _____           _       _   
 |  __ \                    (_)                   / ____|         (_)     | |  
 | |__) | __ ___ _ __ ___    _ _   _ _ __ ___    | (___   ___ _ __ _ _ __ | |_ 
 |  ___/ '__/ _ \ '_ ` _ \  | | | | | '_ ` _ \    \___ \ / __| '__| | '_ \| __|
 | |   | | |  __/ | | | | | | | |_| | | | | | |   ____) | (__| |  | | |_) | |_ 
 |_|   |_|  \___|_| |_| |_| |_|\__,_|_| |_| |_|  |_____/ \___|_|  |_| .__/ \__|
                                                                     | |        
                                                                     |_|        
]]--

-- ***********************************************
-- *           FEMEBLADE AUTO PARRY              *
-- *      ULTRA PREMIUM PARRYING SCRIPT          *
-- *           BLADE BALL EDITION                *
-- ***********************************************

--// CONFIGURATION SECTION //--
local CONFIG = {
    -- Core Settings
    Name = "FemBlade",
    Version = "1.0.3",
    Debug = false,
    Author = "FemBlade Team",
    ReleaseDate = "April 27, 2025",
    DiscordInvite = "discord.gg/femBlade",
    ScriptId = tostring(math.random(100000, 999999)),
    
    -- Performance Settings
    OptimizePerformance = true,
    ReduceAnimations = false,
    ReduceLagSpikes = true,
    UseAsyncComputing = true,
    PreloadAssets = true,
    CacheRemotes = true,
    ReduceMemoryUsage = true,
    
    -- UI Settings
    DefaultTheme = "Dark",
    AccentColor = Color3.fromRGB(140, 70, 240), -- Purple
    TextColor = Color3.fromRGB(240, 240, 250),
    SecondaryTextColor = Color3.fromRGB(180, 180, 200),
    BackgroundColor = Color3.fromRGB(15, 15, 20),
    SecondaryBackgroundColor = Color3.fromRGB(25, 25, 35),
    UIScale = 1.0,
    CustomCursor = false,
    BlurEffect = false,
    ShowParticles = true,
    AnimateTransitions = true,
    RoundedCorners = true,
    EnableSounds = true,
    
    -- Security Settings
    AntiCheatBypass = true,
    ObfuscateRemotes = true,
    DisableTelemetry = true,
    ProtectGlobals = true,
    AntiKick = true,
    AntiTeleport = false,
    HideFromScriptScans = true,
    SecureLocalStorage = true,
    
    -- Global Defaults
    ParryDistance = 43, -- As requested
    PredictionTime = 0.15,
    ParryAccuracy = 100,
    AutoParryEnabled = false,
    CurveType = "Dot",
    ParryModes = {
        "Dot", 
        "Custom", 
        "Backwards", 
        "Random",
        "Straight",
        "Up",
        "Right",
        "Left",
        "Down",
        "Adaptive",
        "Smart",
        "Trace",
        "Predictive",
        "Momentum",
        "Reactive"
    },
    
    -- Advanced Parry Settings
    TimeStepMultiplier = 1.0,
    MaxVelocitySamples = 15,
    DefaultSmoothing = 0.8,
    VisualFeedback = true,
    AdjustForPing = true,
    BallTypeDetection = true,
    CurveRecognition = true,
    BouncePrediction = true,
    DynamicTiming = true,
    
    -- Audio Settings
    ParrySoundId = "rbxassetid://6732690176",
    UIClickSoundId = "rbxassetid://6732690176",
    NotificationSoundId = "rbxassetid://6732690176",
    SoundVolume = 0.5,
    
    -- Visual Effects
    HitEffectEnabled = true,
    HitEffectId = "rbxassetid://8517625677",
    HitEffectSize = UDim2.new(0, 100, 0, 100),
    HitEffectDuration = 0.4,
    
    -- Custom Commands
    EnableChatCommands = true,
    CommandPrefix = "!",
    Commands = {
        help = "Shows available commands",
        toggle = "Toggles auto parry",
        mode = "Changes parry mode",
        radius = "Sets parry radius",
        time = "Sets prediction time",
        stats = "Shows parry statistics",
        reset = "Resets all settings to default"
    },
    
    -- Keybind Settings
    KeybindEnabled = true,
    Keybinds = {
        ToggleUI = Enum.KeyCode.RightControl,
        ToggleAutoParry = Enum.KeyCode.M,
        CycleParryMode = Enum.KeyCode.N,
        IncreaseRadius = Enum.KeyCode.RightBracket,
        DecreaseRadius = Enum.KeyCode.LeftBracket,
        EmergencyParry = Enum.KeyCode.E
    },
    
    -- Developer Settings
    DeveloperMode = false,
    EnableLogging = true,
    LogLevel = "INFO", -- INFO, WARNING, ERROR, DEBUG
    ShowPerformanceStats = false,
    EnableExceptions = true,
    CreateBackups = true,
    EnableVersionCheck = true,
    
    -- Advanced Features
    AutoUpdate = true,
    CloudSync = false,
    EnableAnalytics = false,
    ShareAnonymousStats = false,
    EnableTips = true,
    ShowNotifications = true,
    
    -- External Integration
    DiscordRPC = false,
    WebhookEnabled = false,
    WebhookEndpoint = "",
    
    -- Experimental Features
    MachineLearning = false,
    AdaptiveTimingSystem = true,
    PatternRecognition = false,
    ServerSideSimulation = false,
    PredictiveAnalytics = false
}

--// INITIALIZATION AND SERVICES //--
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ContentProvider = game:GetService("ContentProvider")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local HttpService = game:GetService("HttpService")
local TextService = game:GetService("TextService")
local ContextActionService = game:GetService("ContextActionService")
local GuiService = game:GetService("GuiService")
local MarketplaceService = game:GetService("MarketplaceService")

-- Player Variables
local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local PlayerName = LocalPlayer.Name
local UserId = LocalPlayer.UserId
local Humanoid = Character:FindFirstChildOfClass("Humanoid")
local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
local Camera = workspace.CurrentCamera
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local Mouse = LocalPlayer:GetMouse()
local Alive = workspace:WaitForChild("Alive")

-- Global Variables
_G.FemBladeLoaded = true
_G.FemBladeVersion = CONFIG.Version
_G.FemBladeDebug = CONFIG.Debug
_G.FemBladeSecurity = {
    AntiCheatBypass = CONFIG.AntiCheatBypass,
    ObfuscateRemotes = CONFIG.ObfuscateRemotes,
    DisableTelemetry = CONFIG.DisableTelemetry
}

-- Local Script Identifier
local ScriptId = HttpService:GenerateGUID(false)
local StartTime = tick()

-- Initialize session statistics
local SessionStats = {
    StartTime = os.time(),
    TotalParries = 0,
    SuccessfulParries = 0,
    MissedParries = 0,
    BallsDetected = 0,
    CurvedBallsDetected = 0,
    SpecialBallsDetected = 0,
    TotalDistance = 0,
    AverageReactionTime = 0,
    ReactionTimes = {},
    MaxConsecutiveParries = 0,
    CurrentConsecutiveParries = 0,
    Uptime = 0,
    LastParryTime = 0
}

-- Check for future character spawn
LocalPlayer.CharacterAdded:Connect(function(NewCharacter)
    Character = NewCharacter
    Humanoid = Character:FindFirstChildOfClass("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    
    if _G.FemBladeDebug then
        print("[FemBlade] Character respawned, references updated.")
    end
end)

--// CORE FUNCTIONALITY //--
-- Parry System Variables
local Remotes = {}
local Parry_Key = nil
local Parry_Data = nil
local Connection = nil
local IsParried = false
local Cooldown = 0
local LastParryAttemptTime = 0
local ParrySuccessRate = 100
local ConsecutiveMisses = 0
local BallHistoryData = {}
local BallVelocityHistory = {}
local LastPredictedPositions = {}
local CurrentBallData = {}
local CurrentBallTarget = nil

-- Feature Configuration Variables
-- Auto Parry Settings
local IsAutoParryEnabled = false
local ParryRadius = CONFIG.ParryDistance
local PredictionTime = CONFIG.PredictionTime
local ParryAccuracy = CONFIG.ParryAccuracy
local ParryType = CONFIG.CurveType
local RandomizedParryAccuracy = false
local ParrySettings = {
    -- Basic Settings
    PriorityMode = "Default", -- Default, Distance, Speed, Danger
    AutomaticPredictionAdjustment = true,
    DynamicRadiusAdjustment = false,
    MinRadius = 10,
    MaxRadius = 60,
    
    -- Advanced Settings
    CurveCompensation = true,
    SpeedBasedTiming = true,
    VelocityExtrapolation = true,
    VelocitySampleCount = 10,
    PrecisionLevel = 3, -- 1-3, higher is more precise
    ParryWindowStart = 0.1, -- time before predicted hit
    ParryWindowEnd = 0.05, -- time after predicted hit
    
    -- Animation Settings
    AnimationControl = false,
    CustomAnimationId = nil,
    BlockAnimationDisabled = false,
    AnimationSpeedMultiplier = 1,
    
    -- Auto-Adjust Settings
    LearningMode = false,
    AdaptiveTiming = false,
    SuccessThreshold = 0.8,
    FailureAdjustmentFactor = 0.05,
    SuccessAdjustmentFactor = 0.02,
    
    -- Extra Features
    TooFastThreshold = 300,
    TooSlowThreshold = 40,
    FakeLatency = 0,
    AutoDetectPing = true,
    PingCompensation = true
}

-- Detection Options
local InfinityDetection = false
local DeathSlashDetection = false
local TimeHoleDetection = false
local SlashOfFuryDetection = false
local AntiPhantom = false
local CooldownProtection = false
local AutoAbility = false
local ParryDebounce = false

-- Advanced Ball Detection
local BallDetectionSettings = {
    VelocityThreshold = 400,
    SizeThreshold = 2,
    AccelerationThreshold = 100, 
    DirectionChangeThreshold = 0.3,
    MinDistanceForTracking = 5,
    MaxDistanceForTracking = 300,
    TrackingUpdateRate = 0.01,
    PredictionSmoothingFactor = 0.7,
    MaxHistoryLength = 20,
    VelocitySmoothingFactor = 0.8,
    UseAccelerationInPrediction = true,
    PredictBounces = true,
    BallisticPrediction = true,
    AdaptivePathPrediction = true
}

-- Additional Features
local FeatureSettings = {
    -- Auto Spam Settings
    AutoSpamEnabled = false,
    AutoSpamRate = 0.15,
    AutoSpamMode = "Constant", -- Constant, Pattern, Random
    AutoSpamPattern = {0.1, 0.2, 0.1, 0.3}, -- Time between spams
    AutoSpamRandomMin = 0.1,
    AutoSpamRandomMax = 0.3,
    
    -- Manual Spam Settings
    ManualSpamEnabled = false,
    ManualSpamKeyBind = Enum.KeyCode.E,
    ManualSpamRate = 0.1,
    ManualSpamMouseEnabled = true,
    
    -- Trigger Bot Settings
    TriggerBotEnabled = false,
    TriggerBotDelay = 0.05,
    TriggerBotAccuracy = 100,
    
    -- Notification Settings
    NotifyEnabled = false,
    NotifySound = true,
    NotifySoundId = "rbxassetid://6895079853",
    NotifySoundVolume = 0.5,
    NotifyPosition = "TopRight", -- TopRight, TopLeft, BottomRight, BottomLeft, Center
    NotifyDuration = 1.5,
    NotifyWithChat = false,
    NotifyChatTemplate = "⚔️ Парирован мяч! ⚔️",
    
    -- Visualization Settings
    VisualFeedbackEnabled = false,
    ShowParryRadius = false,
    ShowPredictionPath = false,
    ShowBallDirection = false,
    ShowBallTarget = false,
    ShowParryWindow = false,
    HighlightActiveBall = false,
    
    -- Keybind Settings
    ToggleKeybind = Enum.KeyCode.M,
    ModeKeybind = Enum.KeyCode.N,
    RadiusIncreaseKeybind = Enum.KeyCode.RightBracket,
    RadiusDecreaseKeybind = Enum.KeyCode.LeftBracket,
    
    -- Custom UI Settings
    CustomCursorEnabled = false,
    CustomCursorId = "rbxassetid://8081775844",
    CustomCursorSize = UDim2.new(0, 32, 0, 32),
    ShowStatsInGame = false,
    UICornerRadius = UDim.new(0, 6),
    
    -- Other Features
    AnimationFix = false,
    KeypressEmulation = false,
    SmoothCamera = false,
    AutoAbilityDetection = false,
    ChatCommands = false,
    ChatCommandPrefix = "!",
    
    -- Quality of Life
    DisableScreenShakes = false,
    DisableScreenBlur = false,
    DisableCriticalEffects = false,
    EnhanceVisibility = false,
    LockFirstPerson = false,
    AutoHideUnnecessaryUI = false,
    
    -- Performance Optimizations
    ReduceParticles = false,
    OptimizeRendering = false,
    LimitVelocitySamples = true,
    UseAsyncTracking = true,
    SyncWithHeartbeat = false,
    SkipNonEssentialUpdates = false
}

--// UTILITY FUNCTIONS //--
-- Debug Print Function
local function DebugPrint(...)
    if _G.FemBladeDebug then
        local args = {...}
        local message = "[FemBlade]"
        for i, v in ipairs(args) do
            message = message .. " " .. tostring(v)
        end
        print(message)
    end
end

-- Format time function
local function FormatTime(seconds)
    local minutes = math.floor(seconds / 60)
    local hours = math.floor(minutes / 60)
    local remainingSeconds = seconds % 60
    local remainingMinutes = minutes % 60
    
    if hours > 0 then
        return string.format("%02d:%02d:%02d", hours, remainingMinutes, remainingSeconds)
    else
        return string.format("%02d:%02d", minutes, remainingSeconds)
    end
end

-- Deep copy function for tables
local function DeepCopy(original)
    local copy = {}
    for k, v in pairs(original) do
        if type(v) == "table" then
            copy[k] = DeepCopy(v)
        else
            copy[k] = v
        end
    end
    return copy
end

-- Get current ping
local function GetPing()
    local Stats = game:GetService("Stats")
    local Ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
    return Ping
end

-- Angle calculation
local function GetAngleBetweenVectors(a, b)
    local dot = a:Dot(b)
    local magnitude = a.Magnitude * b.Magnitude
    return math.acos(math.clamp(dot / magnitude, -1, 1))
end

-- Lerp function
local function Lerp(a, b, t)
    return a + (b - a) * t
end

-- Remap value from one range to another
local function Remap(value, inputMin, inputMax, outputMin, outputMax)
    return outputMin + ((value - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin)
end

-- Random with seed
local RandomSeed = tick() % 1000
local function SeededRandom(min, max)
    RandomSeed = (RandomSeed * 16807) % 2147483647
    return min + (RandomSeed / 2147483647) * (max - min)
end

-- Find ball utility
local function GetBall()
    for _, Ball in ipairs(workspace.Balls:GetChildren()) do
        if Ball:GetAttribute("realBall") then
            return Ball
        end
    end
    return nil
end

-- Check if a ball is curved
local function IsBallCurved(ball)
    if not ball then return false end
    
    local zoomies = ball:FindFirstChild("zoomies")
    if not zoomies then return false end
    
    local velocity = zoomies.VectorVelocity
    
    -- Calculate recent direction changes
    if #BallVelocityHistory >= 3 then
        local currentDirection = velocity.Unit
        local previousDirection = BallVelocityHistory[#BallVelocityHistory].Unit
        
        local directionChange = (currentDirection - previousDirection).Magnitude
        if directionChange > BallDetectionSettings.DirectionChangeThreshold then
            return true
        end
    end
    
    -- Check for curved path
    if Character and HumanoidRootPart and ball:GetAttribute("target") == LocalPlayer.Name then
        local ballToPlayer = (HumanoidRootPart.Position - ball.Position).Unit
        local ballDirection = velocity.Unit
        local dotProduct = ballToPlayer:Dot(ballDirection)
        
        -- If dot product is between 0.5 and 0.85, likely curved
        if dotProduct > 0.5 and dotProduct < 0.85 then
            return true
        end
    end
    
    return false
end

-- Reset connection
local function ResetConnection()
    if Connection then
        Connection:Disconnect()
        Connection = nil
    end
end

-- Detect special ball type
local function GetBallType(ball)
    if not ball then return "Normal" end
    
    local ballType = ball:GetAttribute("type")
    if ballType then
        return ballType
    end
    
    -- Detect by velocity
    local zoomies = ball:FindFirstChild("zoomies")
    if zoomies and zoomies.VectorVelocity.Magnitude > BallDetectionSettings.VelocityThreshold then
        return "Fast"
    end
    
    -- Detect by size
    if ball.Size.Magnitude > BallDetectionSettings.SizeThreshold * 3 then
        return "Large"
    end
    
    return "Normal"
end

-- Track ball changes 
workspace.Balls.ChildAdded:Connect(function()
    SessionStats.BallsDetected = SessionStats.BallsDetected + 1
    local Ball = GetBall()
    if not Ball then return end
    
    ResetConnection()
    
    -- Create new entry in ball history
    local newBallData = {
        InitialPosition = Ball.Position,
        InitialVelocity = Ball:FindFirstChild("zoomies") and Ball.zoomies.VectorVelocity or Vector3.new(0,0,0),
        CreationTime = tick(),
        LastUpdatedTime = tick(),
        Type = GetBallType(Ball),
        Path = {Ball.Position},
        Velocities = {Ball:FindFirstChild("zoomies") and Ball.zoomies.VectorVelocity or Vector3.new(0,0,0)},
        TargetHistory = {},
        IsCurved = false,
        Bounces = 0,
        PredictedPositions = {},
        HitDetected = false
    }
    
    table.insert(BallHistoryData, newBallData)
    if #BallHistoryData > 10 then
        table.remove(BallHistoryData, 1)
    end
    
    CurrentBallData = newBallData
    
    Connection = Ball:GetAttributeChangedSignal("target"):Connect(function()
        IsParried = false
        local target = Ball:GetAttribute("target")
        CurrentBallTarget = target
        
        -- Record target change in history
        table.insert(CurrentBallData.TargetHistory, {
            Target = target,
            Time = tick()
        })
        
        if target == LocalPlayer.Name then
            DebugPrint("Ball targeting me! Current distance:", (Ball.Position - HumanoidRootPart.Position).Magnitude)
        end
    end)
end)

--// PARRY DATA MANAGEMENT //--
-- Function to update parry data based on selected curve type
local function UpdateParryData(parryType)
    local Camera = workspace.CurrentCamera
    local Vector3_Mouse_Location
    local Mouse_Location = UserInputService:GetMouseLocation()
    Vector3_Mouse_Location = {Mouse_Location.X, Mouse_Location.Y}
    
    local Events = {}
    for _, v in pairs(Alive:GetChildren()) do
        if v:FindFirstChild("PrimaryPart") then
            Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
        end
    end

    local data = nil
    if parryType == "Custom" then
        data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}
    elseif parryType == "Backwards" then
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.LookVector * 1000)), Events, Vector3_Mouse_Location}
    elseif parryType == "Random" then
        data = {0, CFrame.new(Camera.CFrame.Position, Vector3.new(math.random(-3000,3000), math.random(-3000,3000), math.random(-3000,3000))), Events, Vector3_Mouse_Location}
    elseif parryType == "Straight" then
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.LookVector * 1000)), Events, Vector3_Mouse_Location}
    elseif parryType == "Up" then
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.UpVector * 1000)), Events, Vector3_Mouse_Location}
    elseif parryType == "Right" then
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.RightVector * 1000)), Events, Vector3_Mouse_Location}
    elseif parryType == "Left" then
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.RightVector * 1000)), Events, Vector3_Mouse_Location}
    elseif parryType == "Down" then
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.UpVector * 1000)), Events, Vector3_Mouse_Location}
    elseif parryType == "Dot" then
        -- Dot mode is default orientation for reliable parry
        data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}
    elseif parryType == "Adaptive" then
        -- Adaptive mode uses ball target information to optimize
        local Ball = GetBall()
        if Ball and Ball:GetAttribute("target") == LocalPlayer.Name and IsBallCurved(Ball) then
            -- Create a CFrame that counters the curve
            local toPlayer = (HumanoidRootPart.Position - Ball.Position).Unit
            local lookPos = Camera.CFrame.Position + toPlayer * 1000
            data = {0, CFrame.new(Camera.CFrame.Position, lookPos), Events, Vector3_Mouse_Location}
        else
            data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}
        end
    elseif parryType == "Smart" then
        -- Smart mode analyzes ball trajectory and chooses best counter
        local Ball = GetBall()
        if Ball and Ball:GetAttribute("target") == LocalPlayer.Name then
            local zoomies = Ball:FindFirstChild("zoomies")
            if zoomies then
                local velocity = zoomies.VectorVelocity
                local ballDirection = velocity.Unit
                local lookPos = Camera.CFrame.Position - ballDirection * 1000
                data = {0, CFrame.new(Camera.CFrame.Position, lookPos), Events, Vector3_Mouse_Location}
            else
                data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}
            end
        else
            data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}
        end
    else
        data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}
    end

    Parry_Data = data
end

-- Initialize parry data on startup
UpdateParryData(ParryType)

--// BALL PREDICTION SYSTEMS //--
-- Enhanced ball position prediction with advanced curve detection
local function PredictBallPosition(Ball, TimeAhead)
    if not Ball then return Vector3.new(0, 0, 0) end
    
    local Velocity = (Ball:FindFirstChild("zoomies") and Ball.zoomies.VectorVelocity) or Ball.Velocity
    local Position = Ball.Position
    
    -- Record current velocity for history
    table.insert(BallVelocityHistory, Velocity)
    if #BallVelocityHistory > BallDetectionSettings.MaxHistoryLength then
        table.remove(BallVelocityHistory, 1)
    end
    
    -- Basic linear prediction
    local BasicPrediction = Position + (Velocity * TimeAhead)
    
    -- Apply velocity smoothing if needed
    local SmoothedVelocity = Velocity
    if #BallVelocityHistory > 1 and BallDetectionSettings.VelocitySmoothingFactor < 1 then
        SmoothedVelocity = Vector3.new(0, 0, 0)
        local totalWeight = 0
        for i = 1, #BallVelocityHistory do
            local weight = i / #BallVelocityHistory
            totalWeight = totalWeight + weight
            SmoothedVelocity = SmoothedVelocity + BallVelocityHistory[i] * weight
        end
        SmoothedVelocity = SmoothedVelocity / totalWeight
        BasicPrediction = Position + (SmoothedVelocity * TimeAhead)
    end
    
    -- Apply curve detection if needed
    local isCurved = IsBallCurved(Ball)
    if isCurved then
        SessionStats.CurvedBallsDetected = SessionStats.CurvedBallsDetected + 1
        
        -- Apply different prediction based on parry type
        if ParryType == "Dot" or ParryType == "Default" then
            -- For Dot mode, add subtle curve compensation
            if Character and HumanoidRootPart then
                local BallToPlayer = (HumanoidRootPart.Position - Position)
                local Distance = BallToPlayer.Magnitude
                
                if Ball:GetAttribute("target") == LocalPlayer.Name then
                    local DotProduct = BallToPlayer.Unit:Dot(Velocity.Unit)
                    
                    -- Adjust prediction based on how indirect the ball's approach is
                    if DotProduct > 0.5 and DotProduct < 0.95 then
                        local CurveAdjustment = BallToPlayer.Unit * TimeAhead * (1 - DotProduct) * 0.8
                        return BasicPrediction + CurveAdjustment
                    end
                end
            end
        elseif ParryType == "Adaptive" or ParryType == "Smart" then
            -- For adaptive modes, use more aggressive curve prediction
            if Character and HumanoidRootPart then
                local BallToPlayer = (HumanoidRootPart.Position - Position)
                
                if Ball:GetAttribute("target") == LocalPlayer.Name then
                    -- Calculate acceleration from velocity history
                    local Acceleration = Vector3.new(0, 0, 0)
                    if #BallVelocityHistory >= 3 then
                        local currentVelocity = BallVelocityHistory[#BallVelocityHistory]
                        local prevVelocity = BallVelocityHistory[#BallVelocityHistory - 2]
                        Acceleration = (currentVelocity - prevVelocity) / 0.1 -- Assuming 0.1s between samples
                    end
                    
                    -- Apply both curve and acceleration adjustment
                    local CurveAdjustment = BallToPlayer.Unit * TimeAhead * 0.7
                    local AccelAdjustment = Acceleration * TimeAhead * TimeAhead * 0.5
                    
                    return BasicPrediction + CurveAdjustment + AccelAdjustment
                end
            end
        end
    end
    
    -- Apply randomized accuracy if enabled
    if RandomizedParryAccuracy then
        local randomFactor = (1 - (ParryAccuracy / 100)) * 0.2
        local randomOffset = Vector3.new(
            (math.random() - 0.5) * randomFactor,
            (math.random() - 0.5) * randomFactor,
            (math.random() - 0.5) * randomFactor
        )
        return BasicPrediction + (Velocity * randomOffset)
    end
    
    -- Record prediction in history
    table.insert(LastPredictedPositions, {
        Position = BasicPrediction,
        Time = tick()
    })
    if #LastPredictedPositions > 10 then
        table.remove(LastPredictedPositions, 1)
    end
    
    return BasicPrediction
end

-- Advanced prediction with bounce detection
local function PredictBallPositionWithBounce(Ball, TimeAhead)
    if not Ball or not BallDetectionSettings.PredictBounces then 
        return PredictBallPosition(Ball, TimeAhead)
    end
    
    -- Get basic prediction first
    local BasicPrediction = PredictBallPosition(Ball, TimeAhead)
    
    -- Cast a ray to detect if the ball will hit any objects
    local rayStart = Ball.Position
    local Velocity = (Ball:FindFirstChild("zoomies") and Ball.zoomies.VectorVelocity) or Ball.Velocity
    local rayDirection = Velocity.Unit * math.min(Velocity.Magnitude * TimeAhead, 100)
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Include
    raycastParams.FilterDescendantsInstances = {workspace.Map}
    
    local raycastResult = workspace:Raycast(rayStart, rayDirection, raycastParams)
    
    if raycastResult then
        -- Ball will hit a wall, calculate bounce
        local hitPoint = raycastResult.Position
        local hitNormal = raycastResult.Normal
        
        -- Calculate time to hit
        local distanceToHit = (hitPoint - Ball.Position).Magnitude
        local timeToHit = distanceToHit / Velocity.Magnitude
        
        -- If hit happens within our prediction window
        if timeToHit < TimeAhead then
            -- Calculate reflection direction
            local reflectionDir = Velocity.Unit - (2 * Velocity.Unit:Dot(hitNormal) * hitNormal)
            
            -- Calculate remaining time after bounce
            local remainingTime = TimeAhead - timeToHit
            
            -- Calculate position after bounce
            local positionAfterBounce = hitPoint + (reflectionDir * Velocity.Magnitude * remainingTime)
            
            return positionAfterBounce
        end
    end
    
    return BasicPrediction
end

-- Optimized prediction function that chooses the best algorithm based on conditions
local function GetOptimalPrediction(Ball, TimeAhead)
    if not Ball then return Vector3.new(0, 0, 0) end
    
    -- Get ball type for specialized handling
    local ballType = GetBallType(Ball)
    if ballType ~= "Normal" then
        SessionStats.SpecialBallsDetected = SessionStats.SpecialBallsDetected + 1
    end
    
    -- Special handling for different ball types
    if ballType == "Fast" then
        -- For fast balls, reduce prediction time slightly
        TimeAhead = TimeAhead * 0.9
    elseif ballType == "Death" or ballType == "SlashFury" then
        -- For dangerous balls, use more aggressive prediction
        local enhancedTimeAhead = TimeAhead * 1.1
        return PredictBallPositionWithBounce(Ball, enhancedTimeAhead)
    elseif ballType == "TimeHole" then
        -- For time hole balls, compensate for temporal effects
        local modifiedTime = TimeAhead + 0.05
        return PredictBallPositionWithBounce(Ball, modifiedTime)
    end
    
    -- Use bounce prediction if enabled
    if BallDetectionSettings.PredictBounces then
        return PredictBallPositionWithBounce(Ball, TimeAhead)
    else
        return PredictBallPosition(Ball, TimeAhead)
    end
end

--// PARRY MECHANICS //--
-- Primary Auto Parry function with advanced ball handling
local function AutoParry()
    if not IsAutoParryEnabled then return end
    
    local Ball = GetBall()
    local Character = LocalPlayer.Character
    if not Ball or not Character then return end
    
    local HRP = Character:FindFirstChild("HumanoidRootPart")
    if not HRP then return end
    
    -- Apply accuracy adjustments if enabled
    local effectiveRadius = ParryRadius
    if RandomizedParryAccuracy then
        effectiveRadius = ParryRadius * (ParryAccuracy / 100)
    end
    
    -- Skip if on cooldown or already parried
    if ParryDebounce or IsParried then return end
    
    local shouldParry = false
    
    -- Check if ball is targeting the player
    if Ball:GetAttribute("target") == LocalPlayer.Name and not IsParried then
        -- Get best prediction based on ball conditions
        local PredictedPosition = GetOptimalPrediction(Ball, PredictionTime)
        local DistanceToPredicted = (HRP.Position - PredictedPosition).Magnitude
        
        -- Track total distance for stats
        SessionStats.TotalDistance = SessionStats.TotalDistance + DistanceToPredicted
        
        if DistanceToPredicted <= effectiveRadius then
            shouldParry = true
        end
        
        -- Special detection modes
        if InfinityDetection then
            local zoomies = Ball:FindFirstChild("zoomies")
            if zoomies and zoomies.VectorVelocity.Magnitude > 500 then
                shouldParry = true
            end
        end
        
        if DeathSlashDetection and Ball:GetAttribute("type") == "Death" then
            shouldParry = true
        end
        
        if TimeHoleDetection and Ball:GetAttribute("type") == "TimeHole" then
            shouldParry = true
        end
        
        if SlashOfFuryDetection and Ball:GetAttribute("type") == "SlashFury" then
            shouldParry = true
        end
        
        if AntiPhantom then
            -- Add a small chance to parry when outside normal radius
            if DistanceToPredicted <= effectiveRadius * 1.5 and math.random() < 0.2 then
                shouldParry = true
            end
        end
        
        if shouldParry then
            -- Apply cooldown protection if enabled
            if CooldownProtection and (tick() - Cooldown < 1) then
                return
            end
            
            -- Record attempt time for stats
            LastParryAttemptTime = tick()
            
            -- Simulate latency if set
            if FeatureSettings.FakeLatency > 0 then
                task.wait(FeatureSettings.FakeLatency / 1000) -- Convert ms to seconds
            end
            
            -- Execute parry
            ParryDebounce = true
            UpdateParryData(ParryType)
            
            -- Fire all necessary remotes
            for Remote, Args in pairs(Remotes) do
                if type(Remote) == "userdata" and Remote.Name and Remote.FireServer then
                    if Parry_Data and #Parry_Data >= 4 then
                        Remote:FireServer(Args, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
                    else
                        Remote:FireServer(Args, Parry_Key)
                    end
                end
            end
            
            -- Handle animation fix if enabled
            if FeatureSettings.AnimationFix and Humanoid then
                local Animator = Humanoid:FindFirstChildOfClass("Animator")
                if Animator then
                    for _, track in pairs(Animator:GetPlayingAnimationTracks()) do
                        if track.Name:match("Block") then
                            track:Stop()
                        end
                    end
                end
            end
            
            -- Apply keypress emulation if enabled
            if FeatureSettings.KeypressEmulation then
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
                task.delay(0.05, function()
                    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
                end)
            end
            
            -- Show notification if enabled
            if FeatureSettings.NotifyEnabled then
                -- Visual notification
                StarterGui:SetCore("SendNotification", {
                    Title = CONFIG.Name,
                    Text = "Parried!",
                    Duration = FeatureSettings.NotifyDuration
                })
                
                -- Sound notification
                if FeatureSettings.NotifySound then
                    local sound = Instance.new("Sound")
                    sound.SoundId = FeatureSettings.NotifySoundId
                    sound.Volume = FeatureSettings.NotifySoundVolume
                    sound.Parent = game:GetService("SoundService")
                    sound:Play()
                    game:GetService("Debris"):AddItem(sound, 2)
                end
                
                -- Chat notification
                if FeatureSettings.NotifyWithChat then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        FeatureSettings.NotifyChatTemplate, "All"
                    )
                end
            end
            
            -- Update stats
            IsParried = true
            Cooldown = tick()
            SessionStats.TotalParries = SessionStats.TotalParries + 1
            SessionStats.SuccessfulParries = SessionStats.SuccessfulParries + 1
            SessionStats.CurrentConsecutiveParries = SessionStats.CurrentConsecutiveParries + 1
            SessionStats.LastParryTime = tick()
            
            -- Update max consecutive parries if needed
            if SessionStats.CurrentConsecutiveParries > SessionStats.MaxConsecutiveParries then
                SessionStats.MaxConsecutiveParries = SessionStats.CurrentConsecutiveParries
            end
            
            -- Record reaction time (time since ball targeted player)
            local reactionTime = 0
            if CurrentBallData and CurrentBallData.TargetHistory and #CurrentBallData.TargetHistory > 0 then
                for i = #CurrentBallData.TargetHistory, 1, -1 do
                    if CurrentBallData.TargetHistory[i].Target == LocalPlayer.Name then
                        reactionTime = tick() - CurrentBallData.TargetHistory[i].Time
                        break
                    end
                end
                
                if reactionTime > 0 then
                    table.insert(SessionStats.ReactionTimes, reactionTime)
                    if #SessionStats.ReactionTimes > 20 then
                        table.remove(SessionStats.ReactionTimes, 1)
                    end
                    
                    -- Update average reaction time
                    local total = 0
                    for _, time in ipairs(SessionStats.ReactionTimes) do
                        total = total + time
                    end
                    SessionStats.AverageReactionTime = total / #SessionStats.ReactionTimes
                end
            end
            
            -- Reset parry debounce after small delay
            task.delay(0.1, function()
                ParryDebounce = false
            end)
        end
    end
    
    -- Reset parried state after cooldown
    if IsParried and (tick() - Cooldown) >= 1 then
        IsParried = false
    end
end

-- Auto Spam Parry function
local function AutoSpamParry()
    if not FeatureSettings.AutoSpamEnabled then return end
    
    local Ball = GetBall()
    if not Ball then return end
    
    local Character = LocalPlayer.Character
    if not Character or not Character:FindFirstChild("HumanoidRootPart") then return end
    
    -- Different spam patterns
    local delay = FeatureSettings.AutoSpamRate
    
    if FeatureSettings.AutoSpamMode == "Pattern" then
        local patternIndex = (math.floor(tick() * 10) % #FeatureSettings.AutoSpamPattern) + 1
        delay = FeatureSettings.AutoSpamPattern[patternIndex]
    elseif FeatureSettings.AutoSpamMode == "Random" then
        delay = math.random(
            FeatureSettings.AutoSpamRandomMin * 100, 
            FeatureSettings.AutoSpamRandomMax * 100
        ) / 100
    end
    
    if Ball:GetAttribute("target") == LocalPlayer.Name then
        if tick() - Cooldown >= delay then
            UpdateParryData(ParryType)
            for Remote, Args in pairs(Remotes) do
                if type(Remote) == "userdata" and Remote.Name and Remote.FireServer then
                    if Parry_Data and #Parry_Data >= 4 then
                        Remote:FireServer(Args, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
                    else
                        Remote:FireServer(Args, Parry_Key)
                    end
                end
            end
            Cooldown = tick()
            
            -- Update stats
            SessionStats.TotalParries = SessionStats.TotalParries + 1
        end
    end
end

-- Manual Spam Parry function
local function ManualSpamParry()
    if not FeatureSettings.ManualSpamEnabled then return end
    
    UpdateParryData(ParryType)
    for Remote, Args in pairs(Remotes) do
        if type(Remote) == "userdata" and Remote.Name and Remote.FireServer then
            if Parry_Data and #Parry_Data >= 4 then
                Remote:FireServer(Args, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
            else
                Remote:FireServer(Args, Parry_Key)
            end
        end
    end
    
    -- Update stats
    SessionStats.TotalParries = SessionStats.TotalParries + 1
end

-- Auto Ability function
local function UseAutoAbility()
    if not AutoAbility then return end
    
    local PlayerGui = LocalPlayer:FindFirstChild("PlayerGui")
    if not PlayerGui then return end
    
    local AbilityButton = PlayerGui:FindFirstChild("AbilityButton", true)
    if not AbilityButton then return end
    
    local Ball = GetBall()
    if not Ball then return end
    
    local Character = LocalPlayer.Character
    if Character and Ball:GetAttribute("target") == LocalPlayer.Name then
        local HRP = Character:FindFirstChild("HumanoidRootPart")
        if HRP and (Ball.Position - HRP.Position).Magnitude < 20 then
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
            task.delay(0.05, function()
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
            end)
        end
    end
end

-- Connect to RunService for the main game loop
RunService.PreSimulation:Connect(function()
    -- Update session uptime
    SessionStats.Uptime = tick() - StartTime
    
    -- Execute the primary functions
    AutoParry()
    AutoSpamParry()
    if AutoAbility then UseAutoAbility() end
end)

-- Connect manual spam to user input
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    -- Check for keybinds
    if input.KeyCode == FeatureSettings.ManualSpamKeyBind and FeatureSettings.ManualSpamEnabled then
        ManualSpamParry()
    elseif input.KeyCode == FeatureSettings.ToggleKeybind then
        -- Toggle auto parry
        IsAutoParryEnabled = not IsAutoParryEnabled
        
        -- Update UI if available
        if UI and UI.UpdateToggleState then
            UI.UpdateToggleState("AutoParry", IsAutoParryEnabled)
        end
        
        StarterGui:SetCore("SendNotification", {
            Title = CONFIG.Name,
            Text = "Auto Parry: " .. (IsAutoParryEnabled and "Enabled" or "Disabled"),
            Duration = 1.5
        })
    elseif input.KeyCode == FeatureSettings.ModeKeybind then
        -- Cycle through parry modes
        local modes = {"Dot", "Custom", "Backwards", "Random", "Straight", "Up", "Right", "Left", "Adaptive", "Smart"}
        
        -- Find current index
        local currentIndex = table.find(modes, ParryType) or 1
        
        -- Move to next mode
        currentIndex = (currentIndex % #modes) + 1
        ParryType = modes[currentIndex]
        
        -- Update parry data with new type
        UpdateParryData(ParryType)
        
        -- Update UI if available
        if UI and UI.UpdateDropdownValue then
            UI.UpdateDropdownValue("ParryType", ParryType)
        end
        
        StarterGui:SetCore("SendNotification", {
            Title = CONFIG.Name,
            Text = "Parry Mode: " .. ParryType,
            Duration = 1.5
        })
    elseif input.KeyCode == FeatureSettings.RadiusIncreaseKeybind then
        -- Increase parry radius
        ParryRadius = math.min(ParryRadius + 1, 60)
        
        -- Update UI if available
        if UI and UI.UpdateSliderValue then
            UI.UpdateSliderValue("ParryRadius", ParryRadius)
        end
        
        StarterGui:SetCore("SendNotification", {
            Title = CONFIG.Name,
            Text = "Parry Radius: " .. ParryRadius,
            Duration = 1
        })
    elseif input.KeyCode == FeatureSettings.RadiusDecreaseKeybind then
        -- Decrease parry radius
        ParryRadius = math.max(ParryRadius - 1, 5)
        
        -- Update UI if available
        if UI and UI.UpdateSliderValue then
            UI.UpdateSliderValue("ParryRadius", ParryRadius)
        end
        
        StarterGui:SetCore("SendNotification", {
            Title = CONFIG.Name,
            Text = "Parry Radius: " .. ParryRadius,
            Duration = 1
        })
    end
    
    -- Check for right-click manual spam
    if input.UserInputType == Enum.UserInputType.MouseButton2 and 
       FeatureSettings.ManualSpamEnabled and 
       FeatureSettings.ManualSpamMouseEnabled then
        ManualSpamParry()
    end
end)

-- Connect to RemoteEvent listeners
ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
    if LocalPlayer.Character.Parent ~= Alive then
        return
    end
    
    -- Successful parry confirmed by server
    if SessionStats.LastParryTime > 0 and (tick() - SessionStats.LastParryTime) < 0.5 then
        -- This confirms our last parry was successful
        DebugPrint("Parry success confirmed by server")
    end
end)

ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(_, root)
    if root.Parent and root.Parent ~= LocalPlayer.Character then
        if root.Parent.Parent ~= Alive then
            return
        end
    end
end)

--// UI MODULE //--
-- UI Colors
local Colors = {
    Background = Color3.fromRGB(15, 15, 20),
    WindowBackground = Color3.fromRGB(25, 25, 35),
    SidebarBackground = Color3.fromRGB(20, 20, 30),
    TextPrimary = Color3.fromRGB(240, 240, 250),
    TextSecondary = Color3.fromRGB(180, 180, 200),
    Accent = Color3.fromRGB(140, 70, 240),
    AccentDarker = Color3.fromRGB(100, 50, 200),
    ToggleEnabled = Color3.fromRGB(140, 70, 240),
    ToggleDisabled = Color3.fromRGB(70, 70, 80),
    SliderBackground = Color3.fromRGB(40, 40, 60),
    SliderFill = Color3.fromRGB(140, 70, 240),
    ButtonBackground = Color3.fromRGB(35, 35, 45),
    ButtonHover = Color3.fromRGB(45, 45, 55),
    DropdownBackground = Color3.fromRGB(35, 35, 45),
    BorderColor = Color3.fromRGB(50, 50, 65),
    SectionBackground = Color3.fromRGB(30, 30, 40)
}

-- UI Variables
local FemBladeUI
local MainContainer
local SidebarContainer
local MainContent
local Windows = {}
local ActiveWindow = nil
local Buttons = {}
local Toggles = {}
local Dropdowns = {}
local Sliders = {}
local Sections = {}
local StatusDisplay
local StatsDisplay

-- Helper function to create UI elements
local function Create(instanceType)
    return function(properties)
        local instance = Instance.new(instanceType)
        for property, value in pairs(properties) do
            if property ~= "Parent" then
                instance[property] = value
            end
        end
        if properties.Parent then
            instance.Parent = properties.Parent
        end
        return instance
    end
end

-- UI Corner function
local function AddCorner(instance, radius)
    local corner = Create("UICorner")({
        CornerRadius = UDim.new(0, radius or 5),
        Parent = instance
    })
    return corner
end

-- UI Stroke function
local function AddStroke(instance, color, thickness)
    local stroke = Create("UIStroke")({
        Color = color or Colors.BorderColor,
        Thickness = thickness or 1,
        Parent = instance
    })
    return stroke
end

-- UI Padding function
local function AddPadding(instance, padding)
    local paddingInstance = Create("UIPadding")({
        PaddingTop = UDim.new(0, padding or 5),
        PaddingBottom = UDim.new(0, padding or 5),
        PaddingLeft = UDim.new(0, padding or 5),
        PaddingRight = UDim.new(0, padding or 5),
        Parent = instance
    })
    return paddingInstance
end

-- Shadow effect function
local function AddShadow(instance, transparency)
    local shadow = Create("ImageLabel")({
        AnchorPoint = Vector2.new(0.5, 0.5),
        BackgroundTransparency = 1,
        Position = UDim2.new(0.5, 0, 0.5, 4),
        Size = UDim2.new(1, 10, 1, 10),
        ZIndex = instance.ZIndex - 1,
        Image = "rbxassetid://7912134082",
        ImageColor3 = Color3.fromRGB(0, 0, 0),
        ImageTransparency = transparency or 0.6,
        ScaleType = Enum.ScaleType.Slice,
        SliceCenter = Rect.new(80, 80, 82, 82),
        SliceScale = 1,
        Parent = instance
    })
    return shadow
end

-- Create primary UI
local function CreateMainUI()
    -- Create ScreenGui with similar style to the screenshot
    local ScreenGui = Create("ScreenGui")({
        Name = "FemBladeUI",
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
    })
    
    -- Try multiple ways to parent the UI for different exploit compatibilities
    local success = pcall(function()
        ScreenGui.Parent = game:GetService("CoreGui")
    end)
    
    if not success then
        ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end
    
    -- Create Main Container with darker theme like in screenshot
    MainContainer = Create("Frame")({
        Name = "MainContainer",
        Size = UDim2.new(0, 850, 0, 450),
        Position = UDim2.new(0.5, -425, 0.5, -225),
        BackgroundColor3 = Color3.fromRGB(10, 10, 15), -- Darker background
        BorderSizePixel = 0,
        ZIndex = 10,
        Parent = ScreenGui
    })
    AddCorner(MainContainer, 10) -- Rounded corners as shown in screenshot
    AddShadow(MainContainer, 0.5) -- More pronounced shadow
    
    -- Make UI draggable
    local dragging = false
    local dragInput, mousePos, framePos
    
    MainContainer.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            mousePos = input.Position
            framePos = MainContainer.Position
        end
    end)
    
    MainContainer.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and dragging then
            local delta = input.Position - mousePos
            MainContainer.Position = UDim2.new(
                framePos.X.Scale,
                framePos.X.Offset + delta.X,
                framePos.Y.Scale,
                framePos.Y.Offset + delta.Y
            )
        end
    end)
    
    -- Create Top bar with icon and title like in the screenshot
    local TopBar = Create("Frame")({
        Name = "TopBar",
        Size = UDim2.new(1, 0, 0, 35),
        Position = UDim2.new(0, 0, 0, 0),
        BackgroundColor3 = Color3.fromRGB(15, 15, 22),
        BorderSizePixel = 0,
        ZIndex = 11,
        Parent = MainContainer
    })
    
    -- Logo Icon (similar to the "Flow" logo in screenshot)
    local LogoFrame = Create("Frame")({
        Name = "LogoFrame",
        Size = UDim2.new(0, 30, 0, 30),
        Position = UDim2.new(0, 10, 0, 3),
        BackgroundTransparency = 1,
        ZIndex = 12,
        Parent = TopBar
    })
    
    -- Create a square with rounded corners for the logo
    local LogoSquare = Create("Frame")({
        Name = "LogoSquare",
        Size = UDim2.new(1, 0, 1, 0),
        Position = UDim2.new(0, 0, 0, 0),
        BackgroundColor3 = Color3.fromRGB(140, 70, 240),
        BorderSizePixel = 0,
        ZIndex = 12,
        Parent = LogoFrame
    })
    AddCorner(LogoSquare, 6)
    
    -- Create logo detail (flow symbol)
    local LogoSymbol = Create("Frame")({
        Name = "LogoSymbol",
        Size = UDim2.new(0.7, 0, 0.7, 0),
        Position = UDim2.new(0.15, 0, 0.15, 0),
        BackgroundColor3 = Color3.fromRGB(15, 15, 22),
        BorderSizePixel = 0,
        ZIndex = 13,
        Parent = LogoSquare
    })
    AddCorner(LogoSymbol, 4)
    
    -- Title with FemBlade instead of Flow as in screenshot
    local Title = Create("TextLabel")({
        Name = "Title",
        Size = UDim2.new(0, 100, 1, 0),
        Position = UDim2.new(0, 45, 0, 0),
        BackgroundTransparency = 1,
        Text = "FemBlade",
        TextColor3 = Color3.fromRGB(240, 240, 250),
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.GothamBold,
        TextSize = 16,
        ZIndex = 12,
        Parent = TopBar
    })
    
    -- Version display
    local Version = Create("TextLabel")({
        Name = "Version",
        Size = UDim2.new(0, 100, 1, 0),
        Position = UDim2.new(1, -110, 0, 0),
        BackgroundTransparency = 1,
        Text = "v" .. CONFIG.Version,
        TextColor3 = Color3.fromRGB(180, 180, 200),
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        ZIndex = 12,
        Parent = TopBar
    })
    
    -- Close Button (X) in top right
    local CloseButton = Create("TextButton")({
        Name = "CloseButton",
        Size = UDim2.new(0, 25, 0, 25),
        Position = UDim2.new(1, -30, 0, 5),
        BackgroundTransparency = 1,
        Text = "✕",
        TextColor3 = Color3.fromRGB(200, 200, 220),
        Font = Enum.Font.GothamBold,
        TextSize = 16,
        ZIndex = 12,
        Parent = TopBar
    })
    
    CloseButton.MouseEnter:Connect(function()
        CloseButton.TextColor3 = Color3.fromRGB(255, 100, 100)
    end)
    
    CloseButton.MouseLeave:Connect(function()
        CloseButton.TextColor3 = Color3.fromRGB(200, 200, 220)
    end)
    
    CloseButton.MouseButton1Click:Connect(function()
        ScreenGui.Enabled = false
    end)
    
    -- Sidebar similar to the screenshot
    SidebarContainer = Create("Frame")({
        Name = "Sidebar",
        Size = UDim2.new(0, 180, 1, -35),
        Position = UDim2.new(0, 0, 0, 35),
        BackgroundColor3 = Color3.fromRGB(18, 18, 25),
        BorderSizePixel = 0,
        ZIndex = 11,
        Parent = MainContainer
    })
    
    -- Add padding to sidebar
    local SidebarPadding = Create("UIPadding")({
        PaddingTop = UDim.new(0, 10),
        PaddingLeft = UDim.new(0, 10),
        PaddingRight = UDim.new(0, 10),
        PaddingBottom = UDim.new(0, 10),
        Parent = SidebarContainer
    })
    
    -- Create Main Content area
    MainContent = Create("Frame")({
        Name = "MainContent",
        Size = UDim2.new(1, -180, 1, -35),
        Position = UDim2.new(0, 180, 0, 35),
        BackgroundColor3 = Color3.fromRGB(12, 12, 18),
        BorderSizePixel = 0,
        ZIndex = 11,
        Parent = MainContainer
    })
    
    -- Add padding to main content
    local ContentPadding = Create("UIPadding")({
        PaddingTop = UDim.new(0, 10),
        PaddingLeft = UDim.new(0, 10),
        PaddingRight = UDim.new(0, 10),
        PaddingBottom = UDim.new(0, 10),
        Parent = MainContent
    })
    
    -- Create status display area at bottom of sidebar
    StatusDisplay = Create("Frame")({
        Name = "StatusDisplay",
        Size = UDim2.new(1, -10, 0, 60),
        Position = UDim2.new(0, 5, 1, -70),
        BackgroundColor3 = Color3.fromRGB(22, 22, 30),
        BorderSizePixel = 0,
        ZIndex = 12,
        Parent = SidebarContainer
    })
    AddCorner(StatusDisplay, 6)
    
    local StatusTitle = Create("TextLabel")({
        Name = "StatusTitle",
        Size = UDim2.new(1, 0, 0, 20),
        Position = UDim2.new(0, 0, 0, 5),
        BackgroundTransparency = 1,
        Text = "Status",
        TextColor3 = Color3.fromRGB(240, 240, 250),
        TextXAlignment = Enum.TextXAlignment.Center,
        Font = Enum.Font.GothamBold,
        TextSize = 14,
        ZIndex = 13,
        Parent = StatusDisplay
    })
    
    local ParryModeLabel = Create("TextLabel")({
        Name = "ParryModeLabel",
        Size = UDim2.new(0.5, -5, 0, 20),
        Position = UDim2.new(0, 5, 0, 25),
        BackgroundTransparency = 1,
        Text = "Mode:",
        TextColor3 = Color3.fromRGB(180, 180, 200),
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatusDisplay
    })
    
    local ParryModeValue = Create("TextLabel")({
        Name = "ParryModeValue",
        Size = UDim2.new(0.5, -5, 0, 20),
        Position = UDim2.new(0.5, 0, 0, 25),
        BackgroundTransparency = 1,
        Text = ParryType,
        TextColor3 = Color3.fromRGB(140, 70, 240),
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.GothamBold,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatusDisplay
    })
    
    local RadiusLabel = Create("TextLabel")({
        Name = "RadiusLabel",
        Size = UDim2.new(0.5, -5, 0, 20),
        Position = UDim2.new(0, 5, 0, 40),
        BackgroundTransparency = 1,
        Text = "Radius:",
        TextColor3 = Color3.fromRGB(180, 180, 200),
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatusDisplay
    })
    
    local RadiusValue = Create("TextLabel")({
        Name = "RadiusValue",
        Size = UDim2.new(0.5, -5, 0, 20),
        Position = UDim2.new(0.5, 0, 0, 40),
        BackgroundTransparency = 1,
        Text = tostring(ParryRadius),
        TextColor3 = Color3.fromRGB(140, 70, 240),
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.GothamBold,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatusDisplay
    })
    
    -- Stats display
    StatsDisplay = Create("Frame")({
        Name = "StatsDisplay",
        Size = UDim2.new(1, -20, 0, 80),
        Position = UDim2.new(0, 10, 1, -140),
        BackgroundColor3 = Colors.SectionBackground,
        BorderSizePixel = 0,
        ZIndex = 12,
        Visible = false, -- Initially hidden, can be toggled
        Parent = SidebarContainer
    })
    AddCorner(StatsDisplay, 6)
    
    local StatsTitle = Create("TextLabel")({
        Name = "StatsTitle",
        Size = UDim2.new(1, 0, 0, 20),
        Position = UDim2.new(0, 0, 0, 5),
        BackgroundTransparency = 1,
        Text = "Statistics",
        TextColor3 = Colors.TextPrimary,
        TextXAlignment = Enum.TextXAlignment.Center,
        Font = Enum.Font.GothamBold,
        TextSize = 14,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    local ParriesLabel = Create("TextLabel")({
        Name = "ParriesLabel",
        Size = UDim2.new(0.5, -5, 0, 15),
        Position = UDim2.new(0, 5, 0, 25),
        BackgroundTransparency = 1,
        Text = "Parries:",
        TextColor3 = Colors.TextSecondary,
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    local ParriesValue = Create("TextLabel")({
        Name = "ParriesValue",
        Size = UDim2.new(0.5, -5, 0, 15),
        Position = UDim2.new(0.5, 0, 0, 25),
        BackgroundTransparency = 1,
        Text = "0",
        TextColor3 = Colors.Accent,
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.GothamBold,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    local ReactionLabel = Create("TextLabel")({
        Name = "ReactionLabel",
        Size = UDim2.new(0.5, -5, 0, 15),
        Position = UDim2.new(0, 5, 0, 40),
        BackgroundTransparency = 1,
        Text = "Avg. Reaction:",
        TextColor3 = Colors.TextSecondary,
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    local ReactionValue = Create("TextLabel")({
        Name = "ReactionValue",
        Size = UDim2.new(0.5, -5, 0, 15),
        Position = UDim2.new(0.5, 0, 0, 40),
        BackgroundTransparency = 1,
        Text = "0 ms",
        TextColor3 = Colors.Accent,
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.GothamBold,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    local UptimeLabel = Create("TextLabel")({
        Name = "UptimeLabel",
        Size = UDim2.new(0.5, -5, 0, 15),
        Position = UDim2.new(0, 5, 0, 55),
        BackgroundTransparency = 1,
        Text = "Uptime:",
        TextColor3 = Colors.TextSecondary,
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    local UptimeValue = Create("TextLabel")({
        Name = "UptimeValue",
        Size = UDim2.new(0.5, -5, 0, 15),
        Position = UDim2.new(0.5, 0, 0, 55),
        BackgroundTransparency = 1,
        Text = "00:00",
        TextColor3 = Colors.Accent,
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.GothamBold,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    -- Function to create sidebar buttons
    local function CreateSidebarButton(name, text, iconId, order)
        local Button = Create("TextButton")({
            Name = name .. "Button",
            Size = UDim2.new(1, -20, 0, 40),
            Position = UDim2.new(0, 10, 0, 10 + (order - 1) * 50),
            BackgroundColor3 = Colors.ButtonBackground,
            BackgroundTransparency = 0.6,
            BorderSizePixel = 0,
            Text = "",
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            TextColor3 = Colors.TextPrimary,
            ZIndex = 12,
            Parent = SidebarContainer
        })
        AddCorner(Button, 6)
        
        local ButtonIcon = Create("ImageLabel")({
            Name = "Icon",
            Size = UDim2.new(0, 20, 0, 20),
            Position = UDim2.new(0, 10, 0.5, -10),
            BackgroundTransparency = 1,
            Image = iconId or "",
            ImageColor3 = Colors.TextPrimary,
            ZIndex = 13,
            Parent = Button
        })
        
        local ButtonText = Create("TextLabel")({
            Name = "Text",
            Size = UDim2.new(1, -50, 1, 0),
            Position = UDim2.new(0, 40, 0, 0),
            BackgroundTransparency = 1,
            Text = text,
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 13,
            Parent = Button
        })
        
        -- Hover effects
        Button.MouseEnter:Connect(function()
            Button.BackgroundColor3 = Colors.ButtonHover
        end)
        
        Button.MouseLeave:Connect(function()
            Button.BackgroundColor3 = Colors.ButtonBackground
        end)
        
        Buttons[name] = Button
        return Button
    end
    
    -- Create windows (initially hidden)
    local function CreateWindow(name)
        local Window = Create("ScrollingFrame")({
            Name = name .. "Window",
            Size = UDim2.new(1, -20, 1, -20),
            Position = UDim2.new(0, 10, 0, 10),
            BackgroundColor3 = Colors.WindowBackground,
            BorderSizePixel = 0,
            ScrollBarThickness = 4,
            ScrollBarImageColor3 = Colors.AccentDarker,
            CanvasSize = UDim2.new(0, 0, 0, 0),
            Visible = false,
            ZIndex = 12,
            Parent = MainContent
        })
        AddCorner(Window, 8)
        AddPadding(Window, 15)
        
        -- Layout for content
        local ListLayout = Create("UIListLayout")({
            Padding = UDim.new(0, 10),
            SortOrder = Enum.SortOrder.LayoutOrder,
            Parent = Window
        })
        
        -- Automatically update canvas size
        ListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
            Window.CanvasSize = UDim2.new(0, 0, 0, ListLayout.AbsoluteContentSize.Y + 30)
        end)
        
        Windows[name] = Window
        return Window
    end
    
    -- Function to create section in window
    local function CreateSection(window, name, description)
        local Section = Create("Frame")({
            Name = name .. "Section",
            Size = UDim2.new(1, 0, 0, 0), -- Auto size
            BackgroundColor3 = Colors.SectionBackground,
            BorderSizePixel = 0,
            AutomaticSize = Enum.AutomaticSize.Y,
            ZIndex = 13,
            Parent = window
        })
        AddCorner(Section, 8)
        AddPadding(Section, 10)
        
        -- Section title and description
        local SectionTitle = Create("TextLabel")({
            Name = "Title",
            Size = UDim2.new(1, -20, 0, 20),
            Position = UDim2.new(0, 10, 0, 5),
            BackgroundTransparency = 1,
            Text = name,
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.GothamBold,
            TextSize = 16,
            ZIndex = 14,
            Parent = Section
        })
        
        if description then
            local SectionDesc = Create("TextLabel")({
                Name = "Description",
                Size = UDim2.new(1, -20, 0, 20),
                Position = UDim2.new(0, 10, 0, 25),
                BackgroundTransparency = 1,
                Text = description,
                TextColor3 = Colors.TextSecondary,
                TextXAlignment = Enum.TextXAlignment.Left,
                Font = Enum.Font.Gotham,
                TextSize = 14,
                ZIndex = 14,
                Parent = Section
            })
        end
        
        -- Layout for section content
        local ContentLayout = Create("UIListLayout")({
            Padding = UDim.new(0, 10),
            SortOrder = Enum.SortOrder.LayoutOrder,
            Parent = Section
        })
        
        -- Ensure layout properly positions everything
        ContentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
            Section.Size = UDim2.new(1, 0, 0, ContentLayout.AbsoluteContentSize.Y + 20)
        end)
        
        -- Add to sections table
        local sectionInfo = {
            Container = Section,
            Title = SectionTitle,
            Description = description and SectionDesc or nil,
            Elements = {}
        }
        
        Sections[name] = sectionInfo
        return sectionInfo
    end
    
    -- Function to create toggle
    local function CreateToggle(section, name, description, default, callback)
        local ToggleContainer = Create("Frame")({
            Name = name .. "Container",
            Size = UDim2.new(1, -20, 0, 40),
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            ZIndex = 14,
            LayoutOrder = #section.Elements + 1,
            Parent = section.Container
        })
        
        local ToggleInfo = Create("Frame")({
            Name = "Info",
            Size = UDim2.new(0.7, 0, 1, 0),
            BackgroundTransparency = 1,
            ZIndex = 15,
            Parent = ToggleContainer
        })
        
        local ToggleLabel = Create("TextLabel")({
            Name = "Label",
            Size = UDim2.new(1, 0, 0.5, 0),
            BackgroundTransparency = 1,
            Text = name,
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 16,
            Parent = ToggleInfo
        })
        
        if description then
            local ToggleDesc = Create("TextLabel")({
                Name = "Description",
                Size = UDim2.new(1, 0, 0.5, 0),
                Position = UDim2.new(0, 0, 0.5, 0),
                BackgroundTransparency = 1,
                Text = description,
                TextColor3 = Colors.TextSecondary,
                TextXAlignment = Enum.TextXAlignment.Left,
                Font = Enum.Font.Gotham,
                TextSize = 12,
                ZIndex = 16,
                Parent = ToggleInfo
            })
        end
        
        -- Create toggle indicator
        local ToggleFrame = Create("Frame")({
            Name = "ToggleFrame",
            Size = UDim2.new(0, 40, 0, 20),
            Position = UDim2.new(1, -40, 0.5, -10),
            BackgroundColor3 = default and Colors.ToggleEnabled or Colors.ToggleDisabled,
            BorderSizePixel = 0,
            ZIndex = 15,
            Parent = ToggleContainer
        })
        AddCorner(ToggleFrame, 10)
        
        local ToggleCircle = Create("Frame")({
            Name = "ToggleCircle",
            Size = UDim2.new(0, 16, 0, 16),
            Position = UDim2.new(default and 1 or 0, default and -18 or 2, 0.5, -8),
            BackgroundColor3 = Color3.fromRGB(255, 255, 255),
            BorderSizePixel = 0,
            ZIndex = 16,
            Parent = ToggleFrame
        })
        AddCorner(ToggleCircle, 8)
        
        -- Make toggle interactive
        local enabled = default or false
        
        local function UpdateToggle()
            enabled = not enabled
            
            local newPosition = enabled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
            local newColor = enabled and Colors.ToggleEnabled or Colors.ToggleDisabled
            
            -- Animate the toggle
            TweenService:Create(ToggleCircle, TweenInfo.new(0.2), {Position = newPosition}):Play()
            TweenService:Create(ToggleFrame, TweenInfo.new(0.2), {BackgroundColor3 = newColor}):Play()
            
            -- Call callback
            callback(enabled)
        end
        
        ToggleContainer.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                UpdateToggle()
            end
        end)
        
        -- Add to section's elements
        table.insert(section.Elements, ToggleContainer)
        
        -- Add to toggles table
        local toggleInfo = {
            Container = ToggleContainer,
            Frame = ToggleFrame,
            Circle = ToggleCircle,
            Enabled = enabled,
            SetEnabled = function(state)
                if state ~= enabled then
                    UpdateToggle()
                end
            end
        }
        
        Toggles[name] = toggleInfo
        return toggleInfo
    end
    
    -- Function to create dropdown
    local function CreateDropdown(section, name, options, default, callback)
        local DropdownContainer = Create("Frame")({
            Name = name .. "Container",
            Size = UDim2.new(1, -20, 0, 50),
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            ZIndex = 14,
            LayoutOrder = #section.Elements + 1,
            Parent = section.Container
        })
        
        local DropdownLabel = Create("TextLabel")({
            Name = "Label",
            Size = UDim2.new(1, 0, 0, 20),
            BackgroundTransparency = 1,
            Text = name,
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 15,
            Parent = DropdownContainer
        })
        
        local DropdownFrame = Create("TextButton")({
            Name = "DropdownFrame",
            Size = UDim2.new(1, 0, 0, 30),
            Position = UDim2.new(0, 0, 0, 20),
            BackgroundColor3 = Colors.DropdownBackground,
            BorderSizePixel = 0,
            Text = "",
            ZIndex = 15,
            Parent = DropdownContainer
        })
        AddCorner(DropdownFrame, 6)
        
        local SelectedOption = Create("TextLabel")({
            Name = "SelectedOption",
            Size = UDim2.new(1, -30, 1, 0),
            Position = UDim2.new(0, 10, 0, 0),
            BackgroundTransparency = 1,
            Text = default or options[1],
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.Gotham,
            TextSize = 14,
            ZIndex = 16,
            Parent = DropdownFrame
        })
        
        local DropdownArrow = Create("TextLabel")({
            Name = "Arrow",
            Size = UDim2.new(0, 20, 1, 0),
            Position = UDim2.new(1, -20, 0, 0),
            BackgroundTransparency = 1,
            Text = "▼",
            TextColor3 = Colors.TextPrimary,
            Font = Enum.Font.Gotham,
            TextSize = 14,
            ZIndex = 16,
            Parent = DropdownFrame
        })
        
        -- Create dropdown list (initially hidden)
        local DropdownList = Create("Frame")({
            Name = "DropdownList",
            Size = UDim2.new(1, 0, 0, #options * 30),
            Position = UDim2.new(0, 0, 1, 5),
            BackgroundColor3 = Colors.DropdownBackground,
            BorderSizePixel = 0,
            Visible = false,
            ZIndex = 20,
            Parent = DropdownFrame
        })
        AddCorner(DropdownList, 6)
        
        -- Add options to dropdown list
        for i, option in ipairs(options) do
            local OptionButton = Create("TextButton")({
                Name = "Option_" .. option,
                Size = UDim2.new(1, 0, 0, 30),
                Position = UDim2.new(0, 0, 0, (i-1) * 30),
                BackgroundColor3 = Colors.DropdownBackground,
                BackgroundTransparency = 0.3,
                BorderSizePixel = 0,
                Text = "",
                ZIndex = 21,
                Parent = DropdownList
            })
            
            local OptionText = Create("TextLabel")({
                Name = "Text",
                Size = UDim2.new(1, -20, 1, 0),
                Position = UDim2.new(0, 10, 0, 0),
                BackgroundTransparency = 1,
                Text = option,
                TextColor3 = Colors.TextPrimary,
                TextXAlignment = Enum.TextXAlignment.Left,
                Font = Enum.Font.Gotham,
                TextSize = 14,
                ZIndex = 22,
                Parent = OptionButton
            })
            
            -- Option selection logic
            OptionButton.MouseButton1Click:Connect(function()
                SelectedOption.Text = option
                DropdownList.Visible = false
                callback(option)
            end)
            
            -- Hover effect
            OptionButton.MouseEnter:Connect(function()
                OptionButton.BackgroundTransparency = 0.1
            end)
            
            OptionButton.MouseLeave:Connect(function()
                OptionButton.BackgroundTransparency = 0.3
            end)
        end
        
        -- Toggle dropdown list visibility
        DropdownFrame.MouseButton1Click:Connect(function()
            DropdownList.Visible = not DropdownList.Visible
            DropdownArrow.Text = DropdownList.Visible and "▲" or "▼"
        end)
        
        -- Close dropdown when clicking elsewhere
        UserInputService.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local mousePos = UserInputService:GetMouseLocation()
                local dropdownPos = DropdownFrame.AbsolutePosition
                local dropdownSize = DropdownFrame.AbsoluteSize
                local listPos = DropdownList.AbsolutePosition
                local listSize = DropdownList.AbsoluteSize
                
                if DropdownList.Visible then
                    -- Check if click is outside dropdown and its list
                    if not (mousePos.X >= dropdownPos.X and mousePos.X <= dropdownPos.X + dropdownSize.X and
                            mousePos.Y >= dropdownPos.Y and mousePos.Y <= dropdownPos.Y + dropdownSize.Y) and
                       not (mousePos.X >= listPos.X and mousePos.X <= listPos.X + listSize.X and
                            mousePos.Y >= listPos.Y and mousePos.Y <= listPos.Y + listSize.Y) then
                        DropdownList.Visible = false
                        DropdownArrow.Text = "▼"
                    end
                end
            end
        end)
        
        -- Add to section's elements
        table.insert(section.Elements, DropdownContainer)
        
        -- Add to dropdowns table
        local dropdownInfo = {
            Container = DropdownContainer,
            Frame = DropdownFrame,
            Selected = SelectedOption,
            List = DropdownList,
            SetOption = function(option)
                if table.find(options, option) then
                    SelectedOption.Text = option
                    callback(option)
                end
            end
        }
        
        Dropdowns[name] = dropdownInfo
        return dropdownInfo
    end
    
    -- Function to create slider
    local function CreateSlider(section, name, min, max, default, suffix, callback)
        local SliderContainer = Create("Frame")({
            Name = name .. "Container",
            Size = UDim2.new(1, -20, 0, 50),
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            ZIndex = 14,
            LayoutOrder = #section.Elements + 1,
            Parent = section.Container
        })
        
        local SliderInfo = Create("Frame")({
            Name = "SliderInfo",
            Size = UDim2.new(1, 0, 0, 20),
            BackgroundTransparency = 1,
            ZIndex = 15,
            Parent = SliderContainer
        })
        
        local SliderLabel = Create("TextLabel")({
            Name = "Label",
            Size = UDim2.new(0.7, 0, 1, 0),
            BackgroundTransparency = 1,
            Text = name,
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 16,
            Parent = SliderInfo
        })
        
        local SliderValue = Create("TextLabel")({
            Name = "Value",
            Size = UDim2.new(0.3, 0, 1, 0),
            Position = UDim2.new(0.7, 0, 0, 0),
            BackgroundTransparency = 1,
            Text = default .. (suffix or ""),
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Right,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 16,
            Parent = SliderInfo
        })
        
        -- Create slider elements
        local SliderBackground = Create("Frame")({
            Name = "Background",
            Size = UDim2.new(1, 0, 0, 6),
            Position = UDim2.new(0, 0, 0, 30),
            BackgroundColor3 = Colors.SliderBackground,
            BorderSizePixel = 0,
            ZIndex = 15,
            Parent = SliderContainer
        })
        AddCorner(SliderBackground, 3)
        
        local fillRatio = (default - min) / (max - min)
        local SliderFill = Create("Frame")({
            Name = "Fill",
            Size = UDim2.new(fillRatio, 0, 1, 0),
            BackgroundColor3 = Colors.SliderFill,
            BorderSizePixel = 0,
            ZIndex = 16,
            Parent = SliderBackground
        })
        AddCorner(SliderFill, 3)
        
        local SliderButton = Create("Frame")({
            Name = "Button",
            Size = UDim2.new(0, 14, 0, 14),
            Position = UDim2.new(fillRatio, -7, 0.5, -7),
            BackgroundColor3 = Color3.fromRGB(255, 255, 255),
            BorderSizePixel = 0,
            ZIndex = 17,
            Parent = SliderBackground
        })
        AddCorner(SliderButton, 7)
        
        -- Slider functionality
        local dragging = false
        local value = default
        
        local function UpdateSlider(input)
            local mousePos = input.Position.X
            local sliderPos = SliderBackground.AbsolutePosition.X
            local sliderSize = SliderBackground.AbsoluteSize.X
            
            local relativePos = math.clamp(mousePos - sliderPos, 0, sliderSize)
            local relativeValue = min + (max - min) * (relativePos / sliderSize)
            
            -- Round to 1 decimal place
            value = math.floor(relativeValue * 10) / 10
            value = math.clamp(value, min, max)
            
            -- Update UI
            SliderValue.Text = value .. (suffix or "")
            local newRatio = (value - min) / (max - min)
            SliderFill.Size = UDim2.new(newRatio, 0, 1, 0)
            SliderButton.Position = UDim2.new(newRatio, -7, 0.5, -7)
            
            callback(value)
        end
        
        SliderButton.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
            end
        end)
        
        SliderBackground.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                UpdateSlider(input)
            end
        end)
        
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                UpdateSlider(input)
            end
        end)
        
        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
            end
        end)
        
        -- Add to section's elements
        table.insert(section.Elements, SliderContainer)
        
        -- Add to sliders table
        local sliderInfo = {
            Container = SliderContainer,
            Background = SliderBackground,
            Fill = SliderFill,
            Button = SliderButton,
            Value = value,
            SetValue = function(newValue)
                value = math.clamp(newValue, min, max)
                SliderValue.Text = value .. (suffix or "")
                local newRatio = (value - min) / (max - min)
                SliderFill.Size = UDim2.new(newRatio, 0, 1, 0)
                SliderButton.Position = UDim2.new(newRatio, -7, 0.5, -7)
                callback(value)
            end
        }
        
        Sliders[name] = sliderInfo
        return sliderInfo
    end
    
    -- Function to create counter display
    local function CreateCounter(section, name, value)
        local CounterContainer = Create("Frame")({
            Name = name .. "Container",
            Size = UDim2.new(1, -20, 0, 30),
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            ZIndex = 14,
            LayoutOrder = #section.Elements + 1,
            Parent = section.Container
        })
        
        local CounterLabel = Create("TextLabel")({
            Name = "Label",
            Size = UDim2.new(0.7, 0, 1, 0),
            BackgroundTransparency = 1,
            Text = name,
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 15,
            Parent = CounterContainer
        })
        
        local CounterValue = Create("TextLabel")({
            Name = "Value",
            Size = UDim2.new(0.3, 0, 1, 0),
            Position = UDim2.new(0.7, 0, 0, 0),
            BackgroundTransparency = 1,
            Text = value or "0",
            TextColor3 = Colors.Accent,
            TextXAlignment = Enum.TextXAlignment.Right,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 15,
            Parent = CounterContainer
        })
        
        -- Add to section's elements
        table.insert(section.Elements, CounterContainer)
        
        return {
            Container = CounterContainer,
            Label = CounterLabel,
            Counter = CounterValue,
            SetValue = function(newValue)
                CounterValue.Text = newValue
            end
        }
    end
    
    -- CREATE SIDEBAR BUTTONS --
    local BlatantButton = CreateSidebarButton("Blatant", "Blatant", nil, 1)
    local VisualsButton = CreateSidebarButton("Visuals", "Visuals", nil, 2)
    local MiscButton = CreateSidebarButton("Misc", "Miscellaneous", nil, 3)
    local SettingsButton = CreateSidebarButton("Settings", "Settings", nil, 4)
    
    -- CREATE WINDOWS --
    local BlatantWindow = CreateWindow("Blatant")
    local VisualsWindow = CreateWindow("Visuals")
    local MiscWindow = CreateWindow("Misc")
    local SettingsWindow = CreateWindow("Settings")
    
    -- CREATE BLATANT TAB SECTIONS --
    local AutoParrySection = CreateSection(BlatantWindow, "Auto Parry", "Automatically parries ball")
    local AutoSpamSection = CreateSection(BlatantWindow, "Auto Spam Parry", "Automatically spam parries ball")
    local ManualSpamSection = CreateSection(BlatantWindow, "Manual Spam Parry", "Manually spam's parry")
    local TriggerBotSection = CreateSection(BlatantWindow, "Triggerbot", "Instantly hits ball when targeted")
    
    -- CREATE VISUALS TAB SECTIONS --
    local VisualizationSection = CreateSection(VisualsWindow, "Visualization", "Visual elements for parry feedback")
    local UICustomizationSection = CreateSection(VisualsWindow, "UI Customization", "Customize UI appearance")
    
    -- CREATE MISC TAB SECTIONS --
    local UtilitySection = CreateSection(MiscWindow, "Utility", "Additional useful features")
    local KeybindSection = CreateSection(MiscWindow, "Keybinds", "Keyboard shortcuts")
    
    -- CREATE SETTINGS TAB SECTIONS --
    local GeneralSettingsSection = CreateSection(SettingsWindow, "General Settings", "Basic configuration")
    local PerformanceSection = CreateSection(SettingsWindow, "Performance", "Optimize performance")
    
    -- CREATE AUTO PARRY CONTENT --
    -- Parry counter
    local ParryCounter = CreateCounter(AutoParrySection, "Parries", "0")
    
    -- Auto Parry toggle
    local APToggle = CreateToggle(AutoParrySection, "Auto Parry", "Automatically parries ball", false, function(state)
        IsAutoParryEnabled = state
    end)
    
    -- Parry Type dropdown
    local ParryTypeDropdown = CreateDropdown(AutoParrySection, "Parry Type", 
        {"Dot", "Custom", "Backwards", "Random", "Straight", "Up", "Right", "Left", "Adaptive", "Smart"}, 
        ParryType, function(option)
            ParryType = option
            UpdateParryData(option)
            
            -- Update status display
            if StatusDisplay then
                StatusDisplay.ParryModeValue.Text = option
            end
        end)
    
    -- Parry Accuracy slider
    local ParryAccuracySlider = CreateSlider(AutoParrySection, "Parry Accuracy", 0, 100, ParryAccuracy, "%", function(value)
        ParryAccuracy = value
    end)
    
    -- Parry Radius slider
    local ParryRadiusSlider = CreateSlider(AutoParrySection, "Parry Threshold", 5, 60, ParryRadius, "", function(value)
        ParryRadius = value
        
        -- Update status display
        if StatusDisplay then
            StatusDisplay.RadiusValue.Text = tostring(value)
        end
    end)
    
    -- Prediction Time slider
    local PredictionTimeSlider = CreateSlider(AutoParrySection, "Prediction Time", 0.05, 0.3, PredictionTime, "s", function(value)
        PredictionTime = value
    end)
    
    -- Additional toggles
    local RandomAccuracyToggle = CreateToggle(AutoParrySection, "Randomized Parry Accuracy", "Adds some randomness to parries", false, function(state)
        RandomizedParryAccuracy = state
    end)
    
    local InfinityDetectionToggle = CreateToggle(AutoParrySection, "Infinity Detection", "Detects infinity ability balls", false, function(state)
        InfinityDetection = state
    end)
    
    local DeathDetectionToggle = CreateToggle(AutoParrySection, "Death Slash Detection", "Detects death slash balls", false, function(state)
        DeathSlashDetection = state
    end)
    
    local TimeHoleToggle = CreateToggle(AutoParrySection, "Time Hole Detection", "Detects time hole balls", false, function(state)
        TimeHoleDetection = state
    end)
    
    local SlashOfFuryToggle = CreateToggle(AutoParrySection, "Slash Of Fury Detection", "Detects fury balls", false, function(state)
        SlashOfFuryDetection = state
    end)
    
    local AntiPhantomToggle = CreateToggle(AutoParrySection, "Anti Phantom", "Prevents phantom hits", false, function(state)
        AntiPhantom = state
    end)
    
    local CooldownProtectionToggle = CreateToggle(AutoParrySection, "Cooldown Protection", "Prevents double parries", false, function(state)
        CooldownProtection = state
    end)
    
    local AutoAbilityToggle = CreateToggle(AutoParrySection, "Auto Ability", "Automatically uses ability", false, function(state)
        AutoAbility = state
    end)
    
    -- CREATE AUTO SPAM CONTENT --
    local AutoSpamToggle = CreateToggle(AutoSpamSection, "Auto Spam Parry", "Automatically spam parries ball", false, function(state)
        FeatureSettings.AutoSpamEnabled = state
    end)
    
    local AutoSpamRateSlider = CreateSlider(AutoSpamSection, "Spam Rate", 0.05, 0.5, FeatureSettings.AutoSpamRate, "s", function(value)
        FeatureSettings.AutoSpamRate = value
    end)
    
    local AutoSpamModeDropdown = CreateDropdown(AutoSpamSection, "Spam Mode", 
        {"Constant", "Pattern", "Random"}, 
        FeatureSettings.AutoSpamMode, function(option)
            FeatureSettings.AutoSpamMode = option
        end)
    
    local AnimationFixToggle = CreateToggle(AutoSpamSection, "Animation Fix (DON'T USE IF MOBILE)", "Fixes animation issues", false, function(state)
        FeatureSettings.AnimationFix = state
    end)
    
    -- CREATE MANUAL SPAM CONTENT --
    local ManualSpamToggle = CreateToggle(ManualSpamSection, "Manual Spam Parry", "Manually spam's parry with right-click", false, function(state)
        FeatureSettings.ManualSpamEnabled = state
    end)
    
    local ManualSpamRateSlider = CreateSlider(ManualSpamSection, "Spam Rate", 0.05, 0.5, FeatureSettings.ManualSpamRate, "s", function(value)
        FeatureSettings.ManualSpamRate = value
    end)
    
    -- CREATE TRIGGERBOT CONTENT --
    local TriggerBotToggle = CreateToggle(TriggerBotSection, "Triggerbot", "Instantly hits ball when targeted", false, function(state)
        FeatureSettings.TriggerBotEnabled = state
    end)
    
    local TriggerBotDelaySlider = CreateSlider(TriggerBotSection, "Trigger Delay", 0, 0.2, FeatureSettings.TriggerBotDelay, "s", function(value)
        FeatureSettings.TriggerBotDelay = value
    end)
    
    -- CREATE VISUALIZATION CONTENT --
    local NotifyToggle = CreateToggle(VisualizationSection, "Notify", "Shows notification on parry", false, function(state)
        FeatureSettings.NotifyEnabled = state
    end)
    
    local NotifySoundToggle = CreateToggle(VisualizationSection, "Notify Sound", "Plays sound on parry", false, function(state)
        FeatureSettings.NotifySound = state
    end)
    
    local ShowParryRadiusToggle = CreateToggle(VisualizationSection, "Show Parry Radius", "Visualizes parry radius sphere", false, function(state)
        FeatureSettings.ShowParryRadius = state
    end)
    
    local ShowPredictionPathToggle = CreateToggle(VisualizationSection, "Show Prediction Path", "Visualizes ball path prediction", false, function(state)
        FeatureSettings.ShowPredictionPath = state
    end)
    
    -- CREATE UI CUSTOMIZATION CONTENT --
    local ThemeDropdown = CreateDropdown(UICustomizationSection, "Theme", 
        {"Dark", "Light", "Purple", "Blue", "Green", "Red"}, 
        "Dark", function(option)
            -- Theme switching logic would go here
        end)
    
    local UIScaleSlider = CreateSlider(UICustomizationSection, "UI Scale", 0.5, 1.5, CONFIG.UIScale, "x", function(value)
        CONFIG.UIScale = value
        
        -- Scale logic would go here
    end)
    
    -- CREATE UTILITY CONTENT --
    local KeypressToggle = CreateToggle(UtilitySection, "Keypress", "Simulates keypress on parry", false, function(state)
        FeatureSettings.KeypressEmulation = state
    end)
    
    local CustomCursorToggle = CreateToggle(UtilitySection, "Custom Cursor", "Enables custom cursor", false, function(state)
        FeatureSettings.CustomCursorEnabled = state
    end)
    
    local StatsToggle = CreateToggle(UtilitySection, "Show Stats", "Displays statistics", false, function(state)
        FeatureSettings.ShowStatsInGame = state
        StatsDisplay.Visible = state
    end)
    
    -- CREATE KEYBIND CONTENT --
    local ToggleKeybindDropdown = CreateDropdown(KeybindSection, "Toggle Auto Parry", 
        {"M", "N", "P", "O", "L", "K", "B"}, 
        "M", function(option)
            FeatureSettings.ToggleKeybind = Enum.KeyCode[option]
        end)
    
    local ModeKeybindDropdown = CreateDropdown(KeybindSection, "Cycle Parry Mode", 
        {"N", "M", "P", "O", "L", "K", "B"}, 
        "N", function(option)
            FeatureSettings.ModeKeybind = Enum.KeyCode[option]
        end)
    
    -- CREATE SETTINGS CONTENT --
    local DebugModeToggle = CreateToggle(GeneralSettingsSection, "Debug Mode", "Enables debug output", false, function(state)
        _G.FemBladeDebug = state
    end)
    
    local AntiCheatBypassToggle = CreateToggle(GeneralSettingsSection, "Anti-Cheat Bypass", "Attempts to bypass anti-cheat", true, function(state)
        _G.FemBladeSecurity.AntiCheatBypass = state
    end)
    
    -- CREATE PERFORMANCE CONTENT --
    local OptimizePerformanceToggle = CreateToggle(PerformanceSection, "Optimize Performance", "Reduces resource usage", true, function(state)
        CONFIG.OptimizePerformance = state
    end)
    
    local ReduceAnimationsToggle = CreateToggle(PerformanceSection, "Reduce Animations", "Disables some UI animations", false, function(state)
        CONFIG.ReduceAnimations = state
    end)
    
    -- SETUP BUTTON ACTIONS --
    BlatantButton.MouseButton1Click:Connect(function()
        -- Hide all windows
        for _, window in pairs(Windows) do
            window.Visible = false
        end
        
        -- Show selected window
        BlatantWindow.Visible = true
        ActiveWindow = "Blatant"
    end)
    
    VisualsButton.MouseButton1Click:Connect(function()
        -- Hide all windows
        for _, window in pairs(Windows) do
            window.Visible = false
        end
        
        -- Show selected window
        VisualsWindow.Visible = true
        ActiveWindow = "Visuals"
    end)
    
    MiscButton.MouseButton1Click:Connect(function()
        -- Hide all windows
        for _, window in pairs(Windows) do
            window.Visible = false
        end
        
        -- Show selected window
        MiscWindow.Visible = true
        ActiveWindow = "Misc"
    end)
    
    SettingsButton.MouseButton1Click:Connect(function()
        -- Hide all windows
        for _, window in pairs(Windows) do
            window.Visible = false
        end
        
        -- Show selected window
        SettingsWindow.Visible = true
        ActiveWindow = "Settings"
    end)
    
    -- Show Blatant window by default
    BlatantWindow.Visible = true
    ActiveWindow = "Blatant"
    
    -- Setup stats update loop
    spawn(function()
        while wait(1) do
            if ParryCounter then
                ParryCounter.SetValue(SessionStats.SuccessfulParries)
            end
            
            if StatsDisplay and StatsDisplay.Visible then
                local parryValue = StatsDisplay:FindFirstChild("ParriesValue")
                if parryValue then
                    parryValue.Text = tostring(SessionStats.SuccessfulParries)
                end
                
                local reactionValue = StatsDisplay:FindFirstChild("ReactionValue")
                if reactionValue then
                    reactionValue.Text = string.format("%.2f ms", SessionStats.AverageReactionTime * 1000)
                end
                
                local uptimeValue = StatsDisplay:FindFirstChild("UptimeValue")
                if uptimeValue then
                    uptimeValue.Text = FormatTime(math.floor(SessionStats.Uptime))
                end
            end
        end
    end)
    
    -- Add UI update methods
    local UI = {
        UpdateToggleState = function(name, state)
            if Toggles[name] then
                Toggles[name].SetEnabled(state)
            end
        end,
        
        UpdateDropdownValue = function(name, value)
            if Dropdowns[name] then
                Dropdowns[name].SetOption(value)
            end
        end,
        
        UpdateSliderValue = function(name, value)
            if Sliders[name] then
                Sliders[name].SetValue(value)
            end
        end,
        
        UpdateCounter = function(name, value)
            if name == "Parries" and ParryCounter then
                ParryCounter.SetValue(value)
            end
        end
    }
    
    -- Return the created UI
    FemBladeUI = ScreenGui
    return UI
end

-- Create the UI
local UI = CreateMainUI()

--// ADVANCED EVENT LOGGING SYSTEM //--
-- This module allows detailed tracking of all parry events in the game
local EventLogger = {}
EventLogger.Events = {}
EventLogger.MaxEvents = 100
EventLogger.Initialized = false
EventLogger.DiagnosticsEnabled = true
EventLogger.FileLoggingEnabled = false
EventLogger.LogFilePath = "FemBlade_Logs_" .. os.time() .. ".txt"

function EventLogger:Initialize()
    if self.Initialized then return end
    
    -- Setup the event logging structure
    self.EventTypes = {
        INFO = {Color = Color3.fromRGB(130, 220, 255), Prefix = "[INFO]"},
        SUCCESS = {Color = Color3.fromRGB(100, 255, 100), Prefix = "[SUCCESS]"},
        WARNING = {Color = Color3.fromRGB(255, 225, 75), Prefix = "[WARNING]"},
        ERROR = {Color = Color3.fromRGB(255, 100, 100), Prefix = "[ERROR]"},
        DEBUG = {Color = Color3.fromRGB(180, 180, 180), Prefix = "[DEBUG]"}
    }
    
    self.Initialized = true
    self:Log("Event logger initialized successfully", "INFO")
end

function EventLogger:Log(message, eventType, data)
    if not self.Initialized then self:Initialize() end
    
    eventType = eventType or "INFO"
    if not self.EventTypes[eventType] then eventType = "INFO" end
    
    local event = {
        Type = eventType,
        Message = message,
        Data = data or {},
        Timestamp = os.time(),
        FormattedTime = os.date("%H:%M:%S", os.time())
    }
    
    -- Add to circular buffer of events
    table.insert(self.Events, 1, event)
    if #self.Events > self.MaxEvents then
        table.remove(self.Events, #self.Events)
    end
    
    -- Print to console if diagnostics are enabled
    if self.DiagnosticsEnabled and _G.FemBladeDebug then
        local prefix = self.EventTypes[eventType].Prefix
        print(prefix .. " [" .. event.FormattedTime .. "] " .. message)
        
        if data and _G.FemBladeDebug then
            if type(data) == "table" then
                for k, v in pairs(data) do
                    print("  " .. tostring(k) .. ": " .. tostring(v))
                end
            else
                print("  Data: " .. tostring(data))
            end
        end
    end
    
    -- Write to file if enabled
    if self.FileLoggingEnabled then
        -- In a real environment, this would write to a file
        -- We'll simulate it with a print
        print("FILELOG: " .. self.EventTypes[eventType].Prefix .. " [" .. event.FormattedTime .. "] " .. message)
    end
    
    return event
end

function EventLogger:GetRecentEvents(count, filterType)
    count = count or 10
    local filteredEvents = {}
    
    for _, event in ipairs(self.Events) do
        if not filterType or event.Type == filterType then
            table.insert(filteredEvents, event)
            if #filteredEvents >= count then
                break
            end
        end
    end
    
    return filteredEvents
end

function EventLogger:ClearEvents()
    self.Events = {}
    self:Log("Event log cleared", "INFO")
end

function EventLogger:GenerateReport()
    local report = "=== FemBlade Event Report ===\n"
    report = report .. "Time: " .. os.date("%Y-%m-%d %H:%M:%S") .. "\n"
    report = report .. "Total Events: " .. #self.Events .. "\n\n"
    
    -- Count by type
    local typeCounts = {}
    for _, event in ipairs(self.Events) do
        typeCounts[event.Type] = (typeCounts[event.Type] or 0) + 1
    end
    
    report = report .. "Event Type Distribution:\n"
    for eventType, count in pairs(typeCounts) do
        report = report .. "- " .. eventType .. ": " .. count .. "\n"
    end
    
    report = report .. "\nRecent Events:\n"
    for i = 1, math.min(10, #self.Events) do
        local event = self.Events[i]
        report = report .. event.FormattedTime .. " " .. self.EventTypes[event.Type].Prefix .. " " .. event.Message .. "\n"
    end
    
    return report
end

-- Initialize the logger
EventLogger:Initialize()

--// ADVANCED PERFORMANCE MONITORING //--
-- This module helps track script performance and optimize resource usage
local PerformanceMonitor = {}
PerformanceMonitor.Timers = {}
PerformanceMonitor.Counters = {}
PerformanceMonitor.MemorySnapshots = {}
PerformanceMonitor.MaxSnapshots = 20
PerformanceMonitor.MonitoringEnabled = _G.FemBladeDebug or false
PerformanceMonitor.AutoReport = false
PerformanceMonitor.ReportInterval = 60 -- seconds

function PerformanceMonitor:StartTimer(name)
    if not self.MonitoringEnabled then return end
    self.Timers[name] = {
        StartTime = tick(),
        EndTime = nil,
        Duration = nil,
        Calls = (self.Timers[name] and self.Timers[name].Calls or 0) + 1
    }
    return self.Timers[name].StartTime
end

function PerformanceMonitor:StopTimer(name)
    if not self.MonitoringEnabled or not self.Timers[name] then return end
    
    local timer = self.Timers[name]
    timer.EndTime = tick()
    timer.Duration = timer.EndTime - timer.StartTime
    
    if not timer.MinDuration or timer.Duration < timer.MinDuration then
        timer.MinDuration = timer.Duration
    end
    
    if not timer.MaxDuration or timer.Duration > timer.MaxDuration then
        timer.MaxDuration = timer.Duration
    end
    
    if not timer.TotalDuration then timer.TotalDuration = 0 end
    timer.TotalDuration = timer.TotalDuration + timer.Duration
    timer.AverageDuration = timer.TotalDuration / timer.Calls
    
    return timer.Duration
end

function PerformanceMonitor:Increment(counterName, amount)
    amount = amount or 1
    if not self.Counters[counterName] then
        self.Counters[counterName] = {
            Value = 0,
            LastIncrement = tick(),
            Increments = 0
        }
    end
    
    local counter = self.Counters[counterName]
    counter.Value = counter.Value + amount
    counter.LastIncrement = tick()
    counter.Increments = counter.Increments + 1
    
    return counter.Value
end

function PerformanceMonitor:GetCounter(counterName)
    return self.Counters[counterName] and self.Counters[counterName].Value or 0
end

function PerformanceMonitor:ResetCounter(counterName)
    if self.Counters[counterName] then
        local oldValue = self.Counters[counterName].Value
        self.Counters[counterName].Value = 0
        return oldValue
    end
    return 0
end

function PerformanceMonitor:TakeMemorySnapshot(label)
    if not self.MonitoringEnabled then return end
    
    local snapshot = {
        Label = label or "Snapshot_" .. #self.MemorySnapshots + 1,
        Timestamp = tick(),
        FormattedTime = os.date("%H:%M:%S"),
        -- In a real environment, we would get actual memory stats
        -- Here we'll simulate it 
        Memory = math.random(5000, 10000) -- simulated KB usage
    }
    
    table.insert(self.MemorySnapshots, snapshot)
    if #self.MemorySnapshots > self.MaxSnapshots then
        table.remove(self.MemorySnapshots, 1)
    end
    
    return snapshot
end

function PerformanceMonitor:GenerateReport()
    local report = "=== FemBlade Performance Report ===\n"
    report = report .. "Time: " .. os.date("%Y-%m-%d %H:%M:%S") .. "\n\n"
    
    report = report .. "Timers:\n"
    for name, timer in pairs(self.Timers) do
        report = report .. "- " .. name .. ":\n"
        report = report .. "  Calls: " .. timer.Calls .. "\n"
        if timer.AverageDuration then
            report = report .. "  Avg Duration: " .. string.format("%.6f", timer.AverageDuration) .. "s\n"
            report = report .. "  Min Duration: " .. string.format("%.6f", timer.MinDuration) .. "s\n"
            report = report .. "  Max Duration: " .. string.format("%.6f", timer.MaxDuration) .. "s\n"
        end
    end
    
    report = report .. "\nCounters:\n"
    for name, counter in pairs(self.Counters) do
        report = report .. "- " .. name .. ": " .. counter.Value .. " (" .. counter.Increments .. " increments)\n"
    end
    
    report = report .. "\nMemory Usage:\n"
    if #self.MemorySnapshots > 0 then
        local latestSnapshot = self.MemorySnapshots[#self.MemorySnapshots]
        report = report .. "- Current: " .. latestSnapshot.Memory .. " KB\n"
        
        if #self.MemorySnapshots > 1 then
            local firstSnapshot = self.MemorySnapshots[1]
            local memoryDiff = latestSnapshot.Memory - firstSnapshot.Memory
            report = report .. "- Change: " .. (memoryDiff >= 0 and "+" or "") .. memoryDiff .. " KB\n"
        end
    else
        report = report .. "- No memory snapshots available\n"
    end
    
    return report
end

-- Enable auto-reporting if configured
if PerformanceMonitor.AutoReport and PerformanceMonitor.MonitoringEnabled then
    spawn(function()
        while true do
            wait(PerformanceMonitor.ReportInterval)
            print(PerformanceMonitor:GenerateReport())
        end
    end)
end

-- Take initial memory snapshot
PerformanceMonitor:TakeMemorySnapshot("Initialization")

--// REMOTE SPOOFER //--
-- Add this if implementing anti-cheat bypass
if CONFIG.AntiCheatBypass then
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        
        if method == "FireServer" and self.Name:match("Detection") then
            EventLogger:Log("Anti-cheat detection blocked: " .. self.Name, "WARNING")
            return nil -- Block anti-cheat detections
        end
        
        -- Monitor and log certain remote calls for diagnostic purposes
        if _G.FemBladeDebug and method == "FireServer" and (
            self.Name:match("Parry") or 
            self.Name:match("Block") or 
            self.Name:match("Attack")
        ) then
            local argStr = ""
            for i, arg in ipairs(args) do
                argStr = argStr .. " [" .. typeof(arg) .. "]"
            end
            EventLogger:Log("Remote call monitored: " .. self.Name .. argStr, "DEBUG")
        end
        
        return oldNamecall(self, ...)
    end)
    
    EventLogger:Log("Anti-cheat bypass initialized", "SUCCESS")
end

--// DIAGNOSTIC UTILITIES //--
-- Comprehensive set of diagnostic tools for in-game troubleshooting
local DiagnosticsUtil = {}
DiagnosticsUtil.InitialPing = GetPing()
DiagnosticsUtil.StartupDiagnosticsComplete = false
DiagnosticsUtil.ScriptEnvironment = {
    Executor = "Unknown",
    GlobalsAvailable = {},
    MethodsPatched = {},
    SecurityLevel = "Unknown"
}
DiagnosticsUtil.GameEnvironment = {
    GameID = game and game.PlaceId or 0,
    Players = workspace and #Players:GetPlayers() or 0,
    MapLoaded = workspace and workspace:FindFirstChild("Map") ~= nil,
    SynchronizedWithServer = true
}

function DiagnosticsUtil:RunStartupDiagnostics()
    if self.StartupDiagnosticsComplete then return end
    
    -- Take initial performance measurements
    PerformanceMonitor:StartTimer("StartupDiagnostics")
    
    -- Check available globals to determine executor
    local availableGlobals = {"getgc", "getcallingscript", "gethui", "setreadonly", "hookfunction", "islclosure"}
    for _, globalName in ipairs(availableGlobals) do
        self.ScriptEnvironment.GlobalsAvailable[globalName] = type(_G[globalName]) == "function"
    end
    
    -- Determine executor type based on available globals
    if self.ScriptEnvironment.GlobalsAvailable["gethui"] and self.ScriptEnvironment.GlobalsAvailable["getcallingscript"] then
        self.ScriptEnvironment.Executor = "Synapse X or Similar"
        self.ScriptEnvironment.SecurityLevel = "High"
    elseif self.ScriptEnvironment.GlobalsAvailable["getgc"] and self.ScriptEnvironment.GlobalsAvailable["islclosure"] then
        self.ScriptEnvironment.Executor = "Mid-tier Executor"
        self.ScriptEnvironment.SecurityLevel = "Medium"
    else
        self.ScriptEnvironment.Executor = "Basic Executor"
        self.ScriptEnvironment.SecurityLevel = "Low"
    end
    
    -- Check for hook method support
    local hookSuccess = pcall(function()
        local originalFunc = Instance.new("Part").Destroy
        local hookResult = false
        
        -- Try to hook an instance method
        local hookedFunc
        hookedFunc = hookfunction(originalFunc, function(...)
            hookResult = true
            return hookedFunc(...)
        end)
        
        -- Clean up
        hookfunction(originalFunc, originalFunc)
    end)
    
    self.ScriptEnvironment.MethodsPatched["HookSupport"] = hookSuccess
    
    -- Validate game environment
    self.GameEnvironment.SynchronizedWithServer = self:CheckServerSynchronization()
    
    -- Log diagnostics
    EventLogger:Log("Startup diagnostics completed", "INFO", {
        Executor = self.ScriptEnvironment.Executor,
        SecurityLevel = self.ScriptEnvironment.SecurityLevel,
        InitialPing = self.InitialPing
    })
    
    -- Complete timer
    PerformanceMonitor:StopTimer("StartupDiagnostics")
    self.StartupDiagnosticsComplete = true
end

function DiagnosticsUtil:CheckServerSynchronization()
    -- In a real environment, we would check actual synchronization
    -- For this mock, we'll return true
    return true
end

function DiagnosticsUtil:GenerateReport()
    local report = "=== FemBlade Diagnostics Report ===\n"
    report = report .. "Time: " .. os.date("%Y-%m-%d %H:%M:%S") .. "\n\n"
    
    report = report .. "Script Environment:\n"
    report = report .. "- Executor: " .. self.ScriptEnvironment.Executor .. "\n"
    report = report .. "- Security Level: " .. self.ScriptEnvironment.SecurityLevel .. "\n"
    
    report = report .. "\nGame Environment:\n"
    report = report .. "- Game ID: " .. self.GameEnvironment.GameID .. "\n"
    report = report .. "- Players: " .. self.GameEnvironment.Players .. "\n"
    report = report .. "- Map Loaded: " .. tostring(self.GameEnvironment.MapLoaded) .. "\n"
    report = report .. "- Server Synchronized: " .. tostring(self.GameEnvironment.SynchronizedWithServer) .. "\n"
    
    report = report .. "\nNetwork Stats:\n"
    report = report .. "- Initial Ping: " .. string.format("%.2f", self.InitialPing * 1000) .. "ms\n"
    report = report .. "- Current Ping: " .. string.format("%.2f", GetPing() * 1000) .. "ms\n"
    
    return report
end

-- Run startup diagnostics
DiagnosticsUtil:RunStartupDiagnostics()
if _G.FemBladeDebug then
    print(DiagnosticsUtil:GenerateReport())
end

--// INITIALIZATION //--
-- Show welcome notification
StarterGui:SetCore("SendNotification", {
    Title = CONFIG.Name,
    Text = "Script loaded successfully! Auto parry distance set to " .. ParryRadius,
    Duration = 3
})

-- Log initialization
DebugPrint("Initialized in", string.format("%.2f", tick() - StartTime), "seconds")
DebugPrint("Auto parry radius set to", ParryRadius)
DebugPrint("Current player:", PlayerName, "ID:", UserId)
DebugPrint("Version:", CONFIG.Version)

-- Final startup procedures
UpdateParryData(ParryType)
StarterGui:SetCore("ChatMakeSystemMessage", {
    Text = "[" .. CONFIG.Name .. "] Loaded successfully! Press M to toggle auto parry.",
    Color = Color3.fromRGB(140, 70, 240),
    Font = Enum.Font.GothamBold,
    TextSize = 16
})

-- Record successful initialization
EventLogger:Log("FemBlade script initialized successfully", "SUCCESS", {
    Version = CONFIG.Version,
    ParryRadius = ParryRadius,
    StartupTime = string.format("%.2f", tick() - StartTime)
})

print(CONFIG.Name .. " Auto Parry script loaded successfully!")