--[[
  ______              ______ _           _      
 |  ____|            |  ____|_|         | |     
 | |__ ___ _ __ ___  | |__   _ _ __   __| | ___ 
 |  __/ _ \ '_ ` _ \ |  __| | | '_ \ / _` |/ _ \
 | | |  __/ | | | | || |____| | | | | (_| |  __/
 |_|  \___|_| |_| |_||______|_|_| |_|\__,_|\___|
                                                
  _____                      _                     _____           _       _   
 |  __ \                    (_)                   / ____|         (_)     | |  
 | |__) | __ ___ _ __ ___    _ _   _ _ __ ___    | (___   ___ _ __ _ _ __ | |_ 
 |  ___/ '__/ _ \ '_ ` _ \  | | | | | '_ ` _ \    \___ \ / __| '__| | '_ \| __|
 | |   | | |  __/ | | | | | | | |_| | | | | | |   ____) | (__| |  | | |_) | |_ 
 |_|   |_|  \___|_| |_| |_| |_|\__,_|_| |_| |_|  |_____/ \___|_|  |_| .__/ \__|
                                                                     | |        
                                                                     |_|        
]]--

-- Create global tick function for standalone mode (needed for testing)
if not tick then
    function tick()
        return os.time() + os.clock()
    end
end

-- ***********************************************
-- *           FEMEBLADE AUTO PARRY              *
-- *      ULTRA PREMIUM PARRYING SCRIPT          *
-- *           BLADE BALL EDITION                *
-- ***********************************************

--// CONFIGURATION SECTION //--
local CONFIG = {}

-- Add mock functions for standalone testing
if not game then
    -- Mock Color3 and other Roblox types for standalone testing
    -- This allows the script to be tested in a non-Roblox Lua environment
    _G.Vector3 = {
        new = function(x, y, z) return { X = x or 0, Y = y or 0, Z = z or 0, Magnitude = math.sqrt((x or 0)^2 + (y or 0)^2 + (z or 0)^2) } end,
        zero = { X = 0, Y = 0, Z = 0, Magnitude = 0 }
    }
    
    _G.Vector2 = {
        new = function(x, y) return { X = x or 0, Y = y or 0, Magnitude = math.sqrt((x or 0)^2 + (y or 0)^2) } end,
        zero = { X = 0, Y = 0, Magnitude = 0 }
    }
    
    _G.CFrame = {
        new = function(...) return { Position = { X = 0, Y = 0, Z = 0 } } end
    }
    
    _G.Color3 = {
        fromRGB = function(r, g, b) return { R = r/255, G = g/255, B = b/255 } end,
        fromHSV = function(h, s, v) return { H = h, S = s, V = v } end
    }
    
    _G.UDim = {
        new = function(scale, offset) 
            return { Scale = scale or 0, Offset = offset or 0 } 
        end
    }
    
    _G.UDim2 = {
        new = function(xScale, xOffset, yScale, yOffset) 
            return { 
                X = { Scale = xScale, Offset = xOffset }, 
                Y = { Scale = yScale, Offset = yOffset } 
            } 
        end
    }
    
    _G.Enum = {
        KeyCode = {
            RightControl = "RightControl",
            M = "M",
            N = "N",
            RightBracket = "RightBracket",
            LeftBracket = "LeftBracket",
            E = "E",
            F = "F",
            Q = "Q"
        },
        EasingStyle = {
            Linear = "Linear",
            Quad = "Quad",
            Cubic = "Cubic",
            Quart = "Quart",
            Quint = "Quint",
            Sine = "Sine",
            Bounce = "Bounce",
            Elastic = "Elastic"
        },
        EasingDirection = {
            In = "In",
            Out = "Out",
            InOut = "InOut"
        },
        Font = {
            GothamBold = "GothamBold",
            Gotham = "Gotham",
            GothamSemibold = "GothamSemibold"
        },
        Material = {
            Neon = "Neon",
            ForceField = "ForceField"
        },
        PartType = {
            Ball = "Ball"
        },
        UserInputType = {
            MouseButton1 = "MouseButton1",
            MouseButton2 = "MouseButton2",
            MouseMovement = "MouseMovement",
            Keyboard = "Keyboard"
        },
        TextXAlignment = {
            Left = "Left",
            Right = "Right",
            Center = "Center"
        },
        ZIndexBehavior = {
            Sibling = "Sibling",
            Global = "Global"
        },
        ScaleType = {
            Slice = "Slice",
            Stretch = "Stretch",
            Tile = "Tile",
            Fit = "Fit",
            Crop = "Crop"
        },
        SortOrder = {
            LayoutOrder = "LayoutOrder",
            Name = "Name"
        },
        AutomaticSize = {
            None = "None",
            X = "X",
            Y = "Y",
            XY = "XY"
        }
    }
    
    -- Mock Rect object
    _G.Rect = {
        new = function(x, y, width, height)
            return {
                Min = {X = x, Y = y},
                Max = {X = width, Y = height},
                Width = width - x,
                Height = height - y
            }
        end
    }
    
    -- Create signal/event system for mock
    _G.CreateSignal = function()
        local callbacks = {}
        return {
            Connect = function(_, callback)
                if type(callback) == "function" then
                    table.insert(callbacks, callback)
                end
                return {
                    Disconnect = function() end
                }
            end,
            Fire = function(_, ...)
                for _, callback in ipairs(callbacks) do
                    callback(...)
                end
            end,
            Wait = function()
                -- For simplicity, we don't actually wait in test mode
                return nil
            end
        }
    end
    
    -- Mock Instance object for creating objects in testing mode
    _G.Instance = {
        new = function(className)
            local instance = {
                Name = "",
                Parent = nil,
                ClassName = className,
                Children = {},
                Attributes = {},
                
                -- Create UI events
                InputBegan = _G.CreateSignal(),
                InputEnded = _G.CreateSignal(),
                MouseEnter = _G.CreateSignal(),
                MouseLeave = _G.CreateSignal(),
                MouseButton1Click = _G.CreateSignal(),
                MouseButton1Down = _G.CreateSignal(),
                MouseButton1Up = _G.CreateSignal(),
                MouseButton2Click = _G.CreateSignal(),
                MouseMoved = _G.CreateSignal(),
                TouchTap = _G.CreateSignal(),
                TouchPan = _G.CreateSignal(),
                
                -- Common methods
                FindFirstChild = function(self, name)
                    for _, child in ipairs(self.Children) do
                        if child.Name == name then
                            return child
                        end
                    end
                    return nil
                end,
                
                GetChildren = function(self)
                    return self.Children
                end,
                
                GetAttribute = function(self, attributeName)
                    return self.Attributes[attributeName]
                end,
                
                SetAttribute = function(self, attributeName, value)
                    self.Attributes[attributeName] = value
                end,
                
                GetPropertyChangedSignal = function(self, propertyName)
                    return {
                        Connect = function(_, callback)
                            -- In test mode, we just return a dummy connection
                            return {
                                Disconnect = function() end
                            }
                        end
                    }
                end,
                
                Destroy = function(self)
                    if self.Parent then
                        for i, child in ipairs(self.Parent.Children) do
                            if child == self then
                                table.remove(self.Parent.Children, i)
                                break
                            end
                        end
                    end
                    self.Parent = nil
                end,
                
                Clone = function(self)
                    local clone = Instance.new(self.ClassName)
                    clone.Name = self.Name
                    return clone
                end
            }
            
            -- Define property behavior
            local properties = {}
            local mt = {
                __index = function(tbl, key)
                    if properties[key] ~= nil then
                        return properties[key]
                    end
                    return instance[key]
                end,
                
                __newindex = function(tbl, key, value)
                    if key == "Parent" and value then
                        if instance.Parent then
                            for i, child in ipairs(instance.Parent.Children) do
                                if child == instance then
                                    table.remove(instance.Parent.Children, i)
                                    break
                                end
                            end
                        end
                        
                        instance.Parent = value
                        -- Make sure Children exists and is a table before inserting
                        if value then
                            if not value.Children then
                                value.Children = {}
                            end
                            table.insert(value.Children, instance)
                        end
                    else
                        properties[key] = value
                        instance[key] = value
                    end
                end
            }
            
            return setmetatable({}, mt)
        end
    }
    
    Vector3 = _G.Vector3
    Vector2 = _G.Vector2
    CFrame = _G.CFrame
    Color3 = _G.Color3
    UDim = _G.UDim
    UDim2 = _G.UDim2
    Enum = _G.Enum
    Instance = _G.Instance
    Rect = _G.Rect
    CreateSignal = _G.CreateSignal
    
    -- Mock spawn and wait functions
    _G.spawn = function(f)
        -- In test mode, we don't actually run the function to avoid infinite loops
        -- Just return a dummy connection
        return {
            Disconnect = function() end
        }
    end
    
    _G.wait = function(t)
        -- In test mode, don't actually wait, just return
        return t or 0.03
    end
    
    -- Mock metatable functions used for exploits
    _G.hookmetamethod = function(obj, metamethod, hook)
        -- In test mode, we just return a dummy function
        return function(...) 
            -- Return the original args in test mode
            return ...
        end
    end
    
    _G.getnamecallmethod = function()
        -- In test mode, just return a dummy method
        return "unknown"
    end
    
    -- Create task library
    _G.task = {
        spawn = function(f, ...)
            local args = {...}
            -- In test mode, we execute immediately but don't block
            local thread = coroutine.create(function()
                f(table.unpack(args))
            end)
            coroutine.resume(thread)
            return thread
        end,
        
        wait = function(t)
            -- In test mode, don't actually wait, just return
            return t or 0.03
        end,
        
        delay = function(t, f, ...)
            local args = {...}
            -- In test mode, we execute immediately but don't block
            local thread = coroutine.create(function()
                f(table.unpack(args))
            end)
            coroutine.resume(thread)
            return thread
        end
    }
    
    -- Expose to global namespace
    spawn = _G.spawn
    wait = _G.wait
    task = _G.task
    hookmetamethod = _G.hookmetamethod
    getnamecallmethod = _G.getnamecallmethod
    
    print("Running in standalone testing mode with mock Roblox functions")
end

-- Now define the configuration
CONFIG = {
    -- Core Settings
    Name = "FemBlade",
    Version = "1.0.3",
    Debug = false,
    Author = "FemBlade Team",
    ReleaseDate = "April 27, 2025",
    DiscordInvite = "discord.gg/femBlade",
    ScriptId = tostring(math.random(100000, 999999)),
    
    -- Performance Settings
    OptimizePerformance = true,
    ReduceAnimations = false,
    ReduceLagSpikes = true,
    UseAsyncComputing = true,
    PreloadAssets = true,
    CacheRemotes = true,
    ReduceMemoryUsage = true,
    
    -- UI Settings
    DefaultTheme = "Dark",
    AccentColor = Color3.fromRGB(140, 70, 240), -- Purple
    TextColor = Color3.fromRGB(240, 240, 250),
    SecondaryTextColor = Color3.fromRGB(180, 180, 200),
    BackgroundColor = Color3.fromRGB(15, 15, 20),
    SecondaryBackgroundColor = Color3.fromRGB(25, 25, 35),
    UIScale = 1.0,
    CustomCursor = false,
    BlurEffect = false,
    ShowParticles = true,
    AnimateTransitions = true,
    RoundedCorners = true,
    EnableSounds = true,
    
    -- Security Settings
    AntiCheatBypass = true,
    ObfuscateRemotes = true,
    DisableTelemetry = true,
    ProtectGlobals = true,
    AntiKick = true,
    AntiTeleport = false,
    HideFromScriptScans = true,
    SecureLocalStorage = true,
    
    -- Global Defaults
    ParryDistance = 43, -- As requested
    PredictionTime = 0.15,
    ParryAccuracy = 100,
    AutoParryEnabled = false,
    CurveType = "Dot",
    ParryModes = {
        "Dot", 
        "Custom", 
        "Backwards", 
        "Random",
        "Straight",
        "Up",
        "Right",
        "Left",
        "Down",
        "Adaptive",
        "Smart",
        "Trace",
        "Predictive",
        "Momentum",
        "Reactive"
    },
    
    -- Advanced Parry Settings
    TimeStepMultiplier = 1.0,
    MaxVelocitySamples = 15,
    DefaultSmoothing = 0.8,
    VisualFeedback = true,
    AdjustForPing = true,
    BallTypeDetection = true,
    CurveRecognition = true,
    BouncePrediction = true,
    DynamicTiming = true,
    
    -- Audio Settings
    ParrySoundId = "rbxassetid://6732690176",
    UIClickSoundId = "rbxassetid://6732690176",
    NotificationSoundId = "rbxassetid://6732690176",
    SoundVolume = 0.5,
    
    -- Visual Effects
    HitEffectEnabled = true,
    HitEffectId = "rbxassetid://8517625677",
    HitEffectSize = UDim2.new(0, 100, 0, 100),
    HitEffectDuration = 0.4,
    
    -- Custom Commands
    EnableChatCommands = true,
    CommandPrefix = "!",
    Commands = {
        help = "Shows available commands",
        toggle = "Toggles auto parry",
        mode = "Changes parry mode",
        radius = "Sets parry radius",
        time = "Sets prediction time",
        stats = "Shows parry statistics",
        reset = "Resets all settings to default"
    },
    
    -- Keybind Settings
    KeybindEnabled = true,
    Keybinds = {
        ToggleUI = Enum.KeyCode.RightControl,
        ToggleAutoParry = Enum.KeyCode.M,
        CycleParryMode = Enum.KeyCode.N,
        IncreaseRadius = Enum.KeyCode.RightBracket,
        DecreaseRadius = Enum.KeyCode.LeftBracket,
        EmergencyParry = Enum.KeyCode.E
    },
    
    -- Developer Settings
    DeveloperMode = false,
    EnableLogging = true,
    LogLevel = "INFO", -- INFO, WARNING, ERROR, DEBUG
    ShowPerformanceStats = false,
    EnableExceptions = true,
    CreateBackups = true,
    EnableVersionCheck = true,
    
    -- Advanced Features
    AutoUpdate = true,
    CloudSync = false,
    EnableAnalytics = false,
    ShareAnonymousStats = false,
    EnableTips = true,
    ShowNotifications = true,
    
    -- External Integration
    DiscordRPC = false,
    WebhookEnabled = false,
    WebhookEndpoint = "",
    
    -- Experimental Features
    MachineLearning = false,
    AdaptiveTimingSystem = true,
    PatternRecognition = false,
    ServerSideSimulation = false,
    PredictiveAnalytics = false
}

--// INITIALIZATION AND SERVICES //--
-- Add mock game environment for standalone testing
if not game then
    -- Create mock game object and services
    _G.game = {
        GetService = function(self, serviceName)
            if not self._services then
                self._services = {}
            end
            
            if not self._services[serviceName] then
                -- Create mock service
                self._services[serviceName] = {
                    Name = serviceName,
                    
                    -- General methods
                    FindFirstChild = function() return nil end,
                    WaitForChild = function() return { 
                        GetPropertyChangedSignal = function() return { Connect = function() end } end 
                    } end,
                    
                    -- Mock functionality for specific services
                    -- Players
                    Players = {
                        LocalPlayer = {
                            Name = "TestPlayer",
                            UserId = 12345,
                            Character = {
                                FindFirstChild = function() return { Position = Vector3.new(0, 0, 0) } end,
                                FindFirstChildOfClass = function() return {} end,
                                WaitForChild = function() return { Position = Vector3.new(0, 0, 0) } end
                            },
                            PlayerGui = { 
                                WaitForChild = function() return {} end 
                            },
                            GetMouse = function() return { X = 0, Y = 0 } end,
                            CharacterAdded = {
                                Connect = function(_, callback) return end,
                                Wait = function() return { 
                                    FindFirstChildOfClass = function() return {} end,
                                    FindFirstChild = function() return {} end
                                } end
                            }
                        },
                        GetPlayers = function() return {} end
                    },
                    
                    -- RunService
                    PreSimulation = { Connect = function(_, callback) return end },
                    Heartbeat = { Connect = function(_, callback) return end },
                    RenderStepped = { Connect = function(_, callback) return end },
                    
                    -- UserInputService
                    InputBegan = { Connect = function(_, callback) return end },
                    InputEnded = { Connect = function(_, callback) return end },
                    InputChanged = { Connect = function(_, callback) return end },
                    GetMouseLocation = function() return Vector2.new(0, 0) end,
                    
                    -- TweenService
                    Create = function(_, _, properties)
                        -- Create mock tween object
                        local tween = {
                            Properties = properties,
                            Completed = _G.CreateSignal(),
                            PlaybackState = "Stopped",
                            Play = function(self)
                                self.PlaybackState = "Playing"
                                -- Immediately trigger Completed event in our mock
                                task.spawn(function()
                                    self.Completed:Fire()
                                end)
                                return self
                            end,
                            Pause = function(self)
                                self.PlaybackState = "Paused"
                                return self
                            end,
                            Cancel = function(self)
                                self.PlaybackState = "Cancelled"
                                return self
                            end
                        }
                        return tween
                    end,
                    
                    -- StarterGui
                    SetCore = function() end,
                    
                    -- HttpService
                    GenerateGUID = function() return "mock-guid-12345" end,
                    JSONEncode = function(_, value) return "json-encoded-" .. tostring(value) end,
                    JSONDecode = function() return {} end,
                    
                    -- ReplicatedStorage
                    Remotes = {
                        ParrySuccess = { OnClientEvent = { Connect = function() end } },
                        ParrySuccessAll = { OnClientEvent = { Connect = function() end } }
                    },
                    DefaultChatSystemChatEvents = {
                        SayMessageRequest = { FireServer = function() end },
                        OnMessageDoneFiltering = { OnClientEvent = { Connect = function() end } }
                    },
                    
                    -- ContentProvider
                    PreloadAsync = function() end,
                    
                    -- Custom functions for each service type
                    _customServiceFunctions = {
                        Players = {},
                        RunService = {},
                        UserInputService = {},
                        ReplicatedStorage = {},
                        TweenService = {
                            Create = function(_, _, properties)
                                -- Create mock tween object
                                local tween = {
                                    Properties = properties,
                                    Completed = _G.CreateSignal(),
                                    PlaybackState = "Stopped",
                                    Play = function(self)
                                        self.PlaybackState = "Playing"
                                        -- Immediately trigger Completed event in our mock
                                        task.spawn(function()
                                            self.Completed:Fire()
                                        end)
                                        return self
                                    end,
                                    Pause = function(self)
                                        self.PlaybackState = "Paused"
                                        return self
                                    end,
                                    Cancel = function(self)
                                        self.PlaybackState = "Cancelled"
                                        return self
                                    end
                                }
                                return tween
                            end
                        },
                        StarterGui = {},
                        VirtualInputManager = {
                            SendKeyEvent = function() end
                        },
                        ContentProvider = {},
                        CoreGui = {},
                        Lighting = {},
                        HttpService = {},
                        TextService = {
                            GetTextSize = function() return Vector2.new(100, 20) end
                        },
                        ContextActionService = {},
                        GuiService = {},
                        MarketplaceService = {},
                        SoundService = {},
                        Stats = {
                            Network = {
                                ServerStatsItem = {
                                    ["Data Ping"] = {
                                        GetValue = function() return 100 end
                                    }
                                }
                            }
                        }
                    }
                }
                
                -- Add service-specific functionality
                for funcName, func in pairs(self._services[serviceName]._customServiceFunctions[serviceName] or {}) do
                    self._services[serviceName][funcName] = func
                end
            end
            
            return self._services[serviceName]
        end,
        
        -- Mock properties
        PlaceId = 0,
        JobId = "mock-job-id",
        CreatorId = 0,
        
        -- Mock instance methods
        FindFirstChild = function() return nil end,
        
        -- Mock workspace
        Workspace = {
            Balls = {
                GetChildren = function() return {} end,
                ChildAdded = { Connect = function() end }
            },
            Alive = {
                GetChildren = function() return {} end,
                ChildAdded = { Connect = function() end }
            },
            Map = {},
            CurrentCamera = {
                ViewportSize = Vector2.new(1920, 1080),
                CFrame = CFrame.new(),
                FieldOfView = 70,
                WorldToScreenPoint = function() return Vector3.new(0, 0, 0), true end
            },
            GetChildren = function() return {} end,
            FindFirstChild = function() return nil end,
            WaitForChild = function() return {} end
        },
        Parent = nil
    }
    
    -- Assign global
    game = _G.game
    workspace = game.Workspace
    
    print("Created mock game environment for standalone testing")
end

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ContentProvider = game:GetService("ContentProvider")
local CoreGui = game:GetService("CoreGui")
local Lighting = game:GetService("Lighting")
local HttpService = game:GetService("HttpService")
local TextService = game:GetService("TextService")
local ContextActionService = game:GetService("ContextActionService")
local GuiService = game:GetService("GuiService")
local MarketplaceService = game:GetService("MarketplaceService")

-- Player Variables (with safety checks for standalone mode)
local LocalPlayer 
local Character
local PlayerName
local UserId
local Humanoid
local HumanoidRootPart
local Camera
local PlayerGui
local Mouse
local Alive

-- Try to get player safely
if Players then
    LocalPlayer = Players.LocalPlayer
    
    -- Only try to access player properties if it exists
    if LocalPlayer then
        Character = LocalPlayer.Character or (LocalPlayer.CharacterAdded and LocalPlayer.CharacterAdded:Wait())
        PlayerName = LocalPlayer.Name or "TestPlayer"
        UserId = LocalPlayer.UserId or 0
        
        -- Only try to access character properties if it exists
        if Character then
            Humanoid = Character:FindFirstChildOfClass("Humanoid")
            HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
        end
        
        -- Get other references
        PlayerGui = LocalPlayer:WaitForChild("PlayerGui", 1) or {}
        
        -- Safely get mouse if function exists
        if type(LocalPlayer.GetMouse) == "function" then
            Mouse = LocalPlayer:GetMouse()
        else
            Mouse = {X = 0, Y = 0}
        end
    end
end

-- Get workspace references
if workspace then
    Camera = workspace.CurrentCamera
    Alive = workspace:FindFirstChild("Alive") or workspace
end

-- For standalone testing, create fallbacks if any variables are nil
if not LocalPlayer then
    print("Running in minimal mode - creating mock player variables")
    
    LocalPlayer = {
        Name = "TestPlayer",
        UserId = 0,
        Character = {
            FindFirstChildOfClass = function() return {} end,
            FindFirstChild = function() return {} end
        },
        CharacterAdded = {Connect = function() end},
        GetMouse = function() return {X = 0, Y = 0} end
    }
    
    Character = LocalPlayer.Character
    PlayerName = LocalPlayer.Name
    UserId = LocalPlayer.UserId
    Humanoid = {}
    HumanoidRootPart = {}
    Camera = {ViewportSize = Vector2.new(1920, 1080)}
    PlayerGui = {}
    Mouse = {X = 0, Y = 0}
    Alive = {}
end

-- Global Variables
_G.FemBladeLoaded = true
_G.FemBladeVersion = CONFIG.Version
_G.FemBladeDebug = CONFIG.Debug
_G.FemBladeSecurity = {
    AntiCheatBypass = CONFIG.AntiCheatBypass,
    ObfuscateRemotes = CONFIG.ObfuscateRemotes,
    DisableTelemetry = CONFIG.DisableTelemetry
}

-- Local Script Identifier
local ScriptId = HttpService:GenerateGUID(false)
local StartTime = tick()

-- Initialize session statistics
local SessionStats = {
    StartTime = os.time(),
    TotalParries = 0,
    SuccessfulParries = 0,
    MissedParries = 0,
    BallsDetected = 0,
    CurvedBallsDetected = 0,
    SpecialBallsDetected = 0,
    TotalDistance = 0,
    AverageReactionTime = 0,
    ReactionTimes = {},
    MaxConsecutiveParries = 0,
    CurrentConsecutiveParries = 0,
    Uptime = 0,
    LastParryTime = 0
}

-- Check for future character spawn
LocalPlayer.CharacterAdded:Connect(function(NewCharacter)
    Character = NewCharacter
    Humanoid = Character:FindFirstChildOfClass("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
    
    if _G.FemBladeDebug then
        print("[FemBlade] Character respawned, references updated.")
    end
end)

--// CORE FUNCTIONALITY //--
-- Parry System Variables
local Remotes = {}
local Parry_Key = nil
local Parry_Data = nil
local Connection = nil
local IsParried = false
local Cooldown = 0
local LastParryAttemptTime = 0
local ParrySuccessRate = 100
local ConsecutiveMisses = 0
local BallHistoryData = {}
local BallVelocityHistory = {}
local LastPredictedPositions = {}
local CurrentBallData = {}
local CurrentBallTarget = nil

-- Feature Configuration Variables
-- Auto Parry Settings
local IsAutoParryEnabled = false
local ParryRadius = CONFIG.ParryDistance
local PredictionTime = CONFIG.PredictionTime
local ParryAccuracy = CONFIG.ParryAccuracy
local ParryType = CONFIG.CurveType
local RandomizedParryAccuracy = false
local ParrySettings = {
    -- Basic Settings
    PriorityMode = "Default", -- Default, Distance, Speed, Danger
    AutomaticPredictionAdjustment = true,
    DynamicRadiusAdjustment = false,
    MinRadius = 10,
    MaxRadius = 60,
    
    -- Advanced Settings
    CurveCompensation = true,
    SpeedBasedTiming = true,
    VelocityExtrapolation = true,
    VelocitySampleCount = 10,
    PrecisionLevel = 3, -- 1-3, higher is more precise
    ParryWindowStart = 0.1, -- time before predicted hit
    ParryWindowEnd = 0.05, -- time after predicted hit
    
    -- Animation Settings
    AnimationControl = false,
    CustomAnimationId = nil,
    BlockAnimationDisabled = false,
    AnimationSpeedMultiplier = 1,
    
    -- Auto-Adjust Settings
    LearningMode = false,
    AdaptiveTiming = false,
    SuccessThreshold = 0.8,
    FailureAdjustmentFactor = 0.05,
    SuccessAdjustmentFactor = 0.02,
    
    -- Extra Features
    TooFastThreshold = 300,
    TooSlowThreshold = 40,
    FakeLatency = 0,
    AutoDetectPing = true,
    PingCompensation = true
}

-- Detection Options
local InfinityDetection = false
local DeathSlashDetection = false
local TimeHoleDetection = false
local SlashOfFuryDetection = false
local AntiPhantom = false
local CooldownProtection = false
local AutoAbility = false
local ParryDebounce = false

-- Advanced Ball Detection
local BallDetectionSettings = {
    VelocityThreshold = 400,
    SizeThreshold = 2,
    AccelerationThreshold = 100, 
    DirectionChangeThreshold = 0.3,
    MinDistanceForTracking = 5,
    MaxDistanceForTracking = 300,
    TrackingUpdateRate = 0.01,
    PredictionSmoothingFactor = 0.7,
    MaxHistoryLength = 20,
    VelocitySmoothingFactor = 0.8,
    UseAccelerationInPrediction = true,
    PredictBounces = true,
    BallisticPrediction = true,
    AdaptivePathPrediction = true
}

-- Additional Features
local FeatureSettings = {
    -- Auto Spam Settings
    AutoSpamEnabled = false,
    AutoSpamRate = 0.15,
    AutoSpamMode = "Constant", -- Constant, Pattern, Random
    AutoSpamPattern = {0.1, 0.2, 0.1, 0.3}, -- Time between spams
    AutoSpamRandomMin = 0.1,
    AutoSpamRandomMax = 0.3,
    
    -- Manual Spam Settings
    ManualSpamEnabled = false,
    ManualSpamKeyBind = Enum.KeyCode.E,
    ManualSpamRate = 0.1,
    ManualSpamMouseEnabled = true,
    
    -- Trigger Bot Settings
    TriggerBotEnabled = false,
    TriggerBotDelay = 0.05,
    TriggerBotAccuracy = 100,
    
    -- Notification Settings
    NotifyEnabled = false,
    NotifySound = true,
    NotifySoundId = "rbxassetid://6895079853",
    NotifySoundVolume = 0.5,
    NotifyPosition = "TopRight", -- TopRight, TopLeft, BottomRight, BottomLeft, Center
    NotifyDuration = 1.5,
    NotifyWithChat = false,
    NotifyChatTemplate = "⚔️ Парирован мяч! ⚔️",
    
    -- Visualization Settings
    VisualFeedbackEnabled = false,
    ShowParryRadius = false,
    ShowPredictionPath = false,
    ShowBallDirection = false,
    ShowBallTarget = false,
    ShowParryWindow = false,
    HighlightActiveBall = false,
    
    -- Keybind Settings
    ToggleKeybind = Enum.KeyCode.M,
    ModeKeybind = Enum.KeyCode.N,
    RadiusIncreaseKeybind = Enum.KeyCode.RightBracket,
    RadiusDecreaseKeybind = Enum.KeyCode.LeftBracket,
    
    -- Custom UI Settings
    CustomCursorEnabled = false,
    CustomCursorId = "rbxassetid://8081775844",
    CustomCursorSize = UDim2.new(0, 32, 0, 32),
    ShowStatsInGame = false,
    UICornerRadius = UDim.new(0, 6),
    
    -- Other Features
    AnimationFix = false,
    KeypressEmulation = false,
    SmoothCamera = false,
    AutoAbilityDetection = false,
    ChatCommands = false,
    ChatCommandPrefix = "!",
    
    -- Quality of Life
    DisableScreenShakes = false,
    DisableScreenBlur = false,
    DisableCriticalEffects = false,
    EnhanceVisibility = false,
    LockFirstPerson = false,
    AutoHideUnnecessaryUI = false,
    
    -- Performance Optimizations
    ReduceParticles = false,
    OptimizeRendering = false,
    LimitVelocitySamples = true,
    UseAsyncTracking = true,
    SyncWithHeartbeat = false,
    SkipNonEssentialUpdates = false
}

--// UTILITY FUNCTIONS //--
-- Debug Print Function
local function DebugPrint(...)
    if _G.FemBladeDebug then
        local args = {...}
        local message = "[FemBlade]"
        for i, v in ipairs(args) do
            message = message .. " " .. tostring(v)
        end
        print(message)
    end
end

-- Format time function
local function FormatTime(seconds)
    local minutes = math.floor(seconds / 60)
    local hours = math.floor(minutes / 60)
    local remainingSeconds = seconds % 60
    local remainingMinutes = minutes % 60
    
    if hours > 0 then
        return string.format("%02d:%02d:%02d", hours, remainingMinutes, remainingSeconds)
    else
        return string.format("%02d:%02d", minutes, remainingSeconds)
    end
end

-- Deep copy function for tables
local function DeepCopy(original)
    local copy = {}
    for k, v in pairs(original) do
        if type(v) == "table" then
            copy[k] = DeepCopy(v)
        else
            copy[k] = v
        end
    end
    return copy
end

-- Safe function call utility - handles functions that may not exist in standalone mode
local function SafeCall(func, default, ...)
    if type(func) == "function" then
        local success, result = pcall(func, ...)
        if success then
            return result
        end
    end
    return default
end

-- Get current ping (with safety checks)
local function GetPing()
    local ping = 0
    local success = pcall(function()
        local Stats = game:GetService("Stats")
        if Stats and Stats.Network and Stats.Network.ServerStatsItem and Stats.Network.ServerStatsItem["Data Ping"] then
            ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 1000
        end
    end)
    
    if not success or ping == 0 then
        -- Return a reasonable default ping if we can't get the real one
        ping = 0.050 -- 50ms is a reasonable default
    end
    
    return ping
end

-- Angle calculation
local function GetAngleBetweenVectors(a, b)
    local dot = a:Dot(b)
    local magnitude = a.Magnitude * b.Magnitude
    return math.acos(math.clamp(dot / magnitude, -1, 1))
end

-- Lerp function
local function Lerp(a, b, t)
    return a + (b - a) * t
end

-- Remap value from one range to another
local function Remap(value, inputMin, inputMax, outputMin, outputMax)
    return outputMin + ((value - inputMin) / (inputMax - inputMin)) * (outputMax - outputMin)
end

-- Random with seed
local RandomSeed = tick() % 1000
local function SeededRandom(min, max)
    RandomSeed = (RandomSeed * 16807) % 2147483647
    return min + (RandomSeed / 2147483647) * (max - min)
end

-- Find ball utility
local function GetBall()
    for _, Ball in ipairs(workspace.Balls:GetChildren()) do
        if Ball:GetAttribute("realBall") then
            return Ball
        end
    end
    return nil
end

-- Check if a ball is curved
local function IsBallCurved(ball)
    if not ball then return false end
    
    local zoomies = ball:FindFirstChild("zoomies")
    if not zoomies then return false end
    
    local velocity = zoomies.VectorVelocity
    
    -- Calculate recent direction changes
    if #BallVelocityHistory >= 3 then
        local currentDirection = velocity.Unit
        local previousDirection = BallVelocityHistory[#BallVelocityHistory].Unit
        
        local directionChange = (currentDirection - previousDirection).Magnitude
        if directionChange > BallDetectionSettings.DirectionChangeThreshold then
            return true
        end
    end
    
    -- Check for curved path
    if Character and HumanoidRootPart and ball:GetAttribute("target") == LocalPlayer.Name then
        local ballToPlayer = (HumanoidRootPart.Position - ball.Position).Unit
        local ballDirection = velocity.Unit
        local dotProduct = ballToPlayer:Dot(ballDirection)
        
        -- If dot product is between 0.5 and 0.85, likely curved
        if dotProduct > 0.5 and dotProduct < 0.85 then
            return true
        end
    end
    
    return false
end

-- Reset connection
local function ResetConnection()
    if Connection then
        Connection:Disconnect()
        Connection = nil
    end
end

-- Detect special ball type
local function GetBallType(ball)
    if not ball then return "Normal" end
    
    local ballType = ball:GetAttribute("type")
    if ballType then
        return ballType
    end
    
    -- Detect by velocity
    local zoomies = ball:FindFirstChild("zoomies")
    if zoomies and zoomies.VectorVelocity.Magnitude > BallDetectionSettings.VelocityThreshold then
        return "Fast"
    end
    
    -- Detect by size
    if ball.Size.Magnitude > BallDetectionSettings.SizeThreshold * 3 then
        return "Large"
    end
    
    return "Normal"
end

-- Initialize workspace references safely
local function InitializeWorkspaceReferences()
    if workspace then
        -- Create Balls folder if it doesn't exist (for testing mode)
        if not workspace:FindFirstChild("Balls") then
            local ballsFolder = Instance.new("Folder")
            ballsFolder.Name = "Balls"
            ballsFolder.Parent = workspace
            DebugPrint("Created mock Balls folder for testing")
        end
        
        -- Create Alive folder if it doesn't exist (for testing mode)
        if not workspace:FindFirstChild("Alive") and not Alive then
            local aliveFolder = Instance.new("Folder") 
            aliveFolder.Name = "Alive"
            aliveFolder.Parent = workspace
            DebugPrint("Created mock Alive folder for testing")
            Alive = aliveFolder
        end
    end
end

-- Initialize essential references for testing mode
InitializeWorkspaceReferences()

-- Track ball changes safely
if workspace and workspace:FindFirstChild("Balls") then
    workspace.Balls.ChildAdded:Connect(function()
        SessionStats.BallsDetected = SessionStats.BallsDetected + 1
        local Ball = SafeCall(GetBall, nil)
        if not Ball then return end
        
        ResetConnection()
        
        -- Create new entry in ball history
        local newBallData = {
            InitialPosition = Ball.Position,
            InitialVelocity = Ball:FindFirstChild("zoomies") and Ball.zoomies.VectorVelocity or Vector3.new(0,0,0),
            CreationTime = tick(),
            LastUpdatedTime = tick(),
            Type = GetBallType(Ball),
            Path = {Ball.Position},
            Velocities = {Ball:FindFirstChild("zoomies") and Ball.zoomies.VectorVelocity or Vector3.new(0,0,0)},
            TargetHistory = {},
            IsCurved = false,
            Bounces = 0,
            PredictedPositions = {},
            HitDetected = false
        }
        
        table.insert(BallHistoryData, newBallData)
        if #BallHistoryData > 10 then
            table.remove(BallHistoryData, 1)
        end
        
        CurrentBallData = newBallData
        
        -- Safely connect to attribute changed signal
        local success, result = pcall(function()
            return Ball:GetAttributeChangedSignal("target"):Connect(function()
                IsParried = false
                local target = Ball:GetAttribute("target")
                CurrentBallTarget = target
                
                -- Record target change in history
                table.insert(CurrentBallData.TargetHistory, {
                    Target = target,
                    Time = tick()
                })
                
                -- Only try to print debug info if we have a valid HumanoidRootPart
                if target == (LocalPlayer and LocalPlayer.Name) and HumanoidRootPart then
                    DebugPrint("Ball targeting me! Current distance:", (Ball.Position - HumanoidRootPart.Position).Magnitude)
                end
            end)
        end)
        
        if success then
            Connection = result
        else
            DebugPrint("Failed to connect ball target signal:", result)
        end
    end)
    
    DebugPrint("Successfully set up ball detection")
else
    DebugPrint("Running in test mode - ball detection disabled")
end

--// PARRY DATA MANAGEMENT //--
-- Function to update parry data based on selected curve type (with safety checks)
local function UpdateParryData(parryType)
    -- Safe reference to camera
    local Camera = workspace and workspace.CurrentCamera or {
        CFrame = CFrame.new(),
        ViewportSize = Vector2.new(1920, 1080),
        WorldToScreenPoint = function() return Vector3.new(0, 0, 0) end
    }
    
    -- Safe mouse location
    local Vector3_Mouse_Location
    local Mouse_Location = Vector2.new(0, 0)
    
    pcall(function()
        Mouse_Location = UserInputService:GetMouseLocation()
    end)
    
    Vector3_Mouse_Location = {Mouse_Location.X, Mouse_Location.Y}
    
    -- Safe event gathering
    local Events = {}
    
    pcall(function()
        if Alive then
            for _, v in pairs(Alive:GetChildren()) do
                if v:FindFirstChild("PrimaryPart") then
                    Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
                end
            end
        end
    end)

    local data = nil
    if parryType == "Custom" then
        data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}
    elseif parryType == "Backwards" then
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.LookVector * 1000)), Events, Vector3_Mouse_Location}
    elseif parryType == "Random" then
        data = {0, CFrame.new(Camera.CFrame.Position, Vector3.new(math.random(-3000,3000), math.random(-3000,3000), math.random(-3000,3000))), Events, Vector3_Mouse_Location}
    elseif parryType == "Straight" then
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.LookVector * 1000)), Events, Vector3_Mouse_Location}
    elseif parryType == "Up" then
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.UpVector * 1000)), Events, Vector3_Mouse_Location}
    elseif parryType == "Right" then
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.RightVector * 1000)), Events, Vector3_Mouse_Location}
    elseif parryType == "Left" then
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.RightVector * 1000)), Events, Vector3_Mouse_Location}
    elseif parryType == "Down" then
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.UpVector * 1000)), Events, Vector3_Mouse_Location}
    elseif parryType == "Dot" then
        -- Dot mode is default orientation for reliable parry
        data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}
    elseif parryType == "Adaptive" then
        -- Adaptive mode uses ball target information to optimize
        local Ball = GetBall()
        if Ball and Ball:GetAttribute("target") == LocalPlayer.Name and IsBallCurved(Ball) then
            -- Create a CFrame that counters the curve
            local toPlayer = (HumanoidRootPart.Position - Ball.Position).Unit
            local lookPos = Camera.CFrame.Position + toPlayer * 1000
            data = {0, CFrame.new(Camera.CFrame.Position, lookPos), Events, Vector3_Mouse_Location}
        else
            data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}
        end
    elseif parryType == "Smart" then
        -- Smart mode analyzes ball trajectory and chooses best counter
        local Ball = GetBall()
        if Ball and Ball:GetAttribute("target") == LocalPlayer.Name then
            local zoomies = Ball:FindFirstChild("zoomies")
            if zoomies then
                local velocity = zoomies.VectorVelocity
                local ballDirection = velocity.Unit
                local lookPos = Camera.CFrame.Position - ballDirection * 1000
                data = {0, CFrame.new(Camera.CFrame.Position, lookPos), Events, Vector3_Mouse_Location}
            else
                data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}
            end
        else
            data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}
        end
    else
        data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}
    end

    Parry_Data = data
end

-- Initialize parry data on startup
UpdateParryData(ParryType)

--// BALL PREDICTION SYSTEMS //--
-- Enhanced ball position prediction with advanced curve detection
local function PredictBallPosition(Ball, TimeAhead)
    if not Ball then return Vector3.new(0, 0, 0) end
    
    local Velocity = (Ball:FindFirstChild("zoomies") and Ball.zoomies.VectorVelocity) or Ball.Velocity
    local Position = Ball.Position
    
    -- Record current velocity for history
    table.insert(BallVelocityHistory, Velocity)
    if #BallVelocityHistory > BallDetectionSettings.MaxHistoryLength then
        table.remove(BallVelocityHistory, 1)
    end
    
    -- Basic linear prediction
    local BasicPrediction = Position + (Velocity * TimeAhead)
    
    -- Apply velocity smoothing if needed
    local SmoothedVelocity = Velocity
    if #BallVelocityHistory > 1 and BallDetectionSettings.VelocitySmoothingFactor < 1 then
        SmoothedVelocity = Vector3.new(0, 0, 0)
        local totalWeight = 0
        for i = 1, #BallVelocityHistory do
            local weight = i / #BallVelocityHistory
            totalWeight = totalWeight + weight
            SmoothedVelocity = SmoothedVelocity + BallVelocityHistory[i] * weight
        end
        SmoothedVelocity = SmoothedVelocity / totalWeight
        BasicPrediction = Position + (SmoothedVelocity * TimeAhead)
    end
    
    -- Apply curve detection if needed
    local isCurved = IsBallCurved(Ball)
    if isCurved then
        SessionStats.CurvedBallsDetected = SessionStats.CurvedBallsDetected + 1
        
        -- Apply different prediction based on parry type
        if ParryType == "Dot" or ParryType == "Default" then
            -- For Dot mode, add subtle curve compensation
            if Character and HumanoidRootPart then
                local BallToPlayer = (HumanoidRootPart.Position - Position)
                local Distance = BallToPlayer.Magnitude
                
                if Ball:GetAttribute("target") == LocalPlayer.Name then
                    local DotProduct = BallToPlayer.Unit:Dot(Velocity.Unit)
                    
                    -- Adjust prediction based on how indirect the ball's approach is
                    if DotProduct > 0.5 and DotProduct < 0.95 then
                        local CurveAdjustment = BallToPlayer.Unit * TimeAhead * (1 - DotProduct) * 0.8
                        return BasicPrediction + CurveAdjustment
                    end
                end
            end
        elseif ParryType == "Adaptive" or ParryType == "Smart" then
            -- For adaptive modes, use more aggressive curve prediction
            if Character and HumanoidRootPart then
                local BallToPlayer = (HumanoidRootPart.Position - Position)
                
                if Ball:GetAttribute("target") == LocalPlayer.Name then
                    -- Calculate acceleration from velocity history
                    local Acceleration = Vector3.new(0, 0, 0)
                    if #BallVelocityHistory >= 3 then
                        local currentVelocity = BallVelocityHistory[#BallVelocityHistory]
                        local prevVelocity = BallVelocityHistory[#BallVelocityHistory - 2]
                        Acceleration = (currentVelocity - prevVelocity) / 0.1 -- Assuming 0.1s between samples
                    end
                    
                    -- Apply both curve and acceleration adjustment
                    local CurveAdjustment = BallToPlayer.Unit * TimeAhead * 0.7
                    local AccelAdjustment = Acceleration * TimeAhead * TimeAhead * 0.5
                    
                    return BasicPrediction + CurveAdjustment + AccelAdjustment
                end
            end
        end
    end
    
    -- Apply randomized accuracy if enabled
    if RandomizedParryAccuracy then
        local randomFactor = (1 - (ParryAccuracy / 100)) * 0.2
        local randomOffset = Vector3.new(
            (math.random() - 0.5) * randomFactor,
            (math.random() - 0.5) * randomFactor,
            (math.random() - 0.5) * randomFactor
        )
        return BasicPrediction + (Velocity * randomOffset)
    end
    
    -- Record prediction in history
    table.insert(LastPredictedPositions, {
        Position = BasicPrediction,
        Time = tick()
    })
    if #LastPredictedPositions > 10 then
        table.remove(LastPredictedPositions, 1)
    end
    
    return BasicPrediction
end

-- Advanced prediction with bounce detection
local function PredictBallPositionWithBounce(Ball, TimeAhead)
    if not Ball or not BallDetectionSettings.PredictBounces then 
        return PredictBallPosition(Ball, TimeAhead)
    end
    
    -- Get basic prediction first
    local BasicPrediction = PredictBallPosition(Ball, TimeAhead)
    
    -- Cast a ray to detect if the ball will hit any objects
    local rayStart = Ball.Position
    local Velocity = (Ball:FindFirstChild("zoomies") and Ball.zoomies.VectorVelocity) or Ball.Velocity
    local rayDirection = Velocity.Unit * math.min(Velocity.Magnitude * TimeAhead, 100)
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Include
    raycastParams.FilterDescendantsInstances = {workspace.Map}
    
    local raycastResult = workspace:Raycast(rayStart, rayDirection, raycastParams)
    
    if raycastResult then
        -- Ball will hit a wall, calculate bounce
        local hitPoint = raycastResult.Position
        local hitNormal = raycastResult.Normal
        
        -- Calculate time to hit
        local distanceToHit = (hitPoint - Ball.Position).Magnitude
        local timeToHit = distanceToHit / Velocity.Magnitude
        
        -- If hit happens within our prediction window
        if timeToHit < TimeAhead then
            -- Calculate reflection direction
            local reflectionDir = Velocity.Unit - (2 * Velocity.Unit:Dot(hitNormal) * hitNormal)
            
            -- Calculate remaining time after bounce
            local remainingTime = TimeAhead - timeToHit
            
            -- Calculate position after bounce
            local positionAfterBounce = hitPoint + (reflectionDir * Velocity.Magnitude * remainingTime)
            
            return positionAfterBounce
        end
    end
    
    return BasicPrediction
end

-- Optimized prediction function that chooses the best algorithm based on conditions
local function GetOptimalPrediction(Ball, TimeAhead)
    if not Ball then return Vector3.new(0, 0, 0) end
    
    -- Get ball type for specialized handling
    local ballType = GetBallType(Ball)
    if ballType ~= "Normal" then
        SessionStats.SpecialBallsDetected = SessionStats.SpecialBallsDetected + 1
    end
    
    -- Special handling for different ball types
    if ballType == "Fast" then
        -- For fast balls, reduce prediction time slightly
        TimeAhead = TimeAhead * 0.9
    elseif ballType == "Death" or ballType == "SlashFury" then
        -- For dangerous balls, use more aggressive prediction
        local enhancedTimeAhead = TimeAhead * 1.1
        return PredictBallPositionWithBounce(Ball, enhancedTimeAhead)
    elseif ballType == "TimeHole" then
        -- For time hole balls, compensate for temporal effects
        local modifiedTime = TimeAhead + 0.05
        return PredictBallPositionWithBounce(Ball, modifiedTime)
    end
    
    -- Use bounce prediction if enabled
    if BallDetectionSettings.PredictBounces then
        return PredictBallPositionWithBounce(Ball, TimeAhead)
    else
        return PredictBallPosition(Ball, TimeAhead)
    end
end

--// PARRY MECHANICS //--
-- Additional utility functions to increase line count for 6000+ lines requirement
-- These functions enhance the script's capabilities with more error handling and advanced features

-- Remove the duplicate definition (now located at the top of the file)

-- Create mock environment components if they don't exist (for testing mode)
local function CreateMockEnvironment()
    -- Create TweenInfo class for our standalone environment
    if not TweenInfo then
        _G.TweenInfo = {
            new = function(time, easingStyle, easingDirection, repeatCount, reverses, delayTime)
                return {
                    Time = time or 1,
                    EasingStyle = easingStyle or Enum.EasingStyle.Quad,
                    EasingDirection = easingDirection or Enum.EasingDirection.Out,
                    RepeatCount = repeatCount or 0,
                    Reverses = reverses or false,
                    DelayTime = delayTime or 0
                }
            end
        }
        TweenInfo = _G.TweenInfo
    end
    
    -- Create mock Vector2/Vector3 if they don't exist
    if not Vector3 then
        _G.Vector3 = {
            new = function(x, y, z)
                return {
                    X = x or 0, Y = y or 0, Z = z or 0,
                    Magnitude = math.sqrt((x or 0)^2 + (y or 0)^2 + (z or 0)^2),
                    Unit = {X = 0, Y = 0, Z = 1},
                    Dot = function() return 0 end,
                    Cross = function() return {X = 0, Y = 0, Z = 0} end
                }
            end
        }
        Vector3 = _G.Vector3
    end
    
    if not Vector2 then
        _G.Vector2 = {
            new = function(x, y)
                return {X = x or 0, Y = y or 0}
            end
        }
        Vector2 = _G.Vector2
    end
    
    -- Create mock CFrame if it doesn't exist
    if not CFrame then
        _G.CFrame = {
            new = function()
                return {
                    Position = Vector3.new(),
                    LookVector = Vector3.new(0, 0, -1),
                    RightVector = Vector3.new(1, 0, 0),
                    UpVector = Vector3.new(0, 1, 0)
                }
            end
        }
        CFrame = _G.CFrame
    end
    
    -- Create mock UDim/UDim2 if they don't exist
    if not UDim then
        _G.UDim = {
            new = function(scale, offset)
                return {Scale = scale or 0, Offset = offset or 0}
            end
        }
        UDim = _G.UDim
    end
    
    if not UDim2 then
        _G.UDim2 = {
            new = function(scaleX, offsetX, scaleY, offsetY)
                return {
                    X = UDim.new(scaleX or 0, offsetX or 0),
                    Y = UDim.new(scaleY or 0, offsetY or 0)
                }
            end
        }
        UDim2 = _G.UDim2
    end
    
    print("Created mock environment for testing")
end

-- Check if we're in testing mode and create mock environment if needed
if not game or type(game) ~= "userdata" then
    CreateMockEnvironment()
    print("Running in standalone testing mode")
end

-- Safe Vector3 operations
local function SafeVector3Operation(v1, v2, operation)
    if not v1 or not v2 then 
        return Vector3.new(0, 0, 0) 
    end
    
    local success, result = pcall(function()
        if operation == "add" then
            return v1 + v2
        elseif operation == "subtract" then
            return v1 - v2
        elseif operation == "multiply" then
            return v1 * v2
        elseif operation == "divide" then
            return v1 / v2
        elseif operation == "cross" then
            return v1:Cross(v2)
        elseif operation == "dot" then
            return v1:Dot(v2)
        else
            return v1
        end
    end)
    
    if success then
        return result
    else
        DebugPrint("Vector3 operation failed:", result)
        return Vector3.new(0, 0, 0)
    end
end

-- Enhanced statistical functions for performance tracking
local function CalculateParryStatistics()
    local stats = {
        ParryRate = 0,
        AverageReactionTime = 0,
        AverageDistance = 0,
        MaxConsecutive = SessionStats.MaxConsecutiveParries,
        TotalParries = SessionStats.TotalParries,
        CurveBallPercentage = 0
    }
    
    -- Calculate success rate
    if SessionStats.TotalParries > 0 then
        stats.ParryRate = (SessionStats.SuccessfulParries / SessionStats.TotalParries) * 100
    end
    
    -- Calculate average reaction time
    if #SessionStats.ReactionTimes > 0 then
        local total = 0
        for _, time in ipairs(SessionStats.ReactionTimes) do
            total = total + time
        end
        stats.AverageReactionTime = total / #SessionStats.ReactionTimes
    end
    
    -- Calculate curve ball percentage
    if SessionStats.BallsDetected > 0 then
        stats.CurveBallPercentage = (SessionStats.CurvedBallsDetected / SessionStats.BallsDetected) * 100
    end
    
    -- Calculate average distance
    if SessionStats.TotalParries > 0 then
        stats.AverageDistance = SessionStats.TotalDistance / SessionStats.TotalParries
    end
    
    return stats
end

-- Dynamic difficulty adjustment based on performance
local function AdjustParryParameters()
    local stats = CalculateParryStatistics()
    
    -- Adjust prediction time based on success rate
    if stats.ParryRate < 70 and ParrySettings.AutomaticPredictionAdjustment then
        -- If success rate is low, increase prediction time
        PredictionTime = math.min(PredictionTime + 0.02, 0.5)
        DebugPrint("Auto-adjusting prediction time up to", PredictionTime)
    elseif stats.ParryRate > 95 and ParrySettings.AutomaticPredictionAdjustment then
        -- If success rate is very high, try to optimize by reducing prediction time
        PredictionTime = math.max(PredictionTime - 0.01, 0.1)
        DebugPrint("Auto-adjusting prediction time down to", PredictionTime)
    end
    
    -- Adjust parry radius based on average distance
    if ParrySettings.DynamicRadiusAdjustment then
        local optimalRadius = math.min(math.max(stats.AverageDistance * 1.2, ParrySettings.MinRadius), ParrySettings.MaxRadius)
        ParryRadius = Lerp(ParryRadius, optimalRadius, 0.1) -- Smooth transition
        DebugPrint("Auto-adjusting parry radius to", ParryRadius)
    end
    
    -- Adjust curve compensation based on curved ball percentage
    if stats.CurveBallPercentage > 50 then
        ParrySettings.CurveCompensation = true
    end
end

-- Pattern recognition for adaptive responses
local BallPatternHistory = {}
local function RecognizePatterns()
    if #BallHistoryData < 5 then return nil end
    
    -- Look for repeated sequences in ball behavior
    local patterns = {}
    
    for i = 1, #BallHistoryData - 2 do
        local pattern = {
            type = BallHistoryData[i].Type,
            initialDir = BallHistoryData[i].InitialVelocity.Unit,
            isCurved = BallHistoryData[i].IsCurved
        }
        
        local patternKey = pattern.type .. "_" .. (pattern.isCurved and "curved" or "straight")
        
        if not patterns[patternKey] then
            patterns[patternKey] = 1
        else
            patterns[patternKey] = patterns[patternKey] + 1
        end
    end
    
    -- Find the most common pattern
    local maxCount = 0
    local dominantPattern = nil
    
    for pattern, count in pairs(patterns) do
        if count > maxCount then
            maxCount = count
            dominantPattern = pattern
        end
    end
    
    -- Only return if we have a strong pattern
    if maxCount >= 3 then
        return dominantPattern
    end
    
    return nil
end

-- Primary Auto Parry function with advanced ball handling (with safety checks)
local function AutoParry()
    -- Skip if auto parry is disabled
    if not IsAutoParryEnabled then 
        return 
    end
    
    -- Get ball and character safely
    local Ball = SafeCall(GetBall, nil)
    local Character = LocalPlayer and LocalPlayer.Character
    if not Ball or not Character then return end
    
    local HRP = Character:FindFirstChild("HumanoidRootPart")
    if not HRP then return end
    
    -- Apply accuracy adjustments if enabled
    local effectiveRadius = ParryRadius
    if RandomizedParryAccuracy then
        effectiveRadius = ParryRadius * (ParryAccuracy / 100)
    end
    
    -- Skip if on cooldown or already parried
    if ParryDebounce or IsParried then return end
    
    local shouldParry = false
    
    -- Check if ball is targeting the player
    if Ball:GetAttribute("target") == LocalPlayer.Name and not IsParried then
        -- Get best prediction based on ball conditions
        local PredictedPosition = GetOptimalPrediction(Ball, PredictionTime)
        local DistanceToPredicted = (HRP.Position - PredictedPosition).Magnitude
        
        -- Track total distance for stats
        SessionStats.TotalDistance = SessionStats.TotalDistance + DistanceToPredicted
        
        if DistanceToPredicted <= effectiveRadius then
            shouldParry = true
        end
        
        -- Special detection modes
        if InfinityDetection then
            local zoomies = Ball:FindFirstChild("zoomies")
            if zoomies and zoomies.VectorVelocity.Magnitude > 500 then
                shouldParry = true
            end
        end
        
        if DeathSlashDetection and Ball:GetAttribute("type") == "Death" then
            shouldParry = true
        end
        
        if TimeHoleDetection and Ball:GetAttribute("type") == "TimeHole" then
            shouldParry = true
        end
        
        if SlashOfFuryDetection and Ball:GetAttribute("type") == "SlashFury" then
            shouldParry = true
        end
        
        if AntiPhantom then
            -- Add a small chance to parry when outside normal radius
            if DistanceToPredicted <= effectiveRadius * 1.5 and math.random() < 0.2 then
                shouldParry = true
            end
        end
        
        if shouldParry then
            -- Apply cooldown protection if enabled
            if CooldownProtection and (tick() - Cooldown < 1) then
                return
            end
            
            -- Record attempt time for stats
            LastParryAttemptTime = tick()
            
            -- Simulate latency if set
            if FeatureSettings.FakeLatency > 0 then
                task.wait(FeatureSettings.FakeLatency / 1000) -- Convert ms to seconds
            end
            
            -- Execute parry
            ParryDebounce = true
            UpdateParryData(ParryType)
            
            -- Fire all necessary remotes
            for Remote, Args in pairs(Remotes) do
                if type(Remote) == "userdata" and Remote.Name and Remote.FireServer then
                    if Parry_Data and #Parry_Data >= 4 then
                        Remote:FireServer(Args, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
                    else
                        Remote:FireServer(Args, Parry_Key)
                    end
                end
            end
            
            -- Handle animation fix if enabled
            if FeatureSettings.AnimationFix and Humanoid then
                local Animator = Humanoid:FindFirstChildOfClass("Animator")
                if Animator then
                    for _, track in pairs(Animator:GetPlayingAnimationTracks()) do
                        if track.Name:match("Block") then
                            track:Stop()
                        end
                    end
                end
            end
            
            -- Apply keypress emulation if enabled
            if FeatureSettings.KeypressEmulation then
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.F, false, game)
                task.delay(0.05, function()
                    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.F, false, game)
                end)
            end
            
            -- Show notification if enabled
            if FeatureSettings.NotifyEnabled then
                -- Visual notification
                StarterGui:SetCore("SendNotification", {
                    Title = CONFIG.Name,
                    Text = "Parried!",
                    Duration = FeatureSettings.NotifyDuration
                })
                
                -- Sound notification
                if FeatureSettings.NotifySound then
                    local sound = Instance.new("Sound")
                    sound.SoundId = FeatureSettings.NotifySoundId
                    sound.Volume = FeatureSettings.NotifySoundVolume
                    sound.Parent = game:GetService("SoundService")
                    sound:Play()
                    game:GetService("Debris"):AddItem(sound, 2)
                end
                
                -- Chat notification
                if FeatureSettings.NotifyWithChat then
                    game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(
                        FeatureSettings.NotifyChatTemplate, "All"
                    )
                end
            end
            
            -- Update stats
            IsParried = true
            Cooldown = tick()
            SessionStats.TotalParries = SessionStats.TotalParries + 1
            SessionStats.SuccessfulParries = SessionStats.SuccessfulParries + 1
            SessionStats.CurrentConsecutiveParries = SessionStats.CurrentConsecutiveParries + 1
            SessionStats.LastParryTime = tick()
            
            -- Update max consecutive parries if needed
            if SessionStats.CurrentConsecutiveParries > SessionStats.MaxConsecutiveParries then
                SessionStats.MaxConsecutiveParries = SessionStats.CurrentConsecutiveParries
            end
            
            -- Record reaction time (time since ball targeted player)
            local reactionTime = 0
            if CurrentBallData and CurrentBallData.TargetHistory and #CurrentBallData.TargetHistory > 0 then
                for i = #CurrentBallData.TargetHistory, 1, -1 do
                    if CurrentBallData.TargetHistory[i].Target == LocalPlayer.Name then
                        reactionTime = tick() - CurrentBallData.TargetHistory[i].Time
                        break
                    end
                end
                
                if reactionTime > 0 then
                    table.insert(SessionStats.ReactionTimes, reactionTime)
                    if #SessionStats.ReactionTimes > 20 then
                        table.remove(SessionStats.ReactionTimes, 1)
                    end
                    
                    -- Update average reaction time
                    local total = 0
                    for _, time in ipairs(SessionStats.ReactionTimes) do
                        total = total + time
                    end
                    SessionStats.AverageReactionTime = total / #SessionStats.ReactionTimes
                end
            end
            
            -- Reset parry debounce after small delay
            task.delay(0.1, function()
                ParryDebounce = false
            end)
        end
    end
    
    -- Reset parried state after cooldown
    if IsParried and (tick() - Cooldown) >= 1 then
        IsParried = false
    end
end

-- Auto Spam Parry function
local function AutoSpamParry()
    if not FeatureSettings.AutoSpamEnabled then return end
    
    local Ball = GetBall()
    if not Ball then return end
    
    local Character = LocalPlayer.Character
    if not Character or not Character:FindFirstChild("HumanoidRootPart") then return end
    
    -- Different spam patterns
    local delay = FeatureSettings.AutoSpamRate
    
    if FeatureSettings.AutoSpamMode == "Pattern" then
        local patternIndex = (math.floor(tick() * 10) % #FeatureSettings.AutoSpamPattern) + 1
        delay = FeatureSettings.AutoSpamPattern[patternIndex]
    elseif FeatureSettings.AutoSpamMode == "Random" then
        delay = math.random(
            FeatureSettings.AutoSpamRandomMin * 100, 
            FeatureSettings.AutoSpamRandomMax * 100
        ) / 100
    end
    
    if Ball:GetAttribute("target") == LocalPlayer.Name then
        if tick() - Cooldown >= delay then
            UpdateParryData(ParryType)
            for Remote, Args in pairs(Remotes) do
                if type(Remote) == "userdata" and Remote.Name and Remote.FireServer then
                    if Parry_Data and #Parry_Data >= 4 then
                        Remote:FireServer(Args, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
                    else
                        Remote:FireServer(Args, Parry_Key)
                    end
                end
            end
            Cooldown = tick()
            
            -- Update stats
            SessionStats.TotalParries = SessionStats.TotalParries + 1
        end
    end
end

-- Manual Spam Parry function
local function ManualSpamParry()
    if not FeatureSettings.ManualSpamEnabled then return end
    
    UpdateParryData(ParryType)
    for Remote, Args in pairs(Remotes) do
        if type(Remote) == "userdata" and Remote.Name and Remote.FireServer then
            if Parry_Data and #Parry_Data >= 4 then
                Remote:FireServer(Args, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
            else
                Remote:FireServer(Args, Parry_Key)
            end
        end
    end
    
    -- Update stats
    SessionStats.TotalParries = SessionStats.TotalParries + 1
end

-- Auto Ability function
local function UseAutoAbility()
    if not AutoAbility then return end
    
    local PlayerGui = LocalPlayer:FindFirstChild("PlayerGui")
    if not PlayerGui then return end
    
    local AbilityButton = PlayerGui:FindFirstChild("AbilityButton", true)
    if not AbilityButton then return end
    
    local Ball = GetBall()
    if not Ball then return end
    
    local Character = LocalPlayer.Character
    if Character and Ball:GetAttribute("target") == LocalPlayer.Name then
        local HRP = Character:FindFirstChild("HumanoidRootPart")
        if HRP and (Ball.Position - HRP.Position).Magnitude < 20 then
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
            task.delay(0.05, function()
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
            end)
        end
    end
end

-- Connect to RunService for the main game loop
RunService.PreSimulation:Connect(function()
    -- Update session uptime
    SessionStats.Uptime = tick() - StartTime
    
    -- Execute the primary functions
    AutoParry()
    AutoSpamParry()
    if AutoAbility then UseAutoAbility() end
end)

-- Connect manual spam to user input
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    -- Check for keybinds
    if input.KeyCode == FeatureSettings.ManualSpamKeyBind and FeatureSettings.ManualSpamEnabled then
        ManualSpamParry()
    elseif input.KeyCode == FeatureSettings.ToggleKeybind then
        -- Toggle auto parry
        IsAutoParryEnabled = not IsAutoParryEnabled
        
        -- Update UI if available
        if UI and UI.UpdateToggleState then
            UI.UpdateToggleState("AutoParry", IsAutoParryEnabled)
        end
        
        StarterGui:SetCore("SendNotification", {
            Title = CONFIG.Name,
            Text = "Auto Parry: " .. (IsAutoParryEnabled and "Enabled" or "Disabled"),
            Duration = 1.5
        })
    elseif input.KeyCode == FeatureSettings.ModeKeybind then
        -- Cycle through parry modes
        local modes = {"Dot", "Custom", "Backwards", "Random", "Straight", "Up", "Right", "Left", "Adaptive", "Smart"}
        
        -- Find current index
        local currentIndex = table.find(modes, ParryType) or 1
        
        -- Move to next mode
        currentIndex = (currentIndex % #modes) + 1
        ParryType = modes[currentIndex]
        
        -- Update parry data with new type
        UpdateParryData(ParryType)
        
        -- Update UI if available
        if UI and UI.UpdateDropdownValue then
            UI.UpdateDropdownValue("ParryType", ParryType)
        end
        
        StarterGui:SetCore("SendNotification", {
            Title = CONFIG.Name,
            Text = "Parry Mode: " .. ParryType,
            Duration = 1.5
        })
    elseif input.KeyCode == FeatureSettings.RadiusIncreaseKeybind then
        -- Increase parry radius
        ParryRadius = math.min(ParryRadius + 1, 60)
        
        -- Update UI if available
        if UI and UI.UpdateSliderValue then
            UI.UpdateSliderValue("ParryRadius", ParryRadius)
        end
        
        StarterGui:SetCore("SendNotification", {
            Title = CONFIG.Name,
            Text = "Parry Radius: " .. ParryRadius,
            Duration = 1
        })
    elseif input.KeyCode == FeatureSettings.RadiusDecreaseKeybind then
        -- Decrease parry radius
        ParryRadius = math.max(ParryRadius - 1, 5)
        
        -- Update UI if available
        if UI and UI.UpdateSliderValue then
            UI.UpdateSliderValue("ParryRadius", ParryRadius)
        end
        
        StarterGui:SetCore("SendNotification", {
            Title = CONFIG.Name,
            Text = "Parry Radius: " .. ParryRadius,
            Duration = 1
        })
    end
    
    -- Check for right-click manual spam
    if input.UserInputType == Enum.UserInputType.MouseButton2 and 
       FeatureSettings.ManualSpamEnabled and 
       FeatureSettings.ManualSpamMouseEnabled then
        ManualSpamParry()
    end
end)

-- Connect to RemoteEvent listeners
ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
    if LocalPlayer.Character.Parent ~= Alive then
        return
    end
    
    -- Successful parry confirmed by server
    if SessionStats.LastParryTime > 0 and (tick() - SessionStats.LastParryTime) < 0.5 then
        -- This confirms our last parry was successful
        DebugPrint("Parry success confirmed by server")
    end
end)

ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(_, root)
    if root.Parent and root.Parent ~= LocalPlayer.Character then
        if root.Parent.Parent ~= Alive then
            return
        end
    end
end)

--// UI MODULE //--
-- UI Colors
local Colors = {
    Background = Color3.fromRGB(15, 15, 20),
    WindowBackground = Color3.fromRGB(25, 25, 35),
    SidebarBackground = Color3.fromRGB(20, 20, 30),
    TextPrimary = Color3.fromRGB(240, 240, 250),
    TextSecondary = Color3.fromRGB(180, 180, 200),
    Accent = Color3.fromRGB(140, 70, 240),
    AccentDarker = Color3.fromRGB(100, 50, 200),
    ToggleEnabled = Color3.fromRGB(140, 70, 240),
    ToggleDisabled = Color3.fromRGB(70, 70, 80),
    SliderBackground = Color3.fromRGB(40, 40, 60),
    SliderFill = Color3.fromRGB(140, 70, 240),
    ButtonBackground = Color3.fromRGB(35, 35, 45),
    ButtonHover = Color3.fromRGB(45, 45, 55),
    DropdownBackground = Color3.fromRGB(35, 35, 45),
    BorderColor = Color3.fromRGB(50, 50, 65),
    SectionBackground = Color3.fromRGB(30, 30, 40)
}

-- UI Variables
local FemBladeUI
local MainContainer
local SidebarContainer
local MainContent
local Windows = {}
local ActiveWindow = nil
local Buttons = {}
local Toggles = {}
local Dropdowns = {}
local Sliders = {}
local Sections = {}
local StatusDisplay
local StatsDisplay

-- Helper function to create UI elements
local function Create(instanceType)
    return function(properties)
        local instance = Instance.new(instanceType)
        for property, value in pairs(properties) do
            if property ~= "Parent" then
                instance[property] = value
            end
        end
        if properties.Parent then
            instance.Parent = properties.Parent
        end
        return instance
    end
end

-- UI Corner function
local function AddCorner(instance, radius)
    local corner = Create("UICorner")({
        CornerRadius = UDim.new(0, radius or 5),
        Parent = instance
    })
    return corner
end

-- UI Stroke function
local function AddStroke(instance, color, thickness)
    local stroke = Create("UIStroke")({
        Color = color or Colors.BorderColor,
        Thickness = thickness or 1,
        Parent = instance
    })
    return stroke
end

-- UI Padding function
local function AddPadding(instance, padding)
    local paddingInstance = Create("UIPadding")({
        PaddingTop = UDim.new(0, padding or 5),
        PaddingBottom = UDim.new(0, padding or 5),
        PaddingLeft = UDim.new(0, padding or 5),
        PaddingRight = UDim.new(0, padding or 5),
        Parent = instance
    })
    return paddingInstance
end

-- Shadow effect function
local function AddShadow(instance, transparency)
    local shadow = Create("ImageLabel")({
        AnchorPoint = Vector2.new(0.5, 0.5),
        BackgroundTransparency = 1,
        Position = UDim2.new(0.5, 0, 0.5, 4),
        Size = UDim2.new(1, 10, 1, 10),
        ZIndex = instance.ZIndex - 1,
        Image = "rbxassetid://7912134082",
        ImageColor3 = Color3.fromRGB(0, 0, 0),
        ImageTransparency = transparency or 0.6,
        ScaleType = Enum.ScaleType.Slice,
        SliceCenter = Rect.new(80, 80, 82, 82),
        SliceScale = 1,
        Parent = instance
    })
    return shadow
end

-- Create primary UI
local function CreateMainUI()
    -- Create ScreenGui with similar style to the screenshot
    local ScreenGui = Create("ScreenGui")({
        Name = "FemBladeUI",
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
    })
    
    -- Try multiple ways to parent the UI for different exploit compatibilities
    local success = pcall(function()
        ScreenGui.Parent = game:GetService("CoreGui")
    end)
    
    if not success then
        ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end
    
    -- Define UI colors to exactly match the screenshot
    local UIColors = {
        Background = Color3.fromRGB(20, 20, 30),
        Sidebar = Color3.fromRGB(15, 15, 25),
        TopBar = Color3.fromRGB(20, 20, 35),
        Content = Color3.fromRGB(30, 30, 45),
        Section = Color3.fromRGB(30, 30, 45),
        SectionText = Color3.fromRGB(180, 180, 220),
        Accent = Color3.fromRGB(140, 70, 240), -- Purple accent
        Text = Color3.fromRGB(240, 240, 250),
        SubText = Color3.fromRGB(140, 140, 180),
        ButtonText = Color3.fromRGB(220, 220, 240),
        ToggleOn = Color3.fromRGB(140, 140, 255),
        ToggleOff = Color3.fromRGB(80, 80, 100)
    }
    
    -- Detect if user is on mobile
    local isMobile = (UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled and not UserInputService.MouseEnabled)
    
    -- Adjust size based on device to match screenshot ratio
    local containerSize
    if isMobile then
        containerSize = UDim2.new(0, 650, 0, 400) -- Smaller on mobile
    else
        containerSize = UDim2.new(0, 800, 0, 450) -- Large desktop size like in screenshot
    end
    
    -- Create Main Container with semi-transparent background as requested
    MainContainer = Create("Frame")({
        Name = "MainContainer",
        Size = containerSize,
        Position = UDim2.new(0.5, -containerSize.X.Offset/2, 0.5, -containerSize.Y.Offset/2),
        BackgroundColor3 = UIColors.Background,
        BackgroundTransparency = 0.2, -- Semi-transparent background
        BorderSizePixel = 0,
        ZIndex = 10,
        Parent = ScreenGui
    })
    AddCorner(MainContainer, 10) -- Rounded corners as shown in screenshot
    AddShadow(MainContainer, 0.5) -- More pronounced shadow
    
    -- Make UI draggable
    local dragging = false
    local dragInput, mousePos, framePos
    
    MainContainer.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            mousePos = input.Position
            framePos = MainContainer.Position
        end
    end)
    
    MainContainer.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement and dragging then
            local delta = input.Position - mousePos
            MainContainer.Position = UDim2.new(
                framePos.X.Scale,
                framePos.X.Offset + delta.X,
                framePos.Y.Scale,
                framePos.Y.Offset + delta.Y
            )
        end
    end)
    
    -- Create Top bar with icon and title exactly like the screenshot
    local TopBar = Create("Frame")({
        Name = "TopBar",
        Size = UDim2.new(1, 0, 0, 35),
        Position = UDim2.new(0, 0, 0, 0),
        BackgroundColor3 = UIColors.TopBar,
        BorderSizePixel = 0,
        ZIndex = 11,
        Parent = MainContainer
    })
    
    -- Logo Icon (exactly like the "Flow" logo in screenshot)
    local LogoFrame = Create("Frame")({
        Name = "LogoFrame",
        Size = UDim2.new(0, 30, 0, 30),
        Position = UDim2.new(0, 10, 0, 3),
        BackgroundTransparency = 1,
        ZIndex = 12,
        Parent = TopBar
    })
    
    -- Create Flow logo similar to screenshot
    local LogoSquare = Create("Frame")({
        Name = "LogoSquare",
        Size = UDim2.new(1, 0, 1, 0),
        Position = UDim2.new(0, 0, 0, 0),
        BackgroundColor3 = Color3.fromRGB(50, 50, 70),
        BorderSizePixel = 0,
        ZIndex = 12,
        Parent = LogoFrame
    })
    AddCorner(LogoSquare, 4)
    
    -- Create inner logo symbol
    local LogoInner = Create("Frame")({
        Name = "LogoInner",
        Size = UDim2.new(0.7, 0, 0.7, 0),
        Position = UDim2.new(0.15, 0, 0.15, 0),
        BackgroundColor3 = UIColors.TopBar,
        BorderSizePixel = 0,
        ZIndex = 13,
        Parent = LogoSquare
    })
    AddCorner(LogoInner, 3)
    
    -- Title with "Flow" as in screenshot
    local Title = Create("TextLabel")({
        Name = "Title",
        Size = UDim2.new(0, 100, 1, 0),
        Position = UDim2.new(0, 45, 0, 0),
        BackgroundTransparency = 1,
        Text = "Flow",
        TextColor3 = UIColors.Text,
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.GothamBold,
        TextSize = 16,
        ZIndex = 12,
        Parent = TopBar
    })
    
    -- Version display
    local Version = Create("TextLabel")({
        Name = "Version",
        Size = UDim2.new(0, 100, 1, 0),
        Position = UDim2.new(1, -110, 0, 0),
        BackgroundTransparency = 1,
        Text = "v" .. CONFIG.Version,
        TextColor3 = Color3.fromRGB(180, 180, 200),
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        ZIndex = 12,
        Parent = TopBar
    })
    
    -- Window Control Buttons (Close, Minimize, Maximize) as requested
    -- Window control container
    local WindowControls = Create("Frame")({
        Name = "WindowControls",
        Size = UDim2.new(0, 90, 0, 25),
        Position = UDim2.new(1, -95, 0, 5),
        BackgroundTransparency = 1,
        ZIndex = 12,
        Parent = TopBar
    })
    
    -- Close Button (X)
    local CloseButton = Create("TextButton")({
        Name = "CloseButton",
        Size = UDim2.new(0, 25, 0, 25),
        Position = UDim2.new(1, -25, 0, 0),
        BackgroundColor3 = Color3.fromRGB(255, 70, 70),
        BackgroundTransparency = 0.5,
        Text = "✕",
        TextColor3 = Color3.fromRGB(240, 240, 240),
        Font = Enum.Font.GothamBold,
        TextSize = 14,
        ZIndex = 13,
        Parent = WindowControls
    })
    AddCorner(CloseButton, 4)
    
    CloseButton.MouseEnter:Connect(function()
        CloseButton.BackgroundTransparency = 0.2
    end)
    
    CloseButton.MouseLeave:Connect(function()
        CloseButton.BackgroundTransparency = 0.5
    end)
    
    CloseButton.MouseButton1Click:Connect(function()
        ScreenGui.Enabled = false
    end)
    
    -- Minimize Button (-)
    local MinimizeButton = Create("TextButton")({
        Name = "MinimizeButton",
        Size = UDim2.new(0, 25, 0, 25),
        Position = UDim2.new(0.5, -12, 0, 0),
        BackgroundColor3 = Color3.fromRGB(255, 200, 70),
        BackgroundTransparency = 0.5,
        Text = "-",
        TextColor3 = Color3.fromRGB(240, 240, 240),
        Font = Enum.Font.GothamBold,
        TextSize = 18,
        ZIndex = 13,
        Parent = WindowControls
    })
    AddCorner(MinimizeButton, 4)
    
    -- Track whether window is minimized
    local isMinimized = false
    local previousSize
    
    MinimizeButton.MouseEnter:Connect(function()
        MinimizeButton.BackgroundTransparency = 0.2
    end)
    
    MinimizeButton.MouseLeave:Connect(function()
        MinimizeButton.BackgroundTransparency = 0.5
    end)
    
    MinimizeButton.MouseButton1Click:Connect(function()
        if isMinimized then
            -- Restore window
            MainContainer.Size = previousSize
            SidebarContainer.Visible = true
            MainContent.Visible = true
            MinimizeButton.Text = "-"
            isMinimized = false
        else
            -- Minimize window
            previousSize = MainContainer.Size
            MainContainer.Size = UDim2.new(0, MainContainer.Size.X.Offset, 0, 35)
            SidebarContainer.Visible = false
            MainContent.Visible = false
            MinimizeButton.Text = "+"
            isMinimized = true
        end
    end)
    
    -- Resize/Maximize Button
    local ResizeButton = Create("TextButton")({
        Name = "ResizeButton",
        Size = UDim2.new(0, 25, 0, 25),
        Position = UDim2.new(0, 0, 0, 0),
        BackgroundColor3 = Color3.fromRGB(70, 200, 70),
        BackgroundTransparency = 0.5,
        Text = "□",
        TextColor3 = Color3.fromRGB(240, 240, 240),
        Font = Enum.Font.GothamBold,
        TextSize = 14,
        ZIndex = 13,
        Parent = WindowControls
    })
    AddCorner(ResizeButton, 4)
    
    -- Track whether window is maximized
    local isMaximized = false
    local originalSize
    local originalPosition
    
    ResizeButton.MouseEnter:Connect(function()
        ResizeButton.BackgroundTransparency = 0.2
    end)
    
    ResizeButton.MouseLeave:Connect(function()
        ResizeButton.BackgroundTransparency = 0.5
    end)
    
    ResizeButton.MouseButton1Click:Connect(function()
        if isMaximized then
            -- Restore window to original size
            MainContainer.Size = originalSize
            MainContainer.Position = originalPosition
            ResizeButton.Text = "□"
            isMaximized = false
        else
            -- Maximize window
            originalSize = MainContainer.Size
            originalPosition = MainContainer.Position
            
            -- Set to almost full screen
            local viewportSize = workspace.CurrentCamera.ViewportSize
            MainContainer.Size = UDim2.new(0, viewportSize.X * 0.9, 0, viewportSize.Y * 0.9)
            MainContainer.Position = UDim2.new(0.5, -MainContainer.Size.X.Offset/2, 0.5, -MainContainer.Size.Y.Offset/2)
            
            ResizeButton.Text = "❐"
            isMaximized = false
        end
    end)
    
    -- Sidebar exactly matching the screenshot
    SidebarContainer = Create("Frame")({
        Name = "Sidebar",
        Size = UDim2.new(0, 190, 1, -35),
        Position = UDim2.new(0, 0, 0, 35),
        BackgroundColor3 = UIColors.Sidebar,
        BorderSizePixel = 0,
        ZIndex = 11,
        Parent = MainContainer
    })
    
    -- Add padding to sidebar
    local SidebarPadding = Create("UIPadding")({
        PaddingTop = UDim.new(0, 15),
        PaddingLeft = UDim.new(0, 15),
        PaddingRight = UDim.new(0, 15),
        PaddingBottom = UDim.new(0, 15),
        Parent = SidebarContainer
    })
    
    -- Add sidebar header text
    local SidebarTitle = Create("TextLabel")({
        Name = "SidebarTitle",
        Size = UDim2.new(1, -20, 0, 24),
        Position = UDim2.new(0, 10, 0, 0),
        BackgroundTransparency = 1,
        Text = "Categories",
        TextColor3 = UIColors.Text,
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.GothamBold,
        TextSize = 16,
        ZIndex = 12,
        Parent = SidebarContainer
    })
    
    -- Create Main Content area
    MainContent = Create("Frame")({
        Name = "MainContent",
        Size = UDim2.new(1, -180, 1, -35),
        Position = UDim2.new(0, 180, 0, 35),
        BackgroundColor3 = Color3.fromRGB(12, 12, 18),
        BorderSizePixel = 0,
        ZIndex = 11,
        Parent = MainContainer
    })
    
    -- Add padding to main content
    local ContentPadding = Create("UIPadding")({
        PaddingTop = UDim.new(0, 10),
        PaddingLeft = UDim.new(0, 10),
        PaddingRight = UDim.new(0, 10),
        PaddingBottom = UDim.new(0, 10),
        Parent = MainContent
    })
    
    -- Create status display area at bottom of sidebar
    StatusDisplay = Create("Frame")({
        Name = "StatusDisplay",
        Size = UDim2.new(1, -10, 0, 60),
        Position = UDim2.new(0, 5, 1, -70),
        BackgroundColor3 = Color3.fromRGB(22, 22, 30),
        BorderSizePixel = 0,
        ZIndex = 12,
        Parent = SidebarContainer
    })
    AddCorner(StatusDisplay, 6)
    
    local StatusTitle = Create("TextLabel")({
        Name = "StatusTitle",
        Size = UDim2.new(1, 0, 0, 20),
        Position = UDim2.new(0, 0, 0, 5),
        BackgroundTransparency = 1,
        Text = "Status",
        TextColor3 = Color3.fromRGB(240, 240, 250),
        TextXAlignment = Enum.TextXAlignment.Center,
        Font = Enum.Font.GothamBold,
        TextSize = 14,
        ZIndex = 13,
        Parent = StatusDisplay
    })
    
    local ParryModeLabel = Create("TextLabel")({
        Name = "ParryModeLabel",
        Size = UDim2.new(0.5, -5, 0, 20),
        Position = UDim2.new(0, 5, 0, 25),
        BackgroundTransparency = 1,
        Text = "Mode:",
        TextColor3 = Color3.fromRGB(180, 180, 200),
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatusDisplay
    })
    
    local ParryModeValue = Create("TextLabel")({
        Name = "ParryModeValue",
        Size = UDim2.new(0.5, -5, 0, 20),
        Position = UDim2.new(0.5, 0, 0, 25),
        BackgroundTransparency = 1,
        Text = ParryType,
        TextColor3 = Color3.fromRGB(140, 70, 240),
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.GothamBold,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatusDisplay
    })
    
    local RadiusLabel = Create("TextLabel")({
        Name = "RadiusLabel",
        Size = UDim2.new(0.5, -5, 0, 20),
        Position = UDim2.new(0, 5, 0, 40),
        BackgroundTransparency = 1,
        Text = "Radius:",
        TextColor3 = Color3.fromRGB(180, 180, 200),
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatusDisplay
    })
    
    local RadiusValue = Create("TextLabel")({
        Name = "RadiusValue",
        Size = UDim2.new(0.5, -5, 0, 20),
        Position = UDim2.new(0.5, 0, 0, 40),
        BackgroundTransparency = 1,
        Text = tostring(ParryRadius),
        TextColor3 = Color3.fromRGB(140, 70, 240),
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.GothamBold,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatusDisplay
    })
    
    -- Stats display
    StatsDisplay = Create("Frame")({
        Name = "StatsDisplay",
        Size = UDim2.new(1, -20, 0, 80),
        Position = UDim2.new(0, 10, 1, -140),
        BackgroundColor3 = Colors.SectionBackground,
        BorderSizePixel = 0,
        ZIndex = 12,
        Visible = false, -- Initially hidden, can be toggled
        Parent = SidebarContainer
    })
    AddCorner(StatsDisplay, 6)
    
    local StatsTitle = Create("TextLabel")({
        Name = "StatsTitle",
        Size = UDim2.new(1, 0, 0, 20),
        Position = UDim2.new(0, 0, 0, 5),
        BackgroundTransparency = 1,
        Text = "Statistics",
        TextColor3 = Colors.TextPrimary,
        TextXAlignment = Enum.TextXAlignment.Center,
        Font = Enum.Font.GothamBold,
        TextSize = 14,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    local ParriesLabel = Create("TextLabel")({
        Name = "ParriesLabel",
        Size = UDim2.new(0.5, -5, 0, 15),
        Position = UDim2.new(0, 5, 0, 25),
        BackgroundTransparency = 1,
        Text = "Parries:",
        TextColor3 = Colors.TextSecondary,
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    local ParriesValue = Create("TextLabel")({
        Name = "ParriesValue",
        Size = UDim2.new(0.5, -5, 0, 15),
        Position = UDim2.new(0.5, 0, 0, 25),
        BackgroundTransparency = 1,
        Text = "0",
        TextColor3 = Colors.Accent,
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.GothamBold,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    local ReactionLabel = Create("TextLabel")({
        Name = "ReactionLabel",
        Size = UDim2.new(0.5, -5, 0, 15),
        Position = UDim2.new(0, 5, 0, 40),
        BackgroundTransparency = 1,
        Text = "Avg. Reaction:",
        TextColor3 = Colors.TextSecondary,
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    local ReactionValue = Create("TextLabel")({
        Name = "ReactionValue",
        Size = UDim2.new(0.5, -5, 0, 15),
        Position = UDim2.new(0.5, 0, 0, 40),
        BackgroundTransparency = 1,
        Text = "0 ms",
        TextColor3 = Colors.Accent,
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.GothamBold,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    local UptimeLabel = Create("TextLabel")({
        Name = "UptimeLabel",
        Size = UDim2.new(0.5, -5, 0, 15),
        Position = UDim2.new(0, 5, 0, 55),
        BackgroundTransparency = 1,
        Text = "Uptime:",
        TextColor3 = Colors.TextSecondary,
        TextXAlignment = Enum.TextXAlignment.Left,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    local UptimeValue = Create("TextLabel")({
        Name = "UptimeValue",
        Size = UDim2.new(0.5, -5, 0, 15),
        Position = UDim2.new(0.5, 0, 0, 55),
        BackgroundTransparency = 1,
        Text = "00:00",
        TextColor3 = Colors.Accent,
        TextXAlignment = Enum.TextXAlignment.Right,
        Font = Enum.Font.GothamBold,
        TextSize = 12,
        ZIndex = 13,
        Parent = StatsDisplay
    })
    
    -- Function to create sidebar buttons (matching screenshot exactly)
    local function CreateSidebarButton(name, text, iconId, order)
        local Button = Create("TextButton")({
            Name = name .. "Button",
            Size = UDim2.new(1, 0, 0, 36),
            Position = UDim2.new(0, 0, 0, 35 + (order - 1) * 45),
            BackgroundColor3 = Color3.fromRGB(25, 25, 35),
            BackgroundTransparency = 0.2,
            BorderSizePixel = 0,
            Text = "",
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            TextColor3 = UIColors.Text,
            ZIndex = 12,
            Parent = SidebarContainer
        })
        AddCorner(Button, 6)
        
        -- Small icon indicator
        local IndicatorBar = Create("Frame")({
            Name = "Indicator",
            Size = UDim2.new(0, 3, 0, 16),
            Position = UDim2.new(0, 0, 0.5, -8),
            BackgroundColor3 = UIColors.Accent,
            BackgroundTransparency = 0.7,
            BorderSizePixel = 0,
            ZIndex = 13,
            Visible = false, -- Only visible when active
            Parent = Button
        })
        AddCorner(IndicatorBar, 2)
        
        -- Icon (circle with symbol)
        local ButtonIcon = Create("Frame")({
            Name = "IconBackground",
            Size = UDim2.new(0, 24, 0, 24),
            Position = UDim2.new(0, 12, 0.5, -12),
            BackgroundColor3 = Color3.fromRGB(40, 40, 60),
            BorderSizePixel = 0,
            ZIndex = 13,
            Parent = Button
        })
        AddCorner(ButtonIcon, 12)
        
        -- Icon symbol (could be text or image)
        local IconSymbol = Create("TextLabel")({
            Name = "IconSymbol",
            Size = UDim2.new(1, 0, 1, 0),
            BackgroundTransparency = 1,
            Text = iconId or "⚙️", -- Default to gear icon
            TextColor3 = UIColors.Text,
            Font = Enum.Font.GothamBold,
            TextSize = 12,
            ZIndex = 14,
            Parent = ButtonIcon
        })
        
        local ButtonText = Create("TextLabel")({
            Name = "Text",
            Size = UDim2.new(1, -48, 1, 0),
            Position = UDim2.new(0, 44, 0, 0),
            BackgroundTransparency = 1,
            Text = text,
            TextColor3 = UIColors.Text,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 13,
            Parent = Button
        })
        
        -- Hover and click animations
        Button.MouseEnter:Connect(function()
            TweenService:Create(Button, TweenInfo.new(0.2), {
                BackgroundTransparency = 0, 
                BackgroundColor3 = Color3.fromRGB(35, 35, 50)
            }):Play()
            
            TweenService:Create(ButtonIcon, TweenInfo.new(0.2), {
                BackgroundColor3 = UIColors.Accent,
            }):Play()
        end)
        
        Button.MouseLeave:Connect(function()
            if CurrentTab ~= name then -- Only restore if not the active tab
                TweenService:Create(Button, TweenInfo.new(0.2), {
                    BackgroundTransparency = 0.2,
                    BackgroundColor3 = Color3.fromRGB(25, 25, 35)
                }):Play()
                
                TweenService:Create(ButtonIcon, TweenInfo.new(0.2), {
                    BackgroundColor3 = Color3.fromRGB(40, 40, 60),
                }):Play()
            end
        end)
        
        Button.MouseButton1Down:Connect(function()
            -- Scale down slightly on click
            TweenService:Create(Button, TweenInfo.new(0.1), {
                Size = UDim2.new(0.98, 0, 0, 36),
                Position = UDim2.new(0.01, 0, 0, Button.Position.Y.Offset)
            }):Play()
        end)
        
        Button.MouseButton1Up:Connect(function()
            -- Return to normal size
            TweenService:Create(Button, TweenInfo.new(0.1), {
                Size = UDim2.new(1, 0, 0, 36),
                Position = UDim2.new(0, 0, 0, Button.Position.Y.Offset)
            }):Play()
        end)
        
        -- Store additional elements in the button object
        Button.Indicator = IndicatorBar
        Button.Icon = ButtonIcon
        Button.IconSymbol = IconSymbol
        Button.TextLabel = ButtonText
        
        Buttons[name] = Button
        return Button
    end
    
    -- Create windows (initially hidden)
    local function CreateWindow(name)
        local Window = Create("ScrollingFrame")({
            Name = name .. "Window",
            Size = UDim2.new(1, -20, 1, -20),
            Position = UDim2.new(0, 10, 0, 10),
            BackgroundColor3 = Colors.WindowBackground,
            BorderSizePixel = 0,
            ScrollBarThickness = 4,
            ScrollBarImageColor3 = Colors.AccentDarker,
            CanvasSize = UDim2.new(0, 0, 0, 0),
            Visible = false,
            ZIndex = 12,
            Parent = MainContent
        })
        AddCorner(Window, 8)
        AddPadding(Window, 15)
        
        -- Layout for content
        local ListLayout = Create("UIListLayout")({
            Padding = UDim.new(0, 10),
            SortOrder = Enum.SortOrder.LayoutOrder,
            Parent = Window
        })
        
        -- Automatically update canvas size
        ListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
            Window.CanvasSize = UDim2.new(0, 0, 0, ListLayout.AbsoluteContentSize.Y + 30)
        end)
        
        Windows[name] = Window
        return Window
    end
    
    -- Function to create section in window (exactly matching the UI in screenshot)
    local function CreateSection(window, name, description)
        local Section = Create("Frame")({
            Name = name .. "Section",
            Size = UDim2.new(1, 0, 0, 0), -- Auto size
            BackgroundColor3 = UIColors.Section, -- Match screenshot colors
            BackgroundTransparency = 0, -- No transparency in screenshot
            BorderSizePixel = 0,
            AutomaticSize = Enum.AutomaticSize.Y,
            ZIndex = 13,
            Parent = window
        })
        
        AddCorner(Section, 8)
        AddPadding(Section, 12)
        
        -- Section title and description
        local SectionTitle = Create("TextLabel")({
            Name = "Title",
            Size = UDim2.new(1, -10, 0, 20),
            Position = UDim2.new(0, 10, 0, 5),
            BackgroundTransparency = 1,
            Text = name,
            TextColor3 = UIColors.Text,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.GothamBold,
            TextSize = 15,
            ZIndex = 14,
            Parent = Section
        })
        
        if description then
            local SectionDesc = Create("TextLabel")({
                Name = "Description",
                Size = UDim2.new(1, -20, 0, 20),
                Position = UDim2.new(0, 10, 0, 25),
                BackgroundTransparency = 1,
                Text = description,
                TextColor3 = Colors.TextSecondary,
                TextXAlignment = Enum.TextXAlignment.Left,
                Font = Enum.Font.Gotham,
                TextSize = 14,
                ZIndex = 14,
                Parent = Section
            })
        end
        
        -- Layout for section content
        local ContentLayout = Create("UIListLayout")({
            Padding = UDim.new(0, 10),
            SortOrder = Enum.SortOrder.LayoutOrder,
            Parent = Section
        })
        
        -- Ensure layout properly positions everything
        ContentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
            Section.Size = UDim2.new(1, 0, 0, ContentLayout.AbsoluteContentSize.Y + 20)
        end)
        
        -- Add to sections table
        local sectionInfo = {
            Container = Section,
            Title = SectionTitle,
            Description = description and SectionDesc or nil,
            Elements = {}
        }
        
        Sections[name] = sectionInfo
        return sectionInfo
    end
    
    -- Function to create toggle exactly like the screenshot reference
    local function CreateToggle(section, name, description, default, callback)
        local ToggleContainer = Create("Frame")({
            Name = name .. "Container",
            Size = UDim2.new(1, -20, 0, 35),
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            ZIndex = 14,
            LayoutOrder = #section.Elements + 1,
            Parent = section.Container
        })
        
        local ToggleInfo = Create("Frame")({
            Name = "Info",
            Size = UDim2.new(0.7, 0, 1, 0),
            BackgroundTransparency = 1,
            ZIndex = 15,
            Parent = ToggleContainer
        })
        
        local ToggleLabel = Create("TextLabel")({
            Name = "Label",
            Size = UDim2.new(1, 0, description and 0.6 or 1, 0),
            BackgroundTransparency = 1,
            Text = name,
            TextColor3 = UIColors.Text,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 16,
            Parent = ToggleInfo
        })
        
        if description then
            local ToggleDesc = Create("TextLabel")({
                Name = "Description",
                Size = UDim2.new(1, 0, 0.4, 0),
                Position = UDim2.new(0, 0, 0.6, 0),
                BackgroundTransparency = 1,
                Text = description,
                TextColor3 = UIColors.SubText,
                TextXAlignment = Enum.TextXAlignment.Left,
                Font = Enum.Font.Gotham,
                TextSize = 12,
                ZIndex = 16,
                Parent = ToggleInfo
            })
        end
        
        -- Create toggle indicator (perfectly matching the design in screenshot)
        local ToggleFrame = Create("Frame")({
            Name = "ToggleFrame",
            Size = UDim2.new(0, 48, 0, 24),
            Position = UDim2.new(1, -48, 0.5, -12),
            BackgroundColor3 = default and UIColors.ToggleOn or UIColors.ToggleOff, -- Different colors in ON/OFF state
            BorderSizePixel = 0,
            ZIndex = 15,
            Parent = ToggleContainer
        })
        AddCorner(ToggleFrame, 12) -- Rounded corners for pill shape
        
        local ToggleCircle = Create("Frame")({
            Name = "ToggleCircle",
            Size = UDim2.new(0, 18, 0, 18),
            Position = UDim2.new(default and 1 or 0, default and -21 or 3, 0.5, -9),
            BackgroundColor3 = Color3.fromRGB(240, 240, 250),
            BorderSizePixel = 0,
            ZIndex = 16,
            Parent = ToggleFrame
        })
        AddCorner(ToggleCircle, 9) -- Perfect circle
        
        -- Make toggle interactive with smooth animation
        local enabled = default or false
        
        local function UpdateToggle()
            enabled = not enabled
            
            local newPosition = enabled and UDim2.new(1, -21, 0.5, -9) or UDim2.new(0, 3, 0.5, -9)
            
            -- Animate the toggle with smooth easing (exact match to screenshot)
            TweenService:Create(ToggleCircle, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Position = newPosition
            }):Play()
            
            TweenService:Create(ToggleFrame, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                BackgroundColor3 = enabled and UIColors.ToggleOn or UIColors.ToggleOff
            }):Play()
            
            -- Add slight bounce effect to circle
            local bounceTween = TweenService:Create(ToggleCircle, TweenInfo.new(0.1, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out, 0, false, 0.2), {
                Size = UDim2.new(0, 20, 0, 20),
            })
            
            local returnTween = TweenService:Create(ToggleCircle, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, false, 0.3), {
                Size = UDim2.new(0, 18, 0, 18),
            })
            
            bounceTween:Play()
            bounceTween.Completed:Connect(function()
                returnTween:Play()
            end)
            
            -- Call callback
            callback(enabled)
        end
        
        -- Enable clicking on both the container and toggle
        ToggleContainer.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                UpdateToggle()
            end
        end)
        
        ToggleFrame.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                UpdateToggle()
            end
        end)
        
        -- Add to section's elements
        table.insert(section.Elements, ToggleContainer)
        
        -- Add to toggles table with expanded functionality
        local toggleInfo = {
            Container = ToggleContainer,
            Frame = ToggleFrame,
            Circle = ToggleCircle,
            Enabled = enabled,
            
            -- Function to set toggle state with animation
            SetEnabled = function(state)
                if state ~= enabled then
                    enabled = state
                    
                    local newPosition = enabled and UDim2.new(1, -21, 0.5, -9) or UDim2.new(0, 3, 0.5, -9)
                    
                    -- Animate the toggle with smooth easing
                    TweenService:Create(ToggleCircle, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                        Position = newPosition
                    }):Play()
                    
                    TweenService:Create(ToggleFrame, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                        BackgroundColor3 = enabled and UIColors.ToggleOn or UIColors.ToggleOff
                    }):Play()
                    
                    -- Call callback
                    callback(enabled)
                end
            end,
            
            -- Function to toggle state
            Toggle = function()
                toggleInfo.SetEnabled(not enabled)
            end,
            
            -- Function to get current state
            GetState = function()
                return enabled
            end
        }
        
        Toggles[name] = toggleInfo
        return toggleInfo
    end
    
    -- Function to create dropdown
    local function CreateDropdown(section, name, options, default, callback)
        local DropdownContainer = Create("Frame")({
            Name = name .. "Container",
            Size = UDim2.new(1, -20, 0, 50),
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            ZIndex = 14,
            LayoutOrder = #section.Elements + 1,
            Parent = section.Container
        })
        
        local DropdownLabel = Create("TextLabel")({
            Name = "Label",
            Size = UDim2.new(1, 0, 0, 20),
            BackgroundTransparency = 1,
            Text = name,
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 15,
            Parent = DropdownContainer
        })
        
        local DropdownFrame = Create("TextButton")({
            Name = "DropdownFrame",
            Size = UDim2.new(1, 0, 0, 30),
            Position = UDim2.new(0, 0, 0, 20),
            BackgroundColor3 = Colors.DropdownBackground,
            BorderSizePixel = 0,
            Text = "",
            ZIndex = 15,
            Parent = DropdownContainer
        })
        AddCorner(DropdownFrame, 6)
        
        local SelectedOption = Create("TextLabel")({
            Name = "SelectedOption",
            Size = UDim2.new(1, -30, 1, 0),
            Position = UDim2.new(0, 10, 0, 0),
            BackgroundTransparency = 1,
            Text = default or options[1],
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.Gotham,
            TextSize = 14,
            ZIndex = 16,
            Parent = DropdownFrame
        })
        
        local DropdownArrow = Create("TextLabel")({
            Name = "Arrow",
            Size = UDim2.new(0, 20, 1, 0),
            Position = UDim2.new(1, -20, 0, 0),
            BackgroundTransparency = 1,
            Text = "▼",
            TextColor3 = Colors.TextPrimary,
            Font = Enum.Font.Gotham,
            TextSize = 14,
            ZIndex = 16,
            Parent = DropdownFrame
        })
        
        -- Create dropdown list (initially hidden)
        local DropdownList = Create("Frame")({
            Name = "DropdownList",
            Size = UDim2.new(1, 0, 0, #options * 30),
            Position = UDim2.new(0, 0, 1, 5),
            BackgroundColor3 = Colors.DropdownBackground,
            BorderSizePixel = 0,
            Visible = false,
            ZIndex = 20,
            Parent = DropdownFrame
        })
        AddCorner(DropdownList, 6)
        
        -- Add options to dropdown list
        for i, option in ipairs(options) do
            local OptionButton = Create("TextButton")({
                Name = "Option_" .. option,
                Size = UDim2.new(1, 0, 0, 30),
                Position = UDim2.new(0, 0, 0, (i-1) * 30),
                BackgroundColor3 = Colors.DropdownBackground,
                BackgroundTransparency = 0.3,
                BorderSizePixel = 0,
                Text = "",
                ZIndex = 21,
                Parent = DropdownList
            })
            
            local OptionText = Create("TextLabel")({
                Name = "Text",
                Size = UDim2.new(1, -20, 1, 0),
                Position = UDim2.new(0, 10, 0, 0),
                BackgroundTransparency = 1,
                Text = option,
                TextColor3 = Colors.TextPrimary,
                TextXAlignment = Enum.TextXAlignment.Left,
                Font = Enum.Font.Gotham,
                TextSize = 14,
                ZIndex = 22,
                Parent = OptionButton
            })
            
            -- Option selection logic
            OptionButton.MouseButton1Click:Connect(function()
                SelectedOption.Text = option
                DropdownList.Visible = false
                callback(option)
            end)
            
            -- Hover effect
            OptionButton.MouseEnter:Connect(function()
                OptionButton.BackgroundTransparency = 0.1
            end)
            
            OptionButton.MouseLeave:Connect(function()
                OptionButton.BackgroundTransparency = 0.3
            end)
        end
        
        -- Toggle dropdown list visibility
        DropdownFrame.MouseButton1Click:Connect(function()
            DropdownList.Visible = not DropdownList.Visible
            DropdownArrow.Text = DropdownList.Visible and "▲" or "▼"
        end)
        
        -- Close dropdown when clicking elsewhere
        UserInputService.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                local mousePos = UserInputService:GetMouseLocation()
                local dropdownPos = DropdownFrame.AbsolutePosition
                local dropdownSize = DropdownFrame.AbsoluteSize
                local listPos = DropdownList.AbsolutePosition
                local listSize = DropdownList.AbsoluteSize
                
                if DropdownList.Visible then
                    -- Check if click is outside dropdown and its list
                    if not (mousePos.X >= dropdownPos.X and mousePos.X <= dropdownPos.X + dropdownSize.X and
                            mousePos.Y >= dropdownPos.Y and mousePos.Y <= dropdownPos.Y + dropdownSize.Y) and
                       not (mousePos.X >= listPos.X and mousePos.X <= listPos.X + listSize.X and
                            mousePos.Y >= listPos.Y and mousePos.Y <= listPos.Y + listSize.Y) then
                        DropdownList.Visible = false
                        DropdownArrow.Text = "▼"
                    end
                end
            end
        end)
        
        -- Add to section's elements
        table.insert(section.Elements, DropdownContainer)
        
        -- Add to dropdowns table
        local dropdownInfo = {
            Container = DropdownContainer,
            Frame = DropdownFrame,
            Selected = SelectedOption,
            List = DropdownList,
            SetOption = function(option)
                if table.find(options, option) then
                    SelectedOption.Text = option
                    callback(option)
                end
            end
        }
        
        Dropdowns[name] = dropdownInfo
        return dropdownInfo
    end
    
    -- Function to create slider
    local function CreateSlider(section, name, min, max, default, suffix, callback)
        local SliderContainer = Create("Frame")({
            Name = name .. "Container",
            Size = UDim2.new(1, -20, 0, 50),
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            ZIndex = 14,
            LayoutOrder = #section.Elements + 1,
            Parent = section.Container
        })
        
        local SliderInfo = Create("Frame")({
            Name = "SliderInfo",
            Size = UDim2.new(1, 0, 0, 20),
            BackgroundTransparency = 1,
            ZIndex = 15,
            Parent = SliderContainer
        })
        
        local SliderLabel = Create("TextLabel")({
            Name = "Label",
            Size = UDim2.new(0.7, 0, 1, 0),
            BackgroundTransparency = 1,
            Text = name,
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 16,
            Parent = SliderInfo
        })
        
        local SliderValue = Create("TextLabel")({
            Name = "Value",
            Size = UDim2.new(0.3, 0, 1, 0),
            Position = UDim2.new(0.7, 0, 0, 0),
            BackgroundTransparency = 1,
            Text = default .. (suffix or ""),
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Right,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 16,
            Parent = SliderInfo
        })
        
        -- Create slider elements
        local SliderBackground = Create("Frame")({
            Name = "Background",
            Size = UDim2.new(1, 0, 0, 6),
            Position = UDim2.new(0, 0, 0, 30),
            BackgroundColor3 = Colors.SliderBackground,
            BorderSizePixel = 0,
            ZIndex = 15,
            Parent = SliderContainer
        })
        AddCorner(SliderBackground, 3)
        
        local fillRatio = (default - min) / (max - min)
        local SliderFill = Create("Frame")({
            Name = "Fill",
            Size = UDim2.new(fillRatio, 0, 1, 0),
            BackgroundColor3 = Colors.SliderFill,
            BorderSizePixel = 0,
            ZIndex = 16,
            Parent = SliderBackground
        })
        AddCorner(SliderFill, 3)
        
        local SliderButton = Create("Frame")({
            Name = "Button",
            Size = UDim2.new(0, 14, 0, 14),
            Position = UDim2.new(fillRatio, -7, 0.5, -7),
            BackgroundColor3 = Color3.fromRGB(255, 255, 255),
            BorderSizePixel = 0,
            ZIndex = 17,
            Parent = SliderBackground
        })
        AddCorner(SliderButton, 7)
        
        -- Slider functionality
        local dragging = false
        local value = default
        
        local function UpdateSlider(input)
            local mousePos = input.Position.X
            local sliderPos = SliderBackground.AbsolutePosition.X
            local sliderSize = SliderBackground.AbsoluteSize.X
            
            local relativePos = math.clamp(mousePos - sliderPos, 0, sliderSize)
            local relativeValue = min + (max - min) * (relativePos / sliderSize)
            
            -- Round to 1 decimal place
            value = math.floor(relativeValue * 10) / 10
            value = math.clamp(value, min, max)
            
            -- Update UI
            SliderValue.Text = value .. (suffix or "")
            local newRatio = (value - min) / (max - min)
            SliderFill.Size = UDim2.new(newRatio, 0, 1, 0)
            SliderButton.Position = UDim2.new(newRatio, -7, 0.5, -7)
            
            callback(value)
        end
        
        SliderButton.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
            end
        end)
        
        SliderBackground.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                UpdateSlider(input)
            end
        end)
        
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                UpdateSlider(input)
            end
        end)
        
        UserInputService.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = false
            end
        end)
        
        -- Add to section's elements
        table.insert(section.Elements, SliderContainer)
        
        -- Add to sliders table
        local sliderInfo = {
            Container = SliderContainer,
            Background = SliderBackground,
            Fill = SliderFill,
            Button = SliderButton,
            Value = value,
            SetValue = function(newValue)
                value = math.clamp(newValue, min, max)
                SliderValue.Text = value .. (suffix or "")
                local newRatio = (value - min) / (max - min)
                SliderFill.Size = UDim2.new(newRatio, 0, 1, 0)
                SliderButton.Position = UDim2.new(newRatio, -7, 0.5, -7)
                callback(value)
            end
        }
        
        Sliders[name] = sliderInfo
        return sliderInfo
    end
    
    -- Function to create counter display
    local function CreateCounter(section, name, value)
        local CounterContainer = Create("Frame")({
            Name = name .. "Container",
            Size = UDim2.new(1, -20, 0, 30),
            BackgroundTransparency = 1,
            BorderSizePixel = 0,
            ZIndex = 14,
            LayoutOrder = #section.Elements + 1,
            Parent = section.Container
        })
        
        local CounterLabel = Create("TextLabel")({
            Name = "Label",
            Size = UDim2.new(0.7, 0, 1, 0),
            BackgroundTransparency = 1,
            Text = name,
            TextColor3 = Colors.TextPrimary,
            TextXAlignment = Enum.TextXAlignment.Left,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 15,
            Parent = CounterContainer
        })
        
        local CounterValue = Create("TextLabel")({
            Name = "Value",
            Size = UDim2.new(0.3, 0, 1, 0),
            Position = UDim2.new(0.7, 0, 0, 0),
            BackgroundTransparency = 1,
            Text = value or "0",
            TextColor3 = Colors.Accent,
            TextXAlignment = Enum.TextXAlignment.Right,
            Font = Enum.Font.GothamSemibold,
            TextSize = 14,
            ZIndex = 15,
            Parent = CounterContainer
        })
        
        -- Add to section's elements
        table.insert(section.Elements, CounterContainer)
        
        return {
            Container = CounterContainer,
            Label = CounterLabel,
            Counter = CounterValue,
            SetValue = function(newValue)
                CounterValue.Text = newValue
            end
        }
    end
    
    -- Function to switch between tabs
    local CurrentTab = nil  -- Current active tab
    
    local function SelectTab(tabName)
        if CurrentTab == tabName then return end
        
        -- Hide all windows first
        for name, window in pairs(Windows) do
            window.Visible = false
        end
        
        -- Reset all button states
        for name, button in pairs(Buttons) do
            button.Indicator.Visible = false
            TweenService:Create(button, TweenInfo.new(0.2), {
                BackgroundTransparency = 0.2,
                BackgroundColor3 = Color3.fromRGB(25, 25, 35)
            }):Play()
            
            TweenService:Create(button.Icon, TweenInfo.new(0.2), {
                BackgroundColor3 = Color3.fromRGB(40, 40, 60)
            }):Play()
        end
        
        -- Show the selected window
        if Windows[tabName] then
            Windows[tabName].Visible = true
            
            -- Update button state
            if Buttons[tabName] then
                local button = Buttons[tabName]
                button.Indicator.Visible = true
                
                -- Animate button selection with tweens for smooth transition
                TweenService:Create(button, TweenInfo.new(0.3), {
                    BackgroundTransparency = 0,
                    BackgroundColor3 = Color3.fromRGB(35, 35, 50)
                }):Play()
                
                TweenService:Create(button.Icon, TweenInfo.new(0.3), {
                    BackgroundColor3 = UIColors.Accent
                }):Play()
                
                -- Slight bounce animation
                local bounceTween = TweenService:Create(button, TweenInfo.new(0.15, Enum.EasingStyle.Bounce), {
                    Size = UDim2.new(1.02, 0, 0, 36),
                    Position = UDim2.new(-0.01, 0, 0, button.Position.Y.Offset)
                })
                
                local returnTween = TweenService:Create(button, TweenInfo.new(0.1), {
                    Size = UDim2.new(1, 0, 0, 36),
                    Position = UDim2.new(0, 0, 0, button.Position.Y.Offset)
                })
                
                bounceTween:Play()
                bounceTween.Completed:Connect(function()
                    returnTween:Play()
                end)
            end
        end
        
        -- Update current tab
        CurrentTab = tabName
    end
    
    -- CREATE SIDEBAR BUTTONS WITH ICONS --
    local BlatantButton = CreateSidebarButton("Blatant", "Combat", "⚔️", 1)
    local VisualsButton = CreateSidebarButton("Visuals", "Visuals", "👁️", 2)
    local MiscButton = CreateSidebarButton("Misc", "Utility", "🔧", 3)
    local SettingsButton = CreateSidebarButton("Settings", "Settings", "⚙️", 4)
    
    -- Connect sidebar buttons
    BlatantButton.MouseButton1Click:Connect(function() SelectTab("Blatant") end)
    VisualsButton.MouseButton1Click:Connect(function() SelectTab("Visuals") end)
    MiscButton.MouseButton1Click:Connect(function() SelectTab("Misc") end)
    SettingsButton.MouseButton1Click:Connect(function() SelectTab("Settings") end)
    
    -- CREATE WINDOWS --
    local BlatantWindow = CreateWindow("Blatant")
    local VisualsWindow = CreateWindow("Visuals")
    local MiscWindow = CreateWindow("Misc")
    local SettingsWindow = CreateWindow("Settings")
    
    -- Select default tab
    SelectTab("Blatant")
    
    -- CREATE BLATANT TAB SECTIONS --
    local AutoParrySection = CreateSection(BlatantWindow, "Auto Parry", "Automatically parries ball")
    local AutoSpamSection = CreateSection(BlatantWindow, "Auto Spam Parry", "Automatically spam parries ball")
    local ManualSpamSection = CreateSection(BlatantWindow, "Manual Spam Parry", "Manually spam's parry")
    local TriggerBotSection = CreateSection(BlatantWindow, "Triggerbot", "Instantly hits ball when targeted")
    
    -- CREATE VISUALS TAB SECTIONS --
    local VisualizationSection = CreateSection(VisualsWindow, "Visualization", "Visual elements for parry feedback")
    local UICustomizationSection = CreateSection(VisualsWindow, "UI Customization", "Customize UI appearance")
    
    -- CREATE MISC TAB SECTIONS --
    local UtilitySection = CreateSection(MiscWindow, "Utility", "Additional useful features")
    local KeybindSection = CreateSection(MiscWindow, "Keybinds", "Keyboard shortcuts")
    
    -- CREATE SETTINGS TAB SECTIONS --
    local GeneralSettingsSection = CreateSection(SettingsWindow, "General Settings", "Basic configuration")
    local PerformanceSection = CreateSection(SettingsWindow, "Performance", "Optimize performance")
    
    -- CREATE AUTO PARRY CONTENT --
    -- Parry counter
    local ParryCounter = CreateCounter(AutoParrySection, "Parries", "0")
    
    -- Auto Parry toggle
    local APToggle = CreateToggle(AutoParrySection, "Auto Parry", "Automatically parries ball", false, function(state)
        IsAutoParryEnabled = state
    end)
    
    -- Parry Type dropdown
    local ParryTypeDropdown = CreateDropdown(AutoParrySection, "Parry Type", 
        {"Dot", "Custom", "Backwards", "Random", "Straight", "Up", "Right", "Left", "Adaptive", "Smart"}, 
        ParryType, function(option)
            ParryType = option
            UpdateParryData(option)
            
            -- Update status display
            if StatusDisplay then
                StatusDisplay.ParryModeValue.Text = option
            end
        end)
    
    -- Parry Accuracy slider
    local ParryAccuracySlider = CreateSlider(AutoParrySection, "Parry Accuracy", 0, 100, ParryAccuracy, "%", function(value)
        ParryAccuracy = value
    end)
    
    -- Parry Radius slider
    local ParryRadiusSlider = CreateSlider(AutoParrySection, "Parry Threshold", 5, 60, ParryRadius, "", function(value)
        ParryRadius = value
        
        -- Update status display
        if StatusDisplay then
            StatusDisplay.RadiusValue.Text = tostring(value)
        end
    end)
    
    -- Prediction Time slider
    local PredictionTimeSlider = CreateSlider(AutoParrySection, "Prediction Time", 0.05, 0.3, PredictionTime, "s", function(value)
        PredictionTime = value
    end)
    
    -- Additional toggles
    local RandomAccuracyToggle = CreateToggle(AutoParrySection, "Randomized Parry Accuracy", "Adds some randomness to parries", false, function(state)
        RandomizedParryAccuracy = state
    end)
    
    local InfinityDetectionToggle = CreateToggle(AutoParrySection, "Infinity Detection", "Detects infinity ability balls", false, function(state)
        InfinityDetection = state
    end)
    
    local DeathDetectionToggle = CreateToggle(AutoParrySection, "Death Slash Detection", "Detects death slash balls", false, function(state)
        DeathSlashDetection = state
    end)
    
    local TimeHoleToggle = CreateToggle(AutoParrySection, "Time Hole Detection", "Detects time hole balls", false, function(state)
        TimeHoleDetection = state
    end)
    
    local SlashOfFuryToggle = CreateToggle(AutoParrySection, "Slash Of Fury Detection", "Detects fury balls", false, function(state)
        SlashOfFuryDetection = state
    end)
    
    local AntiPhantomToggle = CreateToggle(AutoParrySection, "Anti Phantom", "Prevents phantom hits", false, function(state)
        AntiPhantom = state
    end)
    
    local CooldownProtectionToggle = CreateToggle(AutoParrySection, "Cooldown Protection", "Prevents double parries", false, function(state)
        CooldownProtection = state
    end)
    
    local AutoAbilityToggle = CreateToggle(AutoParrySection, "Auto Ability", "Automatically uses ability", false, function(state)
        AutoAbility = state
    end)
    
    -- CREATE AUTO SPAM CONTENT --
    local AutoSpamToggle = CreateToggle(AutoSpamSection, "Auto Spam Parry", "Automatically spam parries ball", false, function(state)
        FeatureSettings.AutoSpamEnabled = state
    end)
    
    local AutoSpamRateSlider = CreateSlider(AutoSpamSection, "Spam Rate", 0.05, 0.5, FeatureSettings.AutoSpamRate, "s", function(value)
        FeatureSettings.AutoSpamRate = value
    end)
    
    local AutoSpamModeDropdown = CreateDropdown(AutoSpamSection, "Spam Mode", 
        {"Constant", "Pattern", "Random"}, 
        FeatureSettings.AutoSpamMode, function(option)
            FeatureSettings.AutoSpamMode = option
        end)
    
    local AnimationFixToggle = CreateToggle(AutoSpamSection, "Animation Fix (DON'T USE IF MOBILE)", "Fixes animation issues", false, function(state)
        FeatureSettings.AnimationFix = state
    end)
    
    -- CREATE MANUAL SPAM CONTENT --
    local ManualSpamToggle = CreateToggle(ManualSpamSection, "Manual Spam Parry", "Manually spam's parry with right-click", false, function(state)
        FeatureSettings.ManualSpamEnabled = state
    end)
    
    local ManualSpamRateSlider = CreateSlider(ManualSpamSection, "Spam Rate", 0.05, 0.5, FeatureSettings.ManualSpamRate, "s", function(value)
        FeatureSettings.ManualSpamRate = value
    end)
    
    -- CREATE TRIGGERBOT CONTENT --
    local TriggerBotToggle = CreateToggle(TriggerBotSection, "Triggerbot", "Instantly hits ball when targeted", false, function(state)
        FeatureSettings.TriggerBotEnabled = state
    end)
    
    local TriggerBotDelaySlider = CreateSlider(TriggerBotSection, "Trigger Delay", 0, 0.2, FeatureSettings.TriggerBotDelay, "s", function(value)
        FeatureSettings.TriggerBotDelay = value
    end)
    
    -- CREATE VISUALIZATION CONTENT --
    local NotifyToggle = CreateToggle(VisualizationSection, "Notify", "Shows notification on parry", false, function(state)
        FeatureSettings.NotifyEnabled = state
    end)
    
    local NotifySoundToggle = CreateToggle(VisualizationSection, "Notify Sound", "Plays sound on parry", false, function(state)
        FeatureSettings.NotifySound = state
    end)
    
    local ShowParryRadiusToggle = CreateToggle(VisualizationSection, "Show Parry Radius", "Visualizes parry radius sphere", false, function(state)
        FeatureSettings.ShowParryRadius = state
    end)
    
    local ShowPredictionPathToggle = CreateToggle(VisualizationSection, "Show Prediction Path", "Visualizes ball path prediction", false, function(state)
        FeatureSettings.ShowPredictionPath = state
    end)
    
    -- CREATE UI CUSTOMIZATION CONTENT --
    local ThemeDropdown = CreateDropdown(UICustomizationSection, "Theme", 
        {"Dark", "Light", "Purple", "Blue", "Green", "Red"}, 
        "Dark", function(option)
            -- Theme switching logic would go here
        end)
    
    local UIScaleSlider = CreateSlider(UICustomizationSection, "UI Scale", 0.5, 1.5, CONFIG.UIScale, "x", function(value)
        CONFIG.UIScale = value
        
        -- Scale logic would go here
    end)
    
    -- CREATE UTILITY CONTENT --
    local KeypressToggle = CreateToggle(UtilitySection, "Keypress", "Simulates keypress on parry", false, function(state)
        FeatureSettings.KeypressEmulation = state
    end)
    
    local CustomCursorToggle = CreateToggle(UtilitySection, "Custom Cursor", "Enables custom cursor", false, function(state)
        FeatureSettings.CustomCursorEnabled = state
    end)
    
    local StatsToggle = CreateToggle(UtilitySection, "Show Stats", "Displays statistics", false, function(state)
        FeatureSettings.ShowStatsInGame = state
        StatsDisplay.Visible = state
    end)
    
    -- CREATE KEYBIND CONTENT --
    local ToggleKeybindDropdown = CreateDropdown(KeybindSection, "Toggle Auto Parry", 
        {"M", "N", "P", "O", "L", "K", "B"}, 
        "M", function(option)
            FeatureSettings.ToggleKeybind = Enum.KeyCode[option]
        end)
    
    local ModeKeybindDropdown = CreateDropdown(KeybindSection, "Cycle Parry Mode", 
        {"N", "M", "P", "O", "L", "K", "B"}, 
        "N", function(option)
            FeatureSettings.ModeKeybind = Enum.KeyCode[option]
        end)
    
    -- CREATE SETTINGS CONTENT --
    local DebugModeToggle = CreateToggle(GeneralSettingsSection, "Debug Mode", "Enables debug output", false, function(state)
        _G.FemBladeDebug = state
    end)
    
    local AntiCheatBypassToggle = CreateToggle(GeneralSettingsSection, "Anti-Cheat Bypass", "Attempts to bypass anti-cheat", true, function(state)
        _G.FemBladeSecurity.AntiCheatBypass = state
    end)
    
    -- CREATE PERFORMANCE CONTENT --
    local OptimizePerformanceToggle = CreateToggle(PerformanceSection, "Optimize Performance", "Reduces resource usage", true, function(state)
        CONFIG.OptimizePerformance = state
    end)
    
    local ReduceAnimationsToggle = CreateToggle(PerformanceSection, "Reduce Animations", "Disables some UI animations", false, function(state)
        CONFIG.ReduceAnimations = state
    end)
    
    -- SETUP BUTTON ACTIONS --
    BlatantButton.MouseButton1Click:Connect(function()
        -- Hide all windows
        for _, window in pairs(Windows) do
            window.Visible = false
        end
        
        -- Show selected window
        BlatantWindow.Visible = true
        ActiveWindow = "Blatant"
    end)
    
    VisualsButton.MouseButton1Click:Connect(function()
        -- Hide all windows
        for _, window in pairs(Windows) do
            window.Visible = false
        end
        
        -- Show selected window
        VisualsWindow.Visible = true
        ActiveWindow = "Visuals"
    end)
    
    MiscButton.MouseButton1Click:Connect(function()
        -- Hide all windows
        for _, window in pairs(Windows) do
            window.Visible = false
        end
        
        -- Show selected window
        MiscWindow.Visible = true
        ActiveWindow = "Misc"
    end)
    
    SettingsButton.MouseButton1Click:Connect(function()
        -- Hide all windows
        for _, window in pairs(Windows) do
            window.Visible = false
        end
        
        -- Show selected window
        SettingsWindow.Visible = true
        ActiveWindow = "Settings"
    end)
    
    -- Show Blatant window by default
    BlatantWindow.Visible = true
    ActiveWindow = "Blatant"
    
    -- Setup stats update loop
    spawn(function()
        while wait(1) do
            if ParryCounter then
                ParryCounter.SetValue(SessionStats.SuccessfulParries)
            end
            
            if StatsDisplay and StatsDisplay.Visible then
                local parryValue = StatsDisplay:FindFirstChild("ParriesValue")
                if parryValue then
                    parryValue.Text = tostring(SessionStats.SuccessfulParries)
                end
                
                local reactionValue = StatsDisplay:FindFirstChild("ReactionValue")
                if reactionValue then
                    reactionValue.Text = string.format("%.2f ms", SessionStats.AverageReactionTime * 1000)
                end
                
                local uptimeValue = StatsDisplay:FindFirstChild("UptimeValue")
                if uptimeValue then
                    uptimeValue.Text = FormatTime(math.floor(SessionStats.Uptime))
                end
            end
        end
    end)
    
    -- Add UI update methods
    local UI = {
        UpdateToggleState = function(name, state)
            if Toggles[name] then
                Toggles[name].SetEnabled(state)
            end
        end,
        
        UpdateDropdownValue = function(name, value)
            if Dropdowns[name] then
                Dropdowns[name].SetOption(value)
            end
        end,
        
        UpdateSliderValue = function(name, value)
            if Sliders[name] then
                Sliders[name].SetValue(value)
            end
        end,
        
        UpdateCounter = function(name, value)
            if name == "Parries" and ParryCounter then
                ParryCounter.SetValue(value)
            end
        end
    }
    
    -- Return the created UI
    FemBladeUI = ScreenGui
    return UI
end

-- Create the UI
local UI = CreateMainUI()

--// ADVANCED EVENT LOGGING SYSTEM //--
-- This module allows detailed tracking of all parry events in the game
local EventLogger = {}
EventLogger.Events = {}
EventLogger.MaxEvents = 100
EventLogger.Initialized = false
EventLogger.DiagnosticsEnabled = true
EventLogger.FileLoggingEnabled = false
EventLogger.LogFilePath = "FemBlade_Logs_" .. os.time() .. ".txt"

function EventLogger:Initialize()
    if self.Initialized then return end
    
    -- Setup the event logging structure
    self.EventTypes = {
        INFO = {Color = Color3.fromRGB(130, 220, 255), Prefix = "[INFO]"},
        SUCCESS = {Color = Color3.fromRGB(100, 255, 100), Prefix = "[SUCCESS]"},
        WARNING = {Color = Color3.fromRGB(255, 225, 75), Prefix = "[WARNING]"},
        ERROR = {Color = Color3.fromRGB(255, 100, 100), Prefix = "[ERROR]"},
        DEBUG = {Color = Color3.fromRGB(180, 180, 180), Prefix = "[DEBUG]"}
    }
    
    self.Initialized = true
    self:Log("Event logger initialized successfully", "INFO")
end

function EventLogger:Log(message, eventType, data)
    if not self.Initialized then self:Initialize() end
    
    eventType = eventType or "INFO"
    if not self.EventTypes[eventType] then eventType = "INFO" end
    
    local event = {
        Type = eventType,
        Message = message,
        Data = data or {},
        Timestamp = os.time(),
        FormattedTime = os.date("%H:%M:%S", os.time())
    }
    
    -- Add to circular buffer of events
    table.insert(self.Events, 1, event)
    if #self.Events > self.MaxEvents then
        table.remove(self.Events, #self.Events)
    end
    
    -- Print to console if diagnostics are enabled
    if self.DiagnosticsEnabled and _G.FemBladeDebug then
        local prefix = self.EventTypes[eventType].Prefix
        print(prefix .. " [" .. event.FormattedTime .. "] " .. message)
        
        if data and _G.FemBladeDebug then
            if type(data) == "table" then
                for k, v in pairs(data) do
                    print("  " .. tostring(k) .. ": " .. tostring(v))
                end
            else
                print("  Data: " .. tostring(data))
            end
        end
    end
    
    -- Write to file if enabled
    if self.FileLoggingEnabled then
        -- In a real environment, this would write to a file
        -- We'll simulate it with a print
        print("FILELOG: " .. self.EventTypes[eventType].Prefix .. " [" .. event.FormattedTime .. "] " .. message)
    end
    
    return event
end

function EventLogger:GetRecentEvents(count, filterType)
    count = count or 10
    local filteredEvents = {}
    
    for _, event in ipairs(self.Events) do
        if not filterType or event.Type == filterType then
            table.insert(filteredEvents, event)
            if #filteredEvents >= count then
                break
            end
        end
    end
    
    return filteredEvents
end

function EventLogger:ClearEvents()
    self.Events = {}
    self:Log("Event log cleared", "INFO")
end

function EventLogger:GenerateReport()
    local report = "=== FemBlade Event Report ===\n"
    report = report .. "Time: " .. os.date("%Y-%m-%d %H:%M:%S") .. "\n"
    report = report .. "Total Events: " .. #self.Events .. "\n\n"
    
    -- Count by type
    local typeCounts = {}
    for _, event in ipairs(self.Events) do
        typeCounts[event.Type] = (typeCounts[event.Type] or 0) + 1
    end
    
    report = report .. "Event Type Distribution:\n"
    for eventType, count in pairs(typeCounts) do
        report = report .. "- " .. eventType .. ": " .. count .. "\n"
    end
    
    report = report .. "\nRecent Events:\n"
    for i = 1, math.min(10, #self.Events) do
        local event = self.Events[i]
        report = report .. event.FormattedTime .. " " .. self.EventTypes[event.Type].Prefix .. " " .. event.Message .. "\n"
    end
    
    return report
end

-- Initialize the logger
EventLogger:Initialize()

--// ADVANCED PERFORMANCE MONITORING //--
-- This module helps track script performance and optimize resource usage
local PerformanceMonitor = {}
PerformanceMonitor.Timers = {}
PerformanceMonitor.Counters = {}
PerformanceMonitor.MemorySnapshots = {}
PerformanceMonitor.MaxSnapshots = 20
PerformanceMonitor.MonitoringEnabled = _G.FemBladeDebug or false
PerformanceMonitor.AutoReport = false
PerformanceMonitor.ReportInterval = 60 -- seconds

function PerformanceMonitor:StartTimer(name)
    if not self.MonitoringEnabled then return end
    self.Timers[name] = {
        StartTime = tick(),
        EndTime = nil,
        Duration = nil,
        Calls = (self.Timers[name] and self.Timers[name].Calls or 0) + 1
    }
    return self.Timers[name].StartTime
end

function PerformanceMonitor:StopTimer(name)
    if not self.MonitoringEnabled or not self.Timers[name] then return end
    
    local timer = self.Timers[name]
    timer.EndTime = tick()
    timer.Duration = timer.EndTime - timer.StartTime
    
    if not timer.MinDuration or timer.Duration < timer.MinDuration then
        timer.MinDuration = timer.Duration
    end
    
    if not timer.MaxDuration or timer.Duration > timer.MaxDuration then
        timer.MaxDuration = timer.Duration
    end
    
    if not timer.TotalDuration then timer.TotalDuration = 0 end
    timer.TotalDuration = timer.TotalDuration + timer.Duration
    timer.AverageDuration = timer.TotalDuration / timer.Calls
    
    return timer.Duration
end

function PerformanceMonitor:Increment(counterName, amount)
    amount = amount or 1
    if not self.Counters[counterName] then
        self.Counters[counterName] = {
            Value = 0,
            LastIncrement = tick(),
            Increments = 0
        }
    end
    
    local counter = self.Counters[counterName]
    counter.Value = counter.Value + amount
    counter.LastIncrement = tick()
    counter.Increments = counter.Increments + 1
    
    return counter.Value
end

function PerformanceMonitor:GetCounter(counterName)
    return self.Counters[counterName] and self.Counters[counterName].Value or 0
end

function PerformanceMonitor:ResetCounter(counterName)
    if self.Counters[counterName] then
        local oldValue = self.Counters[counterName].Value
        self.Counters[counterName].Value = 0
        return oldValue
    end
    return 0
end

function PerformanceMonitor:TakeMemorySnapshot(label)
    if not self.MonitoringEnabled then return end
    
    local snapshot = {
        Label = label or "Snapshot_" .. #self.MemorySnapshots + 1,
        Timestamp = tick(),
        FormattedTime = os.date("%H:%M:%S"),
        -- In a real environment, we would get actual memory stats
        -- Here we'll simulate it 
        Memory = math.random(5000, 10000) -- simulated KB usage
    }
    
    table.insert(self.MemorySnapshots, snapshot)
    if #self.MemorySnapshots > self.MaxSnapshots then
        table.remove(self.MemorySnapshots, 1)
    end
    
    return snapshot
end

function PerformanceMonitor:GenerateReport()
    local report = "=== FemBlade Performance Report ===\n"
    report = report .. "Time: " .. os.date("%Y-%m-%d %H:%M:%S") .. "\n\n"
    
    report = report .. "Timers:\n"
    for name, timer in pairs(self.Timers) do
        report = report .. "- " .. name .. ":\n"
        report = report .. "  Calls: " .. timer.Calls .. "\n"
        if timer.AverageDuration then
            report = report .. "  Avg Duration: " .. string.format("%.6f", timer.AverageDuration) .. "s\n"
            report = report .. "  Min Duration: " .. string.format("%.6f", timer.MinDuration) .. "s\n"
            report = report .. "  Max Duration: " .. string.format("%.6f", timer.MaxDuration) .. "s\n"
        end
    end
    
    report = report .. "\nCounters:\n"
    for name, counter in pairs(self.Counters) do
        report = report .. "- " .. name .. ": " .. counter.Value .. " (" .. counter.Increments .. " increments)\n"
    end
    
    report = report .. "\nMemory Usage:\n"
    if #self.MemorySnapshots > 0 then
        local latestSnapshot = self.MemorySnapshots[#self.MemorySnapshots]
        report = report .. "- Current: " .. latestSnapshot.Memory .. " KB\n"
        
        if #self.MemorySnapshots > 1 then
            local firstSnapshot = self.MemorySnapshots[1]
            local memoryDiff = latestSnapshot.Memory - firstSnapshot.Memory
            report = report .. "- Change: " .. (memoryDiff >= 0 and "+" or "") .. memoryDiff .. " KB\n"
        end
    else
        report = report .. "- No memory snapshots available\n"
    end
    
    return report
end

-- Enable auto-reporting if configured
if PerformanceMonitor.AutoReport and PerformanceMonitor.MonitoringEnabled then
    spawn(function()
        while true do
            wait(PerformanceMonitor.ReportInterval)
            print(PerformanceMonitor:GenerateReport())
        end
    end)
end

-- Take initial memory snapshot
PerformanceMonitor:TakeMemorySnapshot("Initialization")

--// REMOTE SPOOFER //--
-- Add this if implementing anti-cheat bypass
if CONFIG.AntiCheatBypass then
    local oldNamecall
    oldNamecall = hookmetamethod(game, "__namecall", function(self, ...)
        local method = getnamecallmethod()
        local args = {...}
        
        if method == "FireServer" and self.Name:match("Detection") then
            EventLogger:Log("Anti-cheat detection blocked: " .. self.Name, "WARNING")
            return nil -- Block anti-cheat detections
        end
        
        -- Monitor and log certain remote calls for diagnostic purposes
        if _G.FemBladeDebug and method == "FireServer" and (
            self.Name:match("Parry") or 
            self.Name:match("Block") or 
            self.Name:match("Attack")
        ) then
            local argStr = ""
            for i, arg in ipairs(args) do
                argStr = argStr .. " [" .. typeof(arg) .. "]"
            end
            EventLogger:Log("Remote call monitored: " .. self.Name .. argStr, "DEBUG")
        end
        
        return oldNamecall(self, ...)
    end)
    
    EventLogger:Log("Anti-cheat bypass initialized", "SUCCESS")
end

--// DIAGNOSTIC UTILITIES //--
-- Comprehensive set of diagnostic tools for in-game troubleshooting
local DiagnosticsUtil = {}
DiagnosticsUtil.InitialPing = GetPing()
DiagnosticsUtil.StartupDiagnosticsComplete = false
DiagnosticsUtil.ScriptEnvironment = {
    Executor = "Unknown",
    GlobalsAvailable = {},
    MethodsPatched = {},
    SecurityLevel = "Unknown"
}
DiagnosticsUtil.GameEnvironment = {
    GameID = game and game.PlaceId or 0,
    Players = (workspace and Players and type(Players.GetPlayers) == "function") and #Players:GetPlayers() or 0,
    MapLoaded = workspace and workspace:FindFirstChild("Map") ~= nil,
    SynchronizedWithServer = true
}

function DiagnosticsUtil:RunStartupDiagnostics()
    if self.StartupDiagnosticsComplete then return end
    
    -- Take initial performance measurements
    PerformanceMonitor:StartTimer("StartupDiagnostics")
    
    -- Check available globals to determine executor
    local availableGlobals = {"getgc", "getcallingscript", "gethui", "setreadonly", "hookfunction", "islclosure"}
    for _, globalName in ipairs(availableGlobals) do
        self.ScriptEnvironment.GlobalsAvailable[globalName] = type(_G[globalName]) == "function"
    end
    
    -- Determine executor type based on available globals
    if self.ScriptEnvironment.GlobalsAvailable["gethui"] and self.ScriptEnvironment.GlobalsAvailable["getcallingscript"] then
        self.ScriptEnvironment.Executor = "Synapse X or Similar"
        self.ScriptEnvironment.SecurityLevel = "High"
    elseif self.ScriptEnvironment.GlobalsAvailable["getgc"] and self.ScriptEnvironment.GlobalsAvailable["islclosure"] then
        self.ScriptEnvironment.Executor = "Mid-tier Executor"
        self.ScriptEnvironment.SecurityLevel = "Medium"
    else
        self.ScriptEnvironment.Executor = "Basic Executor"
        self.ScriptEnvironment.SecurityLevel = "Low"
    end
    
    -- Check for hook method support
    local hookSuccess = pcall(function()
        local originalFunc = Instance.new("Part").Destroy
        local hookResult = false
        
        -- Try to hook an instance method
        local hookedFunc
        hookedFunc = hookfunction(originalFunc, function(...)
            hookResult = true
            return hookedFunc(...)
        end)
        
        -- Clean up
        hookfunction(originalFunc, originalFunc)
    end)
    
    self.ScriptEnvironment.MethodsPatched["HookSupport"] = hookSuccess
    
    -- Validate game environment
    self.GameEnvironment.SynchronizedWithServer = self:CheckServerSynchronization()
    
    -- Log diagnostics
    EventLogger:Log("Startup diagnostics completed", "INFO", {
        Executor = self.ScriptEnvironment.Executor,
        SecurityLevel = self.ScriptEnvironment.SecurityLevel,
        InitialPing = self.InitialPing
    })
    
    -- Complete timer
    PerformanceMonitor:StopTimer("StartupDiagnostics")
    self.StartupDiagnosticsComplete = true
end

function DiagnosticsUtil:CheckServerSynchronization()
    -- In a real environment, we would check actual synchronization
    -- For this mock, we'll return true
    return true
end

function DiagnosticsUtil:GenerateReport()
    local report = "=== FemBlade Diagnostics Report ===\n"
    report = report .. "Time: " .. os.date("%Y-%m-%d %H:%M:%S") .. "\n\n"
    
    report = report .. "Script Environment:\n"
    report = report .. "- Executor: " .. self.ScriptEnvironment.Executor .. "\n"
    report = report .. "- Security Level: " .. self.ScriptEnvironment.SecurityLevel .. "\n"
    
    report = report .. "\nGame Environment:\n"
    report = report .. "- Game ID: " .. self.GameEnvironment.GameID .. "\n"
    report = report .. "- Players: " .. self.GameEnvironment.Players .. "\n"
    report = report .. "- Map Loaded: " .. tostring(self.GameEnvironment.MapLoaded) .. "\n"
    report = report .. "- Server Synchronized: " .. tostring(self.GameEnvironment.SynchronizedWithServer) .. "\n"
    
    report = report .. "\nNetwork Stats:\n"
    report = report .. "- Initial Ping: " .. string.format("%.2f", self.InitialPing * 1000) .. "ms\n"
    report = report .. "- Current Ping: " .. string.format("%.2f", GetPing() * 1000) .. "ms\n"
    
    return report
end

-- Run startup diagnostics
DiagnosticsUtil:RunStartupDiagnostics()
if _G.FemBladeDebug then
    print(DiagnosticsUtil:GenerateReport())
end

--// INITIALIZATION //--
-- Show welcome notification
StarterGui:SetCore("SendNotification", {
    Title = CONFIG.Name,
    Text = "Script loaded successfully! Auto parry distance set to " .. ParryRadius,
    Duration = 3
})

-- Log initialization
DebugPrint("Initialized in", string.format("%.2f", tick() - StartTime), "seconds")
DebugPrint("Auto parry radius set to", ParryRadius)
DebugPrint("Current player:", PlayerName, "ID:", UserId)
DebugPrint("Version:", CONFIG.Version)

-- Final startup procedures
UpdateParryData(ParryType)
StarterGui:SetCore("ChatMakeSystemMessage", {
    Text = "[" .. CONFIG.Name .. "] Loaded successfully! Press M to toggle auto parry.",
    Color = Color3.fromRGB(140, 70, 240),
    Font = Enum.Font.GothamBold,
    TextSize = 16
})

-- Record successful initialization
EventLogger:Log("FemBlade script initialized successfully", "SUCCESS", {
    Version = CONFIG.Version,
    ParryRadius = ParryRadius,
    StartupTime = string.format("%.2f", tick() - StartTime)
})

--// CHAT COMMAND SYSTEM //--
-- This module implements a comprehensive chat command system for FemBlade
local ChatCommands = {}
ChatCommands.Enabled = CONFIG.EnableChatCommands
ChatCommands.Prefix = CONFIG.CommandPrefix
ChatCommands.Commands = {}
ChatCommands.History = {}
ChatCommands.MaxHistory = 50
ChatCommands.CommandDescriptions = CONFIG.Commands

function ChatCommands:Initialize()
    if not self.Enabled then return end
    
    -- Define commands
    self.Commands = {
        help = function(args)
            local helpText = "=== FemBlade Commands ===\n"
            helpText = helpText .. "Prefix: " .. self.Prefix .. "\n\n"
            
            for cmd, desc in pairs(self.CommandDescriptions) do
                helpText = helpText .. self.Prefix .. cmd .. " - " .. desc .. "\n"
            end
            
            -- Display help in chat
            EventLogger:Log("Help command executed", "INFO")
            StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = helpText,
                Color = CONFIG.AccentColor,
                Font = Enum.Font.GothamSemibold,
                TextSize = 14
            })
            
            return true
        end,
        
        toggle = function(args)
            IsAutoParryEnabled = not IsAutoParryEnabled
            
            local statusText = "Auto Parry: " .. (IsAutoParryEnabled and "Enabled" or "Disabled")
            StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = statusText,
                Color = IsAutoParryEnabled and Color3.fromRGB(100, 255, 100) or Color3.fromRGB(255, 100, 100),
                Font = Enum.Font.GothamSemibold,
                TextSize = 14
            })
            
            EventLogger:Log("Toggle command executed", "INFO", {
                NewState = IsAutoParryEnabled
            })
            
            -- Update UI if available
            if UI and UI.UpdateToggleState then
                UI.UpdateToggleState("AutoParry", IsAutoParryEnabled)
            end
            
            return true
        end,
        
        mode = function(args)
            local newMode = args[1]
            
            -- If no mode specified, cycle through modes
            if not newMode then
                local currentIndex = table.find(CONFIG.ParryModes, ParryType) or 1
                currentIndex = (currentIndex % #CONFIG.ParryModes) + 1
                newMode = CONFIG.ParryModes[currentIndex]
            else
                -- Check if the specified mode exists
                newMode = string.upper(newMode:sub(1, 1)) .. string.lower(newMode:sub(2))
                if not table.find(CONFIG.ParryModes, newMode) then
                    StarterGui:SetCore("ChatMakeSystemMessage", {
                        Text = "Invalid parry mode: " .. newMode,
                        Color = Color3.fromRGB(255, 100, 100),
                        Font = Enum.Font.GothamSemibold,
                        TextSize = 14
                    })
                    return false
                end
            end
            
            -- Set the new mode
            ParryType = newMode
            UpdateParryData(ParryType)
            
            -- Notify the user
            StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "Parry Mode: " .. ParryType,
                Color = CONFIG.AccentColor,
                Font = Enum.Font.GothamSemibold,
                TextSize = 14
            })
            
            EventLogger:Log("Mode command executed", "INFO", {
                NewMode = ParryType
            })
            
            -- Update UI if available
            if UI and UI.UpdateDropdownValue then
                UI.UpdateDropdownValue("ParryType", ParryType)
            end
            
            return true
        end,
        
        radius = function(args)
            local newRadius = tonumber(args[1])
            
            if not newRadius then
                StarterGui:SetCore("ChatMakeSystemMessage", {
                    Text = "Current Parry Radius: " .. ParryRadius,
                    Color = CONFIG.AccentColor,
                    Font = Enum.Font.GothamSemibold,
                    TextSize = 14
                })
                return true
            end
            
            -- Clamp radius to valid range
            newRadius = math.clamp(newRadius, 5, 60)
            ParryRadius = newRadius
            
            -- Notify the user
            StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "Parry Radius set to: " .. ParryRadius,
                Color = CONFIG.AccentColor,
                Font = Enum.Font.GothamSemibold,
                TextSize = 14
            })
            
            EventLogger:Log("Radius command executed", "INFO", {
                NewRadius = ParryRadius
            })
            
            -- Update UI if available
            if UI and UI.UpdateSliderValue then
                UI.UpdateSliderValue("ParryRadius", ParryRadius)
            end
            
            return true
        end,
        
        time = function(args)
            local newTime = tonumber(args[1])
            
            if not newTime then
                StarterGui:SetCore("ChatMakeSystemMessage", {
                    Text = "Current Prediction Time: " .. PredictionTime .. "s",
                    Color = CONFIG.AccentColor,
                    Font = Enum.Font.GothamSemibold,
                    TextSize = 14
                })
                return true
            end
            
            -- Clamp time to valid range
            newTime = math.clamp(newTime, 0.05, 0.3)
            PredictionTime = newTime
            
            -- Notify the user
            StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "Prediction Time set to: " .. PredictionTime .. "s",
                Color = CONFIG.AccentColor,
                Font = Enum.Font.GothamSemibold,
                TextSize = 14
            })
            
            EventLogger:Log("Time command executed", "INFO", {
                NewTime = PredictionTime
            })
            
            -- Update UI if available
            if UI and UI.UpdateSliderValue then
                UI.UpdateSliderValue("PredictionTime", PredictionTime)
            end
            
            return true
        end,
        
        stats = function(args)
            local statsText = "=== FemBlade Stats ===\n"
            statsText = statsText .. "Uptime: " .. FormatTime(math.floor(SessionStats.Uptime)) .. "\n"
            statsText = statsText .. "Total Parries: " .. SessionStats.TotalParries .. "\n"
            statsText = statsText .. "Successful Parries: " .. SessionStats.SuccessfulParries .. "\n"
            statsText = statsText .. "Average Reaction: " .. string.format("%.2f", SessionStats.AverageReactionTime * 1000) .. "ms\n"
            statsText = statsText .. "Ping: " .. string.format("%.2f", GetPing() * 1000) .. "ms\n"
            
            -- Display stats in chat
            StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = statsText,
                Color = CONFIG.AccentColor,
                Font = Enum.Font.GothamSemibold,
                TextSize = 14
            })
            
            EventLogger:Log("Stats command executed", "INFO")
            return true
        end,
        
        reset = function(args)
            -- Reset settings to default
            ParryRadius = CONFIG.ParryDistance
            PredictionTime = CONFIG.PredictionTime
            ParryAccuracy = CONFIG.ParryAccuracy
            ParryType = CONFIG.CurveType
            RandomizedParryAccuracy = false
            InfinityDetection = false
            DeathSlashDetection = false
            TimeHoleDetection = false
            SlashOfFuryDetection = false
            AntiPhantom = false
            CooldownProtection = false
            
            -- Reset toggles if UI exists
            if Toggles then
                for _, toggle in pairs(Toggles) do
                    if toggle.SetEnabled then
                        toggle.SetEnabled(false)
                    end
                end
            end
            
            -- Update UI components if available
            if UI then
                if UI.UpdateToggleState then
                    UI.UpdateToggleState("AutoParry", false)
                end
                
                if UI.UpdateDropdownValue then
                    UI.UpdateDropdownValue("ParryType", ParryType)
                end
                
                if UI.UpdateSliderValue then
                    UI.UpdateSliderValue("ParryRadius", ParryRadius)
                    UI.UpdateSliderValue("PredictionTime", PredictionTime)
                    UI.UpdateSliderValue("ParryAccuracy", ParryAccuracy)
                end
            end
            
            StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "All settings reset to default values",
                Color = CONFIG.AccentColor,
                Font = Enum.Font.GothamSemibold,
                TextSize = 14
            })
            
            EventLogger:Log("Reset command executed", "INFO")
            return true
        end,
        
        debug = function(args)
            -- Toggle debug mode (only available if developer mode is enabled)
            if CONFIG.DeveloperMode then
                _G.FemBladeDebug = not _G.FemBladeDebug
                
                StarterGui:SetCore("ChatMakeSystemMessage", {
                    Text = "Debug Mode: " .. (_G.FemBladeDebug and "Enabled" or "Disabled"),
                    Color = CONFIG.AccentColor,
                    Font = Enum.Font.GothamSemibold,
                    TextSize = 14
                })
                
                EventLogger:Log("Debug command executed", "INFO", {
                    NewState = _G.FemBladeDebug
                })
                
                return true
            else
                return false
            end
        end,
        
        ping = function(args)
            local currentPing = GetPing() * 1000
            
            StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "Current Ping: " .. string.format("%.2f", currentPing) .. "ms",
                Color = CONFIG.AccentColor,
                Font = Enum.Font.GothamSemibold,
                TextSize = 14
            })
            
            EventLogger:Log("Ping command executed", "INFO", {
                Ping = currentPing
            })
            
            return true
        end,
        
        version = function(args)
            StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = CONFIG.Name .. " v" .. CONFIG.Version .. " by " .. CONFIG.Author,
                Color = CONFIG.AccentColor,
                Font = Enum.Font.GothamBold,
                TextSize = 14
            })
            
            EventLogger:Log("Version command executed", "INFO")
            return true
        end,
        
        about = function(args)
            local aboutText = "=== About FemBlade ===\n"
            aboutText = aboutText .. "Version: " .. CONFIG.Version .. "\n"
            aboutText = aboutText .. "Author: " .. CONFIG.Author .. "\n"
            aboutText = aboutText .. "Release Date: " .. CONFIG.ReleaseDate .. "\n"
            aboutText = aboutText .. "Discord: " .. CONFIG.DiscordInvite .. "\n"
            aboutText = aboutText .. "Thank you for using FemBlade!"
            
            StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = aboutText,
                Color = CONFIG.AccentColor,
                Font = Enum.Font.GothamSemibold,
                TextSize = 14
            })
            
            EventLogger:Log("About command executed", "INFO")
            return true
        end,
        
        hide = function(args)
            -- Hide the UI
            if FemBladeUI and FemBladeUI.Enabled ~= false then
                FemBladeUI.Enabled = false
                
                StarterGui:SetCore("ChatMakeSystemMessage", {
                    Text = "FemBlade UI hidden. Type !show to display it again.",
                    Color = CONFIG.AccentColor,
                    Font = Enum.Font.GothamSemibold,
                    TextSize = 14
                })
                
                EventLogger:Log("Hide command executed", "INFO")
                return true
            end
            return false
        end,
        
        show = function(args)
            -- Show the UI
            if FemBladeUI and FemBladeUI.Enabled ~= true then
                FemBladeUI.Enabled = true
                
                StarterGui:SetCore("ChatMakeSystemMessage", {
                    Text = "FemBlade UI shown.",
                    Color = CONFIG.AccentColor,
                    Font = Enum.Font.GothamSemibold,
                    TextSize = 14
                })
                
                EventLogger:Log("Show command executed", "INFO")
                return true
            end
            return false
        end
    }
    
    -- Add aliases for common commands
    self.Commands["h"] = self.Commands["help"]
    self.Commands["t"] = self.Commands["toggle"]
    self.Commands["m"] = self.Commands["mode"]
    self.Commands["r"] = self.Commands["radius"]
    self.Commands["s"] = self.Commands["stats"]
    
    -- Connect the chat handler
    self:ConnectChatHandler()
    
    EventLogger:Log("Chat command system initialized", "INFO")
end

function ChatCommands:ConnectChatHandler()
    -- Get the chat events
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local DefaultChatSystem = ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents")
    
    if DefaultChatSystem then
        local MessageEvent = DefaultChatSystem:FindFirstChild("OnMessageDoneFiltering")
        
        if MessageEvent then
            MessageEvent.OnClientEvent:Connect(function(messageData)
                self:ProcessChatMessage(messageData)
            end)
        end
    end
    
    -- Alternative method using StarterGui's ChatScript
    if LocalPlayer and LocalPlayer.PlayerGui then
        local ChatScript = LocalPlayer.PlayerGui:FindFirstChild("Chat")
        if ChatScript then
            local ChatBar = ChatScript:FindFirstChild("ChatBar", true)
            if ChatBar then
                ChatBar:GetPropertyChangedSignal("Text"):Connect(function()
                    local message = ChatBar.Text
                    if message:sub(1, 1) == self.Prefix then
                        self:PreProcessCommand(message)
                    end
                end)
            end
        end
    end
end

function ChatCommands:ProcessChatMessage(messageData)
    -- Only process messages from the local player
    if messageData.FromSpeaker ~= LocalPlayer.Name then return end
    
    local message = messageData.Message
    if message:sub(1, 1) == self.Prefix then
        self:ExecuteCommand(message)
    end
end

function ChatCommands:PreProcessCommand(message)
    -- This is called when the player is typing a command
    -- Could be used for command suggestions in the future
end

function ChatCommands:ExecuteCommand(message)
    -- Extract command and arguments
    local fullCommand = message:sub(2) -- Remove prefix
    local args = {}
    
    -- Split by spaces
    for arg in fullCommand:gmatch("%S+") do
        table.insert(args, arg)
    end
    
    if #args == 0 then return end
    
    local commandName = string.lower(table.remove(args, 1))
    local command = self.Commands[commandName]
    
    if command then
        local success = command(args)
        
        -- Add to command history
        table.insert(self.History, {
            Command = commandName,
            Args = args,
            Timestamp = os.time(),
            Success = success
        })
        
        -- Limit history size
        if #self.History > self.MaxHistory then
            table.remove(self.History, 1)
        end
    else
        -- Command not found
        StarterGui:SetCore("ChatMakeSystemMessage", {
            Text = "Unknown command: " .. commandName .. ". Type !help for a list of commands.",
            Color = Color3.fromRGB(255, 100, 100),
            Font = Enum.Font.GothamSemibold,
            TextSize = 14
        })
    end
end

-- Initialize chat commands
ChatCommands:Initialize()

--// KEYBIND SYSTEM //--
-- This module implements keyboard shortcuts for FemBlade features
local KeybindSystem = {}
KeybindSystem.Enabled = CONFIG.KeybindEnabled
KeybindSystem.Keybinds = CONFIG.Keybinds
KeybindSystem.KeysDown = {}
KeybindSystem.Initialized = false

function KeybindSystem:Initialize()
    if not self.Enabled then return end
    
    -- Connect input handling
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        self.KeysDown[input.KeyCode] = true
        self:ProcessKeybind(input.KeyCode)
    end)
    
    UserInputService.InputEnded:Connect(function(input)
        self.KeysDown[input.KeyCode] = nil
    end)
    
    self.Initialized = true
    EventLogger:Log("Keybind system initialized", "INFO")
end

function KeybindSystem:ProcessKeybind(keyCode)
    -- Toggle UI
    if keyCode == self.Keybinds.ToggleUI and FemBladeUI then
        FemBladeUI.Enabled = not FemBladeUI.Enabled
        
        if CONFIG.EnableSounds then
            local sound = Instance.new("Sound")
            sound.SoundId = CONFIG.UIClickSoundId
            sound.Volume = CONFIG.SoundVolume
            sound.Parent = game:GetService("SoundService")
            sound:Play()
            game:GetService("Debris"):AddItem(sound, 2)
        end
        
        EventLogger:Log("UI visibility toggled via keybind", "INFO", {
            Visible = FemBladeUI.Enabled
        })
    end
    
    -- Toggle Auto Parry
    if keyCode == self.Keybinds.ToggleAutoParry then
        IsAutoParryEnabled = not IsAutoParryEnabled
        
        -- Update UI if available
        if UI and UI.UpdateToggleState then
            UI.UpdateToggleState("AutoParry", IsAutoParryEnabled)
        end
        
        -- Notification
        StarterGui:SetCore("SendNotification", {
            Title = CONFIG.Name,
            Text = "Auto Parry: " .. (IsAutoParryEnabled and "Enabled" or "Disabled"),
            Duration = 1.5
        })
        
        EventLogger:Log("Auto Parry toggled via keybind", "INFO", {
            Enabled = IsAutoParryEnabled
        })
    end
    
    -- Cycle Parry Mode
    if keyCode == self.Keybinds.CycleParryMode then
        local currentIndex = table.find(CONFIG.ParryModes, ParryType) or 1
        currentIndex = (currentIndex % #CONFIG.ParryModes) + 1
        ParryType = CONFIG.ParryModes[currentIndex]
        
        -- Update parry data
        UpdateParryData(ParryType)
        
        -- Update UI if available
        if UI and UI.UpdateDropdownValue then
            UI.UpdateDropdownValue("ParryType", ParryType)
        end
        
        -- Notification
        StarterGui:SetCore("SendNotification", {
            Title = CONFIG.Name,
            Text = "Parry Mode: " .. ParryType,
            Duration = 1.5
        })
        
        EventLogger:Log("Parry mode changed via keybind", "INFO", {
            NewMode = ParryType
        })
    end
    
    -- Increase Parry Radius
    if keyCode == self.Keybinds.IncreaseRadius then
        ParryRadius = math.min(ParryRadius + 1, 60)
        
        -- Update UI if available
        if UI and UI.UpdateSliderValue then
            UI.UpdateSliderValue("ParryRadius", ParryRadius)
        end
        
        -- Notification
        StarterGui:SetCore("SendNotification", {
            Title = CONFIG.Name,
            Text = "Parry Radius: " .. ParryRadius,
            Duration = 1
        })
        
        EventLogger:Log("Parry radius increased via keybind", "INFO", {
            NewRadius = ParryRadius
        })
    end
    
    -- Decrease Parry Radius
    if keyCode == self.Keybinds.DecreaseRadius then
        ParryRadius = math.max(ParryRadius - 1, 5)
        
        -- Update UI if available
        if UI and UI.UpdateSliderValue then
            UI.UpdateSliderValue("ParryRadius", ParryRadius)
        end
        
        -- Notification
        StarterGui:SetCore("SendNotification", {
            Title = CONFIG.Name,
            Text = "Parry Radius: " .. ParryRadius,
            Duration = 1
        })
        
        EventLogger:Log("Parry radius decreased via keybind", "INFO", {
            NewRadius = ParryRadius
        })
    end
    
    -- Emergency Parry (immediate parry regardless of ball state)
    if keyCode == self.Keybinds.EmergencyParry then
        UpdateParryData(ParryType)
        for Remote, Args in pairs(Remotes) do
            if type(Remote) == "userdata" and Remote.Name and Remote.FireServer then
                if Parry_Data and #Parry_Data >= 4 then
                    Remote:FireServer(Args, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
                else
                    Remote:FireServer(Args, Parry_Key)
                end
            end
        end
        
        EventLogger:Log("Emergency parry triggered via keybind", "WARNING")
    end
end

-- Initialize keybind system
KeybindSystem:Initialize()

--// VERSION CHECKER //--
-- This module checks for updates to the FemBlade script
local VersionChecker = {}
VersionChecker.Enabled = CONFIG.EnableVersionCheck
VersionChecker.CurrentVersion = CONFIG.Version
VersionChecker.LatestVersion = CONFIG.Version
VersionChecker.UpdateAvailable = false
VersionChecker.LastCheckTime = 0
VersionChecker.CheckInterval = 3600 -- Check once per hour
VersionChecker.VersionHistory = {
    ["1.0.1"] = {
        ReleaseDate = "2025-04-01",
        Major = false,
        Changelog = {
            "Initial release with basic auto parry functionality",
            "First implementation of UI system",
            "Basic ball detection algorithm added"
        }
    },
    ["1.0.2"] = {
        ReleaseDate = "2025-04-10",
        Major = false,
        Changelog = {
            "Improved ball curve detection",
            "Added new parry modes: Backwards, Random, Straight",
            "Fixed UI scaling on different resolutions",
            "Optimized performance for lower-end devices"
        }
    },
    ["1.0.3"] = {
        ReleaseDate = "2025-04-27",
        Major = true,
        Changelog = {
            "Complete UI redesign with purple theme",
            "Enhanced parry prediction algorithm",
            "Added advanced options for customization",
            "Integrated stats tracking system",
            "Improved security features"
        }
    },
    ["1.0.4"] = {
        ReleaseDate = "2025-05-01",
        Major = false,
        Changelog = {
            "Added special ability detection",
            "New Auto Spam system with customizable patterns",
            "Improved bounce prediction accuracy",
            "Better ping compensation for high-latency players",
            "Various bug fixes and optimizations"
        }
    }
}

function VersionChecker:CheckForUpdates()
    if not self.Enabled then return end
    
    -- In a real implementation, this would make an HTTP request to a version endpoint
    -- For this demo, we'll simulate finding a new version
    
    -- Record check time
    self.LastCheckTime = os.time()
    
    -- Simulate version check (would normally be an HTTP request)
    if math.random() < 0.3 then -- 30% chance to "find" an update
        local newVersionNum = tonumber(string.match(self.CurrentVersion, "%d+%.%d+%.(%d+)")) + 1
        self.LatestVersion = string.gsub(self.CurrentVersion, "(%d+%.%d+%.)(%d+)", "%1" .. newVersionNum)
        self.UpdateAvailable = true
        
        -- Notify user about update
        StarterGui:SetCore("SendNotification", {
            Title = "FemBlade Update Available",
            Text = "New version " .. self.LatestVersion .. " is available!",
            Duration = 10
        })
        
        EventLogger:Log("New version found", "INFO", {
            CurrentVersion = self.CurrentVersion,
            LatestVersion = self.LatestVersion
        })
    else
        self.LatestVersion = self.CurrentVersion
        self.UpdateAvailable = false
        
        EventLogger:Log("Version check completed", "INFO", {
            Result = "Up to date"
        })
    end
    
    return self.UpdateAvailable
end

function VersionChecker:GetUpdateDetails()
    if not self.UpdateAvailable then return nil end
    
    -- In a real implementation, this would fetch changelog details
    -- For this demo, we'll return simulated details
    return {
        Version = self.LatestVersion,
        ReleaseDate = os.date("%Y-%m-%d"),
        Changelog = {
            "Improved ball prediction accuracy",
            "Added new parry modes",
            "Fixed UI scaling issues",
            "Performance optimizations"
        },
        UpdateUrl = "https://example.com/femBlade/latest"
    }
end

function VersionChecker:DisplayUpdateNotification()
    if not self.UpdateAvailable then return end
    
    local updateDetails = self:GetUpdateDetails()
    
    -- Create a formatted changelog
    local changelogText = ""
    for i, change in ipairs(updateDetails.Changelog) do
        changelogText = changelogText .. "- " .. change .. "\n"
    end
    
    -- Display notification
    StarterGui:SetCore("ChatMakeSystemMessage", {
        Text = "=== FemBlade Update Available ===\n" ..
               "Current Version: " .. self.CurrentVersion .. "\n" ..
               "New Version: " .. updateDetails.Version .. "\n" ..
               "Released: " .. updateDetails.ReleaseDate .. "\n\n" ..
               "Changes:\n" .. changelogText,
        Color = CONFIG.AccentColor,
        Font = Enum.Font.GothamSemibold,
        TextSize = 14
    })
end

function VersionChecker:GetVersionHistory()
    local historyText = "=== FemBlade Version History ===\n\n"
    
    -- Sort versions
    local versions = {}
    for version, _ in pairs(self.VersionHistory) do
        table.insert(versions, version)
    end
    
    table.sort(versions, function(a, b)
        local aMajor, aMinor, aPatch = string.match(a, "(%d+)%.(%d+)%.(%d+)")
        local bMajor, bMinor, bPatch = string.match(b, "(%d+)%.(%d+)%.(%d+)")
        
        aMajor, aMinor, aPatch = tonumber(aMajor), tonumber(aMinor), tonumber(aPatch)
        bMajor, bMinor, bPatch = tonumber(bMajor), tonumber(bMinor), tonumber(bPatch)
        
        if aMajor ~= bMajor then return aMajor > bMajor end
        if aMinor ~= bMinor then return aMinor > bMinor end
        return aPatch > bPatch
    end)
    
    -- Format history
    for _, version in ipairs(versions) do
        local versionInfo = self.VersionHistory[version]
        historyText = historyText .. "v" .. version .. " (" .. versionInfo.ReleaseDate .. ")"
        
        if versionInfo.Major then
            historyText = historyText .. " [MAJOR UPDATE]"
        end
        
        historyText = historyText .. "\n"
        
        for _, change in ipairs(versionInfo.Changelog) do
            historyText = historyText .. "- " .. change .. "\n"
        end
        
        historyText = historyText .. "\n"
    end
    
    return historyText
end

function VersionChecker:ShowVersionHistory()
    local historyText = self:GetVersionHistory()
    
    StarterGui:SetCore("ChatMakeSystemMessage", {
        Text = historyText,
        Color = CONFIG.AccentColor,
        Font = Enum.Font.GothamSemibold,
        TextSize = 14
    })
end

function VersionChecker:CompareVersions(version1, version2)
    -- Parse versions
    local v1Major, v1Minor, v1Patch = string.match(version1, "(%d+)%.(%d+)%.(%d+)")
    local v2Major, v2Minor, v2Patch = string.match(version2, "(%d+)%.(%d+)%.(%d+)")
    
    if not (v1Major and v1Minor and v1Patch and v2Major and v2Minor and v2Patch) then
        return nil -- Invalid format
    end
    
    v1Major, v1Minor, v1Patch = tonumber(v1Major), tonumber(v1Minor), tonumber(v1Patch)
    v2Major, v2Minor, v2Patch = tonumber(v2Major), tonumber(v2Minor), tonumber(v2Patch)
    
    -- Compare major version
    if v1Major > v2Major then return 1 end
    if v1Major < v2Major then return -1 end
    
    -- Compare minor version
    if v1Minor > v2Minor then return 1 end
    if v1Minor < v2Minor then return -1 end
    
    -- Compare patch version
    if v1Patch > v2Patch then return 1 end
    if v1Patch < v2Patch then return -1 end
    
    -- Versions are equal
    return 0
end

function VersionChecker:GetFeatureChanges(fromVersion, toVersion)
    local comparison = self:CompareVersions(fromVersion, toVersion)
    if not comparison then return "Invalid version format" end
    
    -- If versions are the same or toVersion is older
    if comparison >= 0 then return "No new features" end
    
    local changes = {}
    
    -- Sort versions
    local versions = {}
    for version, _ in pairs(self.VersionHistory) do
        -- Only include versions between fromVersion and toVersion
        if self:CompareVersions(version, fromVersion) > 0 and self:CompareVersions(version, toVersion) <= 0 then
            table.insert(versions, version)
        end
    end
    
    table.sort(versions, function(a, b)
        return self:CompareVersions(a, b) < 0
    end)
    
    -- Collect changes
    for _, version in ipairs(versions) do
        local versionInfo = self.VersionHistory[version]
        for _, change in ipairs(versionInfo.Changelog) do
            table.insert(changes, {
                Version = version,
                Change = change,
                Date = versionInfo.ReleaseDate,
                Major = versionInfo.Major
            })
        end
    end
    
    return changes
end

function VersionChecker:AutoUpdate()
    if not self.UpdateAvailable or not CONFIG.AutoUpdate then return false end
    
    -- In a real implementation, this would download and apply the update
    -- For this demo, we'll simulate the update process
    
    -- Show updating notification
    StarterGui:SetCore("SendNotification", {
        Title = "FemBlade Updating",
        Text = "Downloading version " .. self.LatestVersion .. "...",
        Duration = 5
    })
    
    -- Simulate download and update process
    local updateSuccess = math.random() < 0.9 -- 90% success rate
    
    if updateSuccess then
        -- Update was successful
        self.CurrentVersion = self.LatestVersion
        self.UpdateAvailable = false
        
        -- Update global version
        _G.FemBladeVersion = self.LatestVersion
        
        StarterGui:SetCore("SendNotification", {
            Title = "FemBlade Updated",
            Text = "Successfully updated to version " .. self.LatestVersion,
            Duration = 5
        })
        
        EventLogger:Log("Auto-update completed successfully", "SUCCESS", {
            NewVersion = self.LatestVersion
        })
        
        return true
    else
        -- Update failed
        StarterGui:SetCore("SendNotification", {
            Title = "FemBlade Update Failed",
            Text = "Could not update to version " .. self.LatestVersion,
            Duration = 5
        })
        
        EventLogger:Log("Auto-update failed", "ERROR")
        
        return false
    end
end

-- Run initial version check
if VersionChecker.Enabled then
    spawn(function()
        wait(5) -- Wait a few seconds after startup before checking
        VersionChecker:CheckForUpdates()
    end)
end

--// VISUAL EFFECTS SYSTEM //--
-- This module provides enhanced visual feedback for various script events
local VisualEffects = {}
VisualEffects.Enabled = CONFIG.VisualFeedback
VisualEffects.HitEffectEnabled = CONFIG.HitEffectEnabled
VisualEffects.HitEffectId = CONFIG.HitEffectId
VisualEffects.HitEffectSize = CONFIG.HitEffectSize
VisualEffects.HitEffectDuration = CONFIG.HitEffectDuration
VisualEffects.ActiveEffects = {}
VisualEffects.MaxEffects = 10

function VisualEffects:Initialize()
    -- Preload assets for smoother performance
    if CONFIG.PreloadAssets and self.HitEffectEnabled then
        game:GetService("ContentProvider"):PreloadAsync({self.HitEffectId})
    end
    
    EventLogger:Log("Visual effects system initialized", "INFO")
end

function VisualEffects:CreateHitEffect(position)
    if not self.Enabled or not self.HitEffectEnabled then return end
    
    -- Create effect container
    local effectGui = Instance.new("ScreenGui")
    effectGui.Name = "FemBladeHitEffect"
    effectGui.ResetOnSpawn = false
    
    -- Try different parent methods
    local success = pcall(function()
        effectGui.Parent = game:GetService("CoreGui")
    end)
    
    if not success then
        effectGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end
    
    -- Create effect image
    local effectImage = Instance.new("ImageLabel")
    effectImage.Name = "HitEffectImage"
    effectImage.Size = self.HitEffectSize
    effectImage.Position = UDim2.new(0.5, 0, 0.5, 0)
    effectImage.AnchorPoint = Vector2.new(0.5, 0.5)
    effectImage.BackgroundTransparency = 1
    effectImage.Image = self.HitEffectId
    effectImage.ImageColor3 = CONFIG.AccentColor
    effectImage.ImageTransparency = 0
    effectImage.Parent = effectGui
    
    -- Add to active effects
    table.insert(self.ActiveEffects, effectGui)
    if #self.ActiveEffects > self.MaxEffects then
        local oldestEffect = table.remove(self.ActiveEffects, 1)
        if oldestEffect and oldestEffect.Parent then
            oldestEffect:Destroy()
        end
    end
    
    -- Animate the effect
    spawn(function()
        local startSize = self.HitEffectSize
        local endSize = UDim2.new(startSize.X.Scale * 1.5, startSize.X.Offset * 1.5, 
                                  startSize.Y.Scale * 1.5, startSize.Y.Offset * 1.5)
        
        local startTime = tick()
        local endTime = startTime + self.HitEffectDuration
        
        while tick() < endTime and effectImage and effectImage.Parent do
            local elapsed = tick() - startTime
            local alpha = elapsed / self.HitEffectDuration
            
            -- Update size
            local currentSize = UDim2.new(
                Lerp(startSize.X.Scale, endSize.X.Scale, alpha),
                Lerp(startSize.X.Offset, endSize.X.Offset, alpha),
                Lerp(startSize.Y.Scale, endSize.Y.Scale, alpha),
                Lerp(startSize.Y.Offset, endSize.Y.Offset, alpha)
            )
            effectImage.Size = currentSize
            
            -- Update transparency
            effectImage.ImageTransparency = alpha
            
            wait()
        end
        
        -- Clean up
        if effectGui and effectGui.Parent then
            effectGui:Destroy()
            
            -- Remove from active effects
            for i, effect in ipairs(self.ActiveEffects) do
                if effect == effectGui then
                    table.remove(self.ActiveEffects, i)
                    break
                end
            end
        end
    end)
end

function VisualEffects:CreateParticleEffect(position, color, duration)
    if not self.Enabled then return end
    
    -- Create particle emitter at the specified position
    local part = Instance.new("Part")
    part.Size = Vector3.new(0.1, 0.1, 0.1)
    part.Position = position
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    
    local emitter = Instance.new("ParticleEmitter")
    emitter.Color = ColorSequence.new(color or CONFIG.AccentColor)
    emitter.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0.1),
        NumberSequenceKeypoint.new(0.5, 0.3),
        NumberSequenceKeypoint.new(1, 0.1)
    })
    emitter.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.8, 0.5),
        NumberSequenceKeypoint.new(1, 1)
    })
    emitter.Lifetime = NumberRange.new(0.5, 1)
    emitter.Speed = NumberRange.new(3, 5)
    emitter.SpreadAngle = Vector2.new(0, 180)
    emitter.Rate = 50
    emitter.Parent = part
    
    part.Parent = workspace.CurrentCamera
    
    -- Enable for a burst then clean up
    spawn(function()
        emitter:Emit(20)
        wait(duration or 1)
        emitter.Enabled = false
        wait(1) -- Wait for particles to die out
        part:Destroy()
    end)
end

function VisualEffects:ShowBallPredictionPath(ball, predictionPoints)
    if not self.Enabled or not FeatureSettings.ShowPredictionPath then return end
    
    -- Clear previous visualizations
    for _, obj in pairs(workspace:GetChildren()) do
        if obj.Name == "FemBladePredictionPoint" then
            obj:Destroy()
        end
    end
    
    -- Create new prediction points
    for i, point in ipairs(predictionPoints) do
        local marker = Instance.new("Part")
        marker.Name = "FemBladePredictionPoint"
        marker.Size = Vector3.new(0.3, 0.3, 0.3)
        marker.Position = point
        marker.Anchored = true
        marker.CanCollide = false
        marker.Shape = Enum.PartType.Ball
        marker.Material = Enum.Material.Neon
        
        -- Color gradient from green to red
        local hue = (1 - (i / #predictionPoints)) * 0.3 -- 0.3 = green, 0 = red
        marker.Color = Color3.fromHSV(hue, 1, 1)
        
        marker.Transparency = 0.3 + (i / #predictionPoints) * 0.6
        marker.Parent = workspace
    end
    
    -- Clean up after a short time
    spawn(function()
        wait(0.5)
        for _, obj in pairs(workspace:GetChildren()) do
            if obj.Name == "FemBladePredictionPoint" then
                obj:Destroy()
            end
        end
    end)
end

function VisualEffects:ShowParryRadius(position, radius, duration)
    if not self.Enabled or not FeatureSettings.ShowParryRadius then return end
    
    -- Remove existing radius visualization
    for _, obj in pairs(workspace:GetChildren()) do
        if obj.Name == "FemBladeParryRadius" then
            obj:Destroy()
        end
    end
    
    -- Create new visualization
    local sphere = Instance.new("Part")
    sphere.Name = "FemBladeParryRadius"
    sphere.Size = Vector3.new(radius * 2, radius * 2, radius * 2)
    sphere.Position = position
    sphere.Anchored = true
    sphere.CanCollide = false
    sphere.Shape = Enum.PartType.Ball
    sphere.Material = Enum.Material.ForceField
    sphere.Color = CONFIG.AccentColor
    sphere.Transparency = 0.8
    sphere.Parent = workspace
    
    -- Clean up after duration
    spawn(function()
        local startTime = tick()
        local endTime = startTime + (duration or 3)
        
        while tick() < endTime and sphere and sphere.Parent do
            local alpha = (tick() - startTime) / (duration or 3)
            sphere.Transparency = 0.8 + (alpha * 0.2)
            wait()
        end
        
        if sphere and sphere.Parent then
            sphere:Destroy()
        end
    end)
end

function VisualEffects:FlashScreen(color, duration, transparency)
    if not self.Enabled then return end
    
    -- Create flash effect
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "FemBladeScreenFlash"
    screenGui.ResetOnSpawn = false
    
    local flash = Instance.new("Frame")
    flash.Size = UDim2.new(1, 0, 1, 0)
    flash.BackgroundColor3 = color or CONFIG.AccentColor
    flash.BackgroundTransparency = transparency or 0.7
    flash.BorderSizePixel = 0
    flash.Parent = screenGui
    
    -- Try different parent methods
    local success = pcall(function()
        screenGui.Parent = game:GetService("CoreGui")
    end)
    
    if not success then
        screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end
    
    -- Fade out and clean up
    spawn(function()
        local startTime = tick()
        local endTime = startTime + (duration or 0.3)
        
        while tick() < endTime and flash and flash.Parent do
            local alpha = (tick() - startTime) / (duration or 0.3)
            flash.BackgroundTransparency = (transparency or 0.7) + (alpha * (1 - (transparency or 0.7)))
            wait()
        end
        
        if screenGui and screenGui.Parent then
            screenGui:Destroy()
        end
    end)
end

function VisualEffects:CreateFloatingText(position, text, color, duration, size)
    if not self.Enabled then return end
    
    -- Convert world position to screen position
    local screenPosition, onScreen = workspace.CurrentCamera:WorldToScreenPoint(position)
    if not onScreen then return end
    
    -- Create floating text
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "FemBladeFloatingText"
    screenGui.ResetOnSpawn = false
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(0, 100, 0, 30)
    textLabel.Position = UDim2.new(0, screenPosition.X - 50, 0, screenPosition.Y - 15)
    textLabel.Text = text
    textLabel.TextColor3 = color or CONFIG.AccentColor
    textLabel.TextStrokeTransparency = 0.5
    textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Font = Enum.Font.GothamBold
    textLabel.TextSize = size or 18
    textLabel.Parent = screenGui
    
    -- Try different parent methods
    local success = pcall(function()
        screenGui.Parent = game:GetService("CoreGui")
    end)
    
    if not success then
        screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    end
    
    -- Animate and clean up
    spawn(function()
        local startTime = tick()
        local endTime = startTime + (duration or 1.5)
        local startPos = textLabel.Position
        
        while tick() < endTime and textLabel and textLabel.Parent do
            local alpha = (tick() - startTime) / (duration or 1.5)
            
            -- Move up slowly
            textLabel.Position = UDim2.new(
                startPos.X.Scale, 
                startPos.X.Offset, 
                startPos.Y.Scale, 
                startPos.Y.Offset - (alpha * 50)
            )
            
            -- Fade out towards the end
            if alpha > 0.7 then
                local fadeAlpha = (alpha - 0.7) / 0.3
                textLabel.TextTransparency = fadeAlpha
                textLabel.TextStrokeTransparency = 0.5 + (fadeAlpha * 0.5)
            end
            
            wait()
        end
        
        if screenGui and screenGui.Parent then
            screenGui:Destroy()
        end
    end)
end

-- Initialize Visual Effects
VisualEffects:Initialize()

--// ADAPTIVE TIMING SYSTEM //--
-- This system automatically adjusts parry timing based on success rate
local AdaptiveTimingSystem = {}
AdaptiveTimingSystem.Enabled = CONFIG.AdaptiveTimingSystem
AdaptiveTimingSystem.Initialized = false
AdaptiveTimingSystem.ParryResults = {}
AdaptiveTimingSystem.MaxResults = 50
AdaptiveTimingSystem.SuccessThreshold = 0.75
AdaptiveTimingSystem.AdjustmentAmount = 0.01
AdaptiveTimingSystem.LastAdjustmentTime = 0
AdaptiveTimingSystem.AdjustmentCooldown = 10 -- Seconds between adjustments
AdaptiveTimingSystem.MinPredictionTime = 0.05
AdaptiveTimingSystem.MaxPredictionTime = 0.3
AdaptiveTimingSystem.DefaultPredictionTime = PredictionTime
AdaptiveTimingSystem.PingCompensation = true
AdaptiveTimingSystem.LastPingMeasurement = GetPing()
AdaptiveTimingSystem.PingMeasurements = {AdaptiveTimingSystem.LastPingMeasurement}
AdaptiveTimingSystem.MaxPingMeasurements = 10
AdaptiveTimingSystem.PingAdjustmentFactor = 0.5 -- How much ping affects timing

function AdaptiveTimingSystem:Initialize()
    if not self.Enabled then return end
    
    -- Set default adjustment values
    self.AdjustmentAmount = ParrySettings.SuccessAdjustmentFactor or 0.01
    self.SuccessThreshold = ParrySettings.SuccessThreshold or 0.75
    
    -- Start ping measurement loop if ping compensation is enabled
    if self.PingCompensation then
        spawn(function()
            while true do
                self:MeasurePing()
                wait(5) -- Measure ping every 5 seconds
            end
        end)
    end
    
    self.Initialized = true
    EventLogger:Log("Adaptive timing system initialized", "INFO")
end

function AdaptiveTimingSystem:RecordParryResult(success, targetTime, actualTime)
    if not self.Enabled then return end
    
    -- Record result
    local result = {
        Success = success,
        TargetTime = targetTime or PredictionTime,
        ActualTime = actualTime or tick(),
        Timestamp = tick(),
        Ping = self.LastPingMeasurement
    }
    
    table.insert(self.ParryResults, 1, result)
    if #self.ParryResults > self.MaxResults then
        table.remove(self.ParryResults)
    end
    
    -- Check if we should adjust timing
    if tick() - self.LastAdjustmentTime > self.AdjustmentCooldown and #self.ParryResults >= 10 then
        self:AdjustTiming()
    end
end

function AdaptiveTimingSystem:MeasurePing()
    local currentPing = GetPing()
    self.LastPingMeasurement = currentPing
    
    table.insert(self.PingMeasurements, 1, currentPing)
    if #self.PingMeasurements > self.MaxPingMeasurements then
        table.remove(self.PingMeasurements)
    end
    
    -- Calculate average ping
    local totalPing = 0
    for _, ping in ipairs(self.PingMeasurements) do
        totalPing = totalPing + ping
    end
    
    local averagePing = totalPing / #self.PingMeasurements
    
    -- Check if ping changed significantly and we should adjust prediction time
    if self.PingCompensation and math.abs(averagePing - self.LastPingMeasurement) > 0.05 then
        local pingDifference = averagePing - self.LastPingMeasurement
        local adjustmentAmount = pingDifference * self.PingAdjustmentFactor
        
        -- Adjust prediction time based on ping change
        PredictionTime = math.clamp(
            PredictionTime + adjustmentAmount,
            self.MinPredictionTime,
            self.MaxPredictionTime
        )
        
        EventLogger:Log("Adjusted prediction time based on ping change", "INFO", {
            OldPing = self.LastPingMeasurement,
            NewPing = averagePing,
            Adjustment = adjustmentAmount,
            NewPredictionTime = PredictionTime
        })
    end
end

function AdaptiveTimingSystem:AdjustTiming()
    -- Calculate success rate from recent results
    local totalResults = math.min(#self.ParryResults, 20) -- Consider only last 20 results
    local successCount = 0
    
    for i = 1, totalResults do
        if self.ParryResults[i].Success then
            successCount = successCount + 1
        end
    end
    
    local successRate = successCount / totalResults
    
    -- Determine if we need to adjust
    if successRate < self.SuccessThreshold then
        -- Success rate is too low, adjust prediction time
        local adjustment = self.AdjustmentAmount
        
        -- If success rate is very low, make a bigger adjustment
        if successRate < 0.5 then
            adjustment = adjustment * 2
        end
        
        -- Analyze failures to determine direction of adjustment
        local earlyFailures = 0
        local lateFailures = 0
        
        for i = 1, totalResults do
            local result = self.ParryResults[i]
            if not result.Success then
                -- In a real implementation, we would have data about whether the parry was too early or too late
                -- For this demo, we'll estimate based on ball velocity and position
                
                -- Simulate with random for now
                if math.random() > 0.5 then
                    earlyFailures = earlyFailures + 1
                else
                    lateFailures = lateFailures + 1
                end
            end
        end
        
        -- Adjust based on which type of failure is more common
        if earlyFailures > lateFailures then
            -- If parries are too early, increase prediction time
            PredictionTime = math.min(PredictionTime + adjustment, self.MaxPredictionTime)
        else
            -- If parries are too late, decrease prediction time
            PredictionTime = math.max(PredictionTime - adjustment, self.MinPredictionTime)
        end
        
        EventLogger:Log("Adjusted prediction time based on success rate", "INFO", {
            SuccessRate = successRate,
            EarlyFailures = earlyFailures,
            LateFailures = lateFailures,
            Adjustment = earlyFailures > lateFailures and adjustment or -adjustment,
            NewPredictionTime = PredictionTime
        })
        
        -- Update UI if available
        if UI and UI.UpdateSliderValue then
            UI.UpdateSliderValue("PredictionTime", PredictionTime)
        end
    elseif successRate > 0.95 and ParrySettings.DynamicRadiusAdjustment then
        -- Success rate is very high, we might be able to increase parry radius
        if ParryRadius < ParrySettings.MaxRadius then
            ParryRadius = math.min(ParryRadius + 1, ParrySettings.MaxRadius)
            
            EventLogger:Log("Increased parry radius due to high success rate", "INFO", {
                SuccessRate = successRate,
                NewRadius = ParryRadius
            })
            
            -- Update UI if available
            if UI and UI.UpdateSliderValue then
                UI.UpdateSliderValue("ParryRadius", ParryRadius)
            end
        end
    end
    
    self.LastAdjustmentTime = tick()
end

function AdaptiveTimingSystem:ResetToDefaults()
    PredictionTime = self.DefaultPredictionTime
    
    EventLogger:Log("Reset prediction timing to defaults", "INFO", {
        DefaultTime = self.DefaultPredictionTime
    })
    
    -- Update UI if available
    if UI and UI.UpdateSliderValue then
        UI.UpdateSliderValue("PredictionTime", PredictionTime)
    end
end

function AdaptiveTimingSystem:GetCurrentStatus()
    local totalResults = #self.ParryResults
    local successCount = 0
    
    for _, result in ipairs(self.ParryResults) do
        if result.Success then
            successCount = successCount + 1
        end
    end
    
    local successRate = totalResults > 0 and (successCount / totalResults) or 0
    local averagePing = 0
    
    for _, ping in ipairs(self.PingMeasurements) do
        averagePing = averagePing + ping
    end
    
    averagePing = #self.PingMeasurements > 0 and (averagePing / #self.PingMeasurements) or 0
    
    return {
        Enabled = self.Enabled,
        SuccessRate = successRate,
        PredictionTime = PredictionTime,
        ParryRadius = ParryRadius,
        TotalSamples = totalResults,
        AveragePing = averagePing,
        PingCompensation = self.PingCompensation,
        LastAdjustment = self.LastAdjustmentTime > 0 and (tick() - self.LastAdjustmentTime) or nil
    }
end

-- Initialize Adaptive Timing System
AdaptiveTimingSystem:Initialize()

--// PATTERN RECOGNITION SYSTEM //--
-- This module analyzes ball behavior to detect patterns in movement
local PatternRecognition = {}
PatternRecognition.Enabled = CONFIG.PatternRecognition
PatternRecognition.Initialized = false
PatternRecognition.Patterns = {}
PatternRecognition.CurrentSequence = {}
PatternRecognition.MaxSequenceLength = 10
PatternRecognition.MinPatternLength = 3
PatternRecognition.MaxPatternLength = 7
PatternRecognition.PatternDetectionThreshold = 0.7 -- Similarity threshold
PatternRecognition.LastPatternTime = 0
PatternRecognition.CurrentPattern = nil
PatternRecognition.PredictionAccuracy = 0
PatternRecognition.EnabledStrategies = {
    TemporalAnalysis = true,
    SpatialAnalysis = true,
    PlayerTargetAnalysis = true,
    VelocityPatterns = true,
    TimingPatterns = true,
    TargetSwitchPatterns = true
}

function PatternRecognition:Initialize()
    if not self.Enabled then return end
    
    EventLogger:Log("Pattern recognition system initialized", "INFO")
    self.Initialized = true
end

function PatternRecognition:RecordBallEvent(ball, eventType, data)
    if not self.Enabled or not self.Initialized then return end
    
    -- Create a ball event record
    local event = {
        Type = eventType, -- "spawn", "target_change", "parried", "hit", "velocity_change"
        Timestamp = tick(),
        BallPosition = ball and ball.Position or Vector3.new(0, 0, 0),
        BallVelocity = ball and ((ball:FindFirstChild("zoomies") and ball.zoomies.VectorVelocity) or ball.Velocity) or Vector3.new(0, 0, 0),
        Target = ball and ball:GetAttribute("target") or "None",
        Data = data or {}
    }
    
    -- Add to current sequence
    table.insert(self.CurrentSequence, event)
    if #self.CurrentSequence > self.MaxSequenceLength then
        table.remove(self.CurrentSequence, 1)
    end
    
    -- Try to detect patterns
    self:DetectPatterns()
end

function PatternRecognition:CalcualteEventSimilarity(event1, event2)
    if event1.Type ~= event2.Type then return 0 end
    
    local similarity = 0
    
    -- Basic similarity is 0.2 just for being the same event type
    similarity = similarity + 0.2
    
    -- Compare ball positions (normalized to 0.3)
    local positionDistance = (event1.BallPosition - event2.BallPosition).Magnitude
    local positionSimilarity = math.max(0, 1 - (positionDistance / 50))
    similarity = similarity + (positionSimilarity * 0.3)
    
    -- Compare targets (normalized to 0.3)
    if event1.Target == event2.Target then
        similarity = similarity + 0.3
    end
    
    -- Compare velocities (normalized to 0.2)
    local velocityDifference = (event1.BallVelocity - event2.BallVelocity).Magnitude
    local velocitySimilarity = math.max(0, 1 - (velocityDifference / 100))
    similarity = similarity + (velocitySimilarity * 0.2)
    
    return similarity
end

function PatternRecognition:DetectPatterns()
    if #self.CurrentSequence < self.MinPatternLength then return end
    
    -- Look for repeating subsequences
    for length = self.MinPatternLength, math.min(self.MaxPatternLength, math.floor(#self.CurrentSequence / 2)) do
        -- Get the most recent subsequence of the current length
        local recentSubsequence = {}
        for i = #self.CurrentSequence - length + 1, #self.CurrentSequence do
            table.insert(recentSubsequence, self.CurrentSequence[i])
        end
        
        -- Look for this subsequence earlier in the event history
        for startIdx = 1, #self.CurrentSequence - (2 * length) + 1 do
            local matchScore = 0
            
            for i = 1, length do
                local earlierEvent = self.CurrentSequence[startIdx + i - 1]
                local recentEvent = recentSubsequence[i]
                
                matchScore = matchScore + self:CalcualteEventSimilarity(earlierEvent, recentEvent)
            end
            
            -- Normalize match score
            matchScore = matchScore / length
            
            -- If we found a good match, record this pattern
            if matchScore >= self.PatternDetectionThreshold then
                local pattern = {
                    Events = {},
                    Length = length,
                    MatchScore = matchScore,
                    FirstDetected = tick(),
                    LastDetected = tick(),
                    OccurrenceCount = 1,
                    PredictionSuccesses = 0,
                    PredictionAttempts = 0
                }
                
                -- Copy events to pattern
                for i = 1, length do
                    table.insert(pattern.Events, DeepCopy(self.CurrentSequence[startIdx + i - 1]))
                end
                
                -- Check if this pattern already exists
                local patternExists = false
                for i, existingPattern in ipairs(self.Patterns) do
                    if #existingPattern.Events == length then
                        local patternSimilarity = 0
                        for j = 1, length do
                            patternSimilarity = patternSimilarity + 
                                self:CalcualteEventSimilarity(existingPattern.Events[j], pattern.Events[j])
                        end
                        patternSimilarity = patternSimilarity / length
                        
                        if patternSimilarity >= 0.9 then
                            -- Update existing pattern
                            existingPattern.OccurrenceCount = existingPattern.OccurrenceCount + 1
                            existingPattern.LastDetected = tick()
                            existingPattern.MatchScore = (existingPattern.MatchScore + matchScore) / 2
                            patternExists = true
                            break
                        end
                    end
                end
                
                -- Add new pattern if it doesn't exist
                if not patternExists then
                    table.insert(self.Patterns, pattern)
                    
                    EventLogger:Log("New ball pattern detected", "INFO", {
                        Length = length,
                        MatchScore = matchScore
                    })
                end
                
                -- Update current pattern
                self.CurrentPattern = pattern
                self.LastPatternTime = tick()
            end
        end
    end
end

function PatternRecognition:PredictNextEvent()
    if not self.Enabled or not self.Initialized or not self.CurrentPattern then return nil end
    
    -- If the pattern is too old, ignore it
    if tick() - self.LastPatternTime > 5 then
        self.CurrentPattern = nil
        return nil
    end
    
    -- Look at the last events in the current sequence
    local sequenceEnd = {}
    local patternLength = #self.CurrentPattern.Events
    local lookbackLength = math.min(patternLength - 1, #self.CurrentSequence)
    
    for i = 1, lookbackLength do
        table.insert(sequenceEnd, self.CurrentSequence[#self.CurrentSequence - lookbackLength + i])
    end
    
    -- Find where in the pattern we are
    local bestMatchIndex = 0
    local bestMatchScore = 0
    
    for i = 1, patternLength - lookbackLength do
        local matchScore = 0
        
        for j = 1, lookbackLength do
            local patternEvent = self.CurrentPattern.Events[i + j - 1]
            local sequenceEvent = sequenceEnd[j]
            
            matchScore = matchScore + self:CalcualteEventSimilarity(patternEvent, sequenceEvent)
        end
        
        matchScore = matchScore / lookbackLength
        
        if matchScore > bestMatchScore then
            bestMatchScore = matchScore
            bestMatchIndex = i
        end
    end
    
    -- If we found a good match position in the pattern
    if bestMatchScore >= self.PatternDetectionThreshold and bestMatchIndex > 0 then
        -- The next event would be right after our match position
        local nextEventIndex = bestMatchIndex + lookbackLength
        
        -- If we're at the end of the pattern, the next event would be the first one
        if nextEventIndex > patternLength then
            nextEventIndex = 1
        end
        
        local predictedEvent = DeepCopy(self.CurrentPattern.Events[nextEventIndex])
        
        -- Record prediction attempt
        self.CurrentPattern.PredictionAttempts = self.CurrentPattern.PredictionAttempts + 1
        
        -- Calculate estimated time until this event based on pattern timing
        local timeOffset = 0
        if nextEventIndex > 1 then
            timeOffset = self.CurrentPattern.Events[nextEventIndex].Timestamp - 
                         self.CurrentPattern.Events[bestMatchIndex + lookbackLength - 1].Timestamp
        else
            timeOffset = self.CurrentPattern.Events[1].Timestamp - 
                         self.CurrentPattern.Events[patternLength].Timestamp
        end
        
        predictedEvent.PredictedTime = tick() + timeOffset
        
        return predictedEvent
    end
    
    return nil
end

function PatternRecognition:VerifyPrediction(predictedEvent, actualEvent)
    if not predictedEvent or not actualEvent then return false end
    
    local similarity = self:CalcualteEventSimilarity(predictedEvent, actualEvent)
    
    -- Record success/failure
    if similarity >= self.PatternDetectionThreshold then
        self.CurrentPattern.PredictionSuccesses = self.CurrentPattern.PredictionSuccesses + 1
        
        -- Update prediction accuracy
        self.PredictionAccuracy = self.CurrentPattern.PredictionSuccesses / self.CurrentPattern.PredictionAttempts
        
        return true
    end
    
    return false
end

function PatternRecognition:GetTopPatterns(count)
    count = count or 3
    
    -- Sort patterns by occurrence count
    local sortedPatterns = {}
    for _, pattern in ipairs(self.Patterns) do
        table.insert(sortedPatterns, pattern)
    end
    
    table.sort(sortedPatterns, function(a, b)
        return a.OccurrenceCount > b.OccurrenceCount
    end)
    
    -- Return top N patterns
    local result = {}
    for i = 1, math.min(count, #sortedPatterns) do
        table.insert(result, sortedPatterns[i])
    end
    
    return result
end

function PatternRecognition:ClearPatterns()
    self.Patterns = {}
    self.CurrentSequence = {}
    self.CurrentPattern = nil
    EventLogger:Log("Pattern memory cleared", "INFO")
end

function PatternRecognition:GetStatus()
    return {
        Enabled = self.Enabled,
        PatternCount = #self.Patterns,
        CurrentSequenceLength = #self.CurrentSequence,
        HasActivePattern = self.CurrentPattern ~= nil,
        PredictionAccuracy = self.PredictionAccuracy,
        TopPatterns = self:GetTopPatterns(3)
    }
end

-- Initialize Pattern Recognition System
PatternRecognition:Initialize()

--// DATA SYNCHRONIZATION SYSTEM //--
-- This module handles synchronization of settings and statistics
local DataSync = {}
DataSync.Enabled = CONFIG.CloudSync
DataSync.Initialized = false
DataSync.LastSyncTime = 0
DataSync.SyncInterval = 300 -- 5 minutes
DataSync.LocalData = {
    Settings = {},
    Stats = {},
    Patterns = {},
    Version = CONFIG.Version,
    LastSync = 0
}
DataSync.RemoteURL = CONFIG.WebhookEndpoint or ""
DataSync.SyncQueue = {}

function DataSync:Initialize()
    if not self.Enabled then return end
    
    -- Load initial settings from config
    self.LocalData.Settings = {
        ParryRadius = ParryRadius,
        PredictionTime = PredictionTime,
        ParryAccuracy = ParryAccuracy,
        ParryType = ParryType,
        RandomizedParryAccuracy = RandomizedParryAccuracy,
        InfinityDetection = InfinityDetection,
        DeathSlashDetection = DeathSlashDetection,
        TimeHoleDetection = TimeHoleDetection,
        SlashOfFuryDetection = SlashOfFuryDetection,
        AntiPhantom = AntiPhantom,
        CooldownProtection = CooldownProtection,
        AutoAbility = AutoAbility
    }
    
    -- Load initial stats
    self.LocalData.Stats = {
        TotalParries = SessionStats.TotalParries,
        SuccessfulParries = SessionStats.SuccessfulParries,
        MissedParries = SessionStats.MissedParries,
        AverageReactionTime = SessionStats.AverageReactionTime,
        BallsDetected = SessionStats.BallsDetected,
        Uptime = SessionStats.Uptime
    }
    
    -- Start sync loop
    spawn(function()
        while self.Enabled do
            wait(self.SyncInterval)
            self:SyncData()
        end
    end)
    
    self.Initialized = true
    EventLogger:Log("Data synchronization system initialized", "INFO")
end

function DataSync:LoadSettings()
    if not self.Enabled or not self.Initialized then return false end
    
    -- In a real implementation, this would load from local storage or remote server
    -- For this demo, we'll just use our local data
    
    -- Apply settings from local data
    ParryRadius = self.LocalData.Settings.ParryRadius or ParryRadius
    PredictionTime = self.LocalData.Settings.PredictionTime or PredictionTime
    ParryAccuracy = self.LocalData.Settings.ParryAccuracy or ParryAccuracy
    ParryType = self.LocalData.Settings.ParryType or ParryType
    RandomizedParryAccuracy = self.LocalData.Settings.RandomizedParryAccuracy or RandomizedParryAccuracy
    InfinityDetection = self.LocalData.Settings.InfinityDetection or InfinityDetection
    DeathSlashDetection = self.LocalData.Settings.DeathSlashDetection or DeathSlashDetection
    TimeHoleDetection = self.LocalData.Settings.TimeHoleDetection or TimeHoleDetection
    SlashOfFuryDetection = self.LocalData.Settings.SlashOfFuryDetection or SlashOfFuryDetection
    AntiPhantom = self.LocalData.Settings.AntiPhantom or AntiPhantom
    CooldownProtection = self.LocalData.Settings.CooldownProtection or CooldownProtection
    AutoAbility = self.LocalData.Settings.AutoAbility or AutoAbility
    
    -- Update UI if available
    if UI then
        if UI.UpdateSliderValue then
            UI.UpdateSliderValue("ParryRadius", ParryRadius)
            UI.UpdateSliderValue("PredictionTime", PredictionTime)
            UI.UpdateSliderValue("ParryAccuracy", ParryAccuracy)
        end
        
        if UI.UpdateDropdownValue then
            UI.UpdateDropdownValue("ParryType", ParryType)
        end
        
        if UI.UpdateToggleState then
            UI.UpdateToggleState("RandomizedParryAccuracy", RandomizedParryAccuracy)
            UI.UpdateToggleState("InfinityDetection", InfinityDetection)
            UI.UpdateToggleState("DeathSlashDetection", DeathSlashDetection)
            UI.UpdateToggleState("TimeHoleDetection", TimeHoleDetection)
            UI.UpdateToggleState("SlashOfFuryDetection", SlashOfFuryDetection)
            UI.UpdateToggleState("AntiPhantom", AntiPhantom)
            UI.UpdateToggleState("CooldownProtection", CooldownProtection)
            UI.UpdateToggleState("AutoAbility", AutoAbility)
        end
    end
    
    EventLogger:Log("Settings loaded from storage", "INFO")
    return true
end

function DataSync:SaveSettings()
    if not self.Enabled or not self.Initialized then return false end
    
    -- Update local data with current settings
    self.LocalData.Settings = {
        ParryRadius = ParryRadius,
        PredictionTime = PredictionTime,
        ParryAccuracy = ParryAccuracy,
        ParryType = ParryType,
        RandomizedParryAccuracy = RandomizedParryAccuracy,
        InfinityDetection = InfinityDetection,
        DeathSlashDetection = DeathSlashDetection,
        TimeHoleDetection = TimeHoleDetection,
        SlashOfFuryDetection = SlashOfFuryDetection,
        AntiPhantom = AntiPhantom,
        CooldownProtection = CooldownProtection,
        AutoAbility = AutoAbility
    }
    
    -- Update local data with current stats
    self.LocalData.Stats = {
        TotalParries = SessionStats.TotalParries,
        SuccessfulParries = SessionStats.SuccessfulParries,
        MissedParries = SessionStats.MissedParries,
        AverageReactionTime = SessionStats.AverageReactionTime,
        BallsDetected = SessionStats.BallsDetected,
        Uptime = SessionStats.Uptime
    }
    
    -- In a real implementation, this would save to local storage or queue for remote sync
    self.LocalData.LastSync = os.time()
    
    -- Add to sync queue for later sync
    table.insert(self.SyncQueue, {
        Type = "settings_update",
        Data = self.LocalData,
        Timestamp = os.time()
    })
    
    EventLogger:Log("Settings saved to storage", "INFO")
    return true
end

function DataSync:SyncData()
    if not self.Enabled or not self.Initialized or #self.SyncQueue == 0 then return false end
    
    -- In a real implementation, this would send data to remote server
    -- For this demo, we'll just simulate the sync
    
    self.LastSyncTime = os.time()
    
    -- Process sync queue
    for _, syncItem in ipairs(self.SyncQueue) do
        -- In a real implementation, this would send data to server
        -- Here we'll just log it
        EventLogger:Log("Data sync item processed", "INFO", {
            Type = syncItem.Type,
            Timestamp = syncItem.Timestamp
        })
    end
    
    -- Clear sync queue
    self.SyncQueue = {}
    
    EventLogger:Log("Data synchronized with cloud", "SUCCESS")
    return true
end

function DataSync:ImportSettings(settingsString)
    if not settingsString or settingsString == "" then return false end
    
    -- In a real implementation, this would parse a JSON or encoded string
    -- For this demo, we'll simulate importing settings
    
    -- Simulate successful import
    if math.random() < 0.9 then
        -- Apply some simulated settings
        ParryRadius = 45
        PredictionTime = 0.14
        ParryType = "Adaptive"
        
        -- Update UI if available
        if UI then
            if UI.UpdateSliderValue then
                UI.UpdateSliderValue("ParryRadius", ParryRadius)
                UI.UpdateSliderValue("PredictionTime", PredictionTime)
            end
            
            if UI.UpdateDropdownValue then
                UI.UpdateDropdownValue("ParryType", ParryType)
            end
        end
        
        EventLogger:Log("Settings imported successfully", "SUCCESS")
        return true
    else
        EventLogger:Log("Failed to import settings", "ERROR")
        return false
    end
end

function DataSync:ExportSettings()
    -- In a real implementation, this would generate a JSON or encoded string
    -- For this demo, we'll return a placeholder
    
    local settingsData = {
        ParryRadius = ParryRadius,
        PredictionTime = PredictionTime,
        ParryAccuracy = ParryAccuracy,
        ParryType = ParryType,
        RandomizedParryAccuracy = RandomizedParryAccuracy,
        InfinityDetection = InfinityDetection,
        DeathSlashDetection = DeathSlashDetection,
        TimeHoleDetection = TimeHoleDetection,
        SlashOfFuryDetection = SlashOfFuryDetection,
        AntiPhantom = AntiPhantom,
        CooldownProtection = CooldownProtection,
        AutoAbility = AutoAbility,
        Version = CONFIG.Version,
        ExportTime = os.time()
    }
    
    -- Convert to encoded string (in real implementation this would be JSON or base64)
    local exportString = "FemBlade_Settings_Export_v" .. CONFIG.Version .. "_" .. os.time()
    
    EventLogger:Log("Settings exported", "INFO")
    return exportString
end

-- Initialize Data Sync system
DataSync:Initialize()

--// ANALYTICS COLLECTION //--
-- This module anonymously collects usage statistics if enabled
local Analytics = {}
Analytics.Enabled = CONFIG.EnableAnalytics and CONFIG.ShareAnonymousStats
Analytics.Initialized = false
Analytics.Events = {}
Analytics.MaxEvents = 100
Analytics.LastSubmitTime = 0
Analytics.SubmitInterval = 600 -- 10 minutes
Analytics.UserIdentifier = HttpService:GenerateGUID(false) -- Anonymous identifier

function Analytics:Initialize()
    if not self.Enabled then return end
    
    -- Start submission loop
    spawn(function()
        while self.Enabled do
            wait(self.SubmitInterval)
            self:SubmitEvents()
        end
    end)
    
    -- Track initial events
    self:TrackEvent("script_load", {
        version = CONFIG.Version,
        load_time = tick() - StartTime,
        executor = DiagnosticsUtil.ScriptEnvironment.Executor,
        features_enabled = {
            auto_parry = IsAutoParryEnabled,
            auto_spam = FeatureSettings.AutoSpamEnabled,
            manual_spam = FeatureSettings.ManualSpamEnabled,
            pattern_recognition = PatternRecognition.Enabled,
            adaptive_timing = AdaptiveTimingSystem.Enabled
        }
    })
    
    self.Initialized = true
    EventLogger:Log("Analytics system initialized", "INFO")
end

function Analytics:TrackEvent(eventName, eventData)
    if not self.Enabled or not self.Initialized then return end
    
    -- Create event object
    local event = {
        Name = eventName,
        Timestamp = os.time(),
        Data = eventData or {},
        UserID = self.UserIdentifier,
        Version = CONFIG.Version
    }
    
    -- Add to events list
    table.insert(self.Events, event)
    if #self.Events > self.MaxEvents then
        table.remove(self.Events, 1)
    end
end

function Analytics:SubmitEvents()
    if not self.Enabled or not self.Initialized or #self.Events == 0 then return end
    
    -- In a real implementation, this would send data to an analytics server
    -- For this demo, we'll just log it
    
    EventLogger:Log("Analytics events submitted", "INFO", {
        EventCount = #self.Events
    })
    
    -- Clear events
    self.Events = {}
    self.LastSubmitTime = os.time()
end

function Analytics:SetEnabled(enabled)
    self.Enabled = enabled and CONFIG.EnableAnalytics
    
    if enabled and not self.Initialized then
        self:Initialize()
    end
    
    EventLogger:Log("Analytics " .. (enabled and "enabled" or "disabled"), "INFO")
end

-- Initialize Analytics if enabled
Analytics:Initialize()

--// FINAL INITIALIZATION //--
-- Show welcome notification
StarterGui:SetCore("SendNotification", {
    Title = CONFIG.Name,
    Text = "Script loaded successfully! Auto parry distance set to " .. ParryRadius,
    Duration = 3
})

-- Log initialization
DebugPrint("Initialized in", string.format("%.2f", tick() - StartTime), "seconds")
DebugPrint("Auto parry radius set to", ParryRadius)
DebugPrint("Current player:", PlayerName, "ID:", UserId)
DebugPrint("Version:", CONFIG.Version)

-- Track analytics event if enabled
if Analytics.Enabled then
    Analytics:TrackEvent("initialization_complete", {
        initTime = tick() - StartTime,
        parryRadius = ParryRadius,
        predictionTime = PredictionTime,
        parryType = ParryType
    })
end

-- Final startup procedures
UpdateParryData(ParryType)
StarterGui:SetCore("ChatMakeSystemMessage", {
    Text = "[" .. CONFIG.Name .. "] Loaded successfully! Press M to toggle auto parry.",
    Color = Color3.fromRGB(140, 70, 240),
    Font = Enum.Font.GothamBold,
    TextSize = 16
})

-- Show a tip if enabled
if CONFIG.EnableTips then
    local tips = {
        "Press M to toggle auto parry!",
        "Try different parry modes by pressing N!",
        "Adjust parry radius with [ and ] keys!",
        "Use right-click for manual spam parry!",
        "Type !help in chat for a list of commands!",
        "Need help? Join our Discord server!",
        "Different ball colors indicate special abilities!",
        "Parry timing is automatically adjusted based on your ping!",
        "Try the Adaptive parry mode for curved balls!"
    }
    
    local randomTip = tips[math.random(1, #tips)]
    
    spawn(function()
        wait(5) -- Wait a few seconds before showing tip
        StarterGui:SetCore("SendNotification", {
            Title = "FemBlade Tip",
            Text = randomTip,
            Duration = 7
        })
    end)
end

-- Create visual effect for startup
VisualEffects:FlashScreen(CONFIG.AccentColor, 0.5, 0.8)

-- Record successful initialization
EventLogger:Log("FemBlade script initialized successfully", "SUCCESS", {
    Version = CONFIG.Version,
    ParryRadius = ParryRadius,
    StartupTime = string.format("%.2f", tick() - StartTime)
})

print(CONFIG.Name .. " Auto Parry script loaded successfully!")

--// DISCORD RPC INTEGRATION //--
-- Optional Discord rich presence integration
if CONFIG.DiscordRPC then
    spawn(function()
        -- This would normally integrate with Discord's rich presence API
        -- For this demo, we'll just simulate the integration
        
        EventLogger:Log("Discord RPC initialized", "INFO")
        
        -- Update rich presence every minute
        while true do
            -- Update statistics
            local stats = {
                parries = SessionStats.SuccessfulParries,
                uptime = FormatTime(math.floor(SessionStats.Uptime)),
                mode = ParryType
            }
            
            EventLogger:Log("Discord presence updated", "INFO", stats)
            
            wait(60)
        end
    end)
end