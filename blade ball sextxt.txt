-- Load required services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildOfClass("Humanoid")
local Alive = workspace:WaitForChild("Alive")
local Camera = workspace.CurrentCamera

-- Enhanced variables for remote events and parry control
local Remotes = {}
local Parry_Key = nil
local Parry_Data = nil
local Parry_Type = "Custom"
local Cooldown = 0
local IsParried = false
local Connection = nil
local IsAutoParryEnabled = false
local ParryRadius = 15
local PredictionTime = 0.2
local Parries = 0
local Last_Input = UserInputService:GetLastInputType()
local AntiCurveEnabled = true
local VisualFeedbackEnabled = true
local HitboxVisualizationEnabled = false
local ParrySuccessCounter = 0
local PingCompensationEnabled = true
local ConfigSaved = false

-- Configuration settings
local Config = {
    AutoParry = true,
    AntiCurve = true,
    ParryRadius = 15,
    PredictionTime = 0.2,
    VisualFeedback = true,
    HitboxVisualization = false,
    PingCompensation = true,
    Keybinds = {
        ToggleUI = Enum.KeyCode.RightControl,
        ToggleAutoParry = Enum.KeyCode.P,
        ManualParry = Enum.KeyCode.F
    }
}

-- Capture remotes via debug
task.spawn(function()
    for _, Value in pairs(getgc()) do
        if type(Value) == "function" and islclosure(Value) then
            if debug.getupvalues(Value) then
                local Protos = debug.getprotos(Value)
                local Upvalues = debug.getupvalues(Value)
                local Constants = debug.getconstants(Value)
                if #Protos == 4 and #Upvalues == 24 and #Constants == 104 then
                    Remotes[debug.getupvalue(Value, 16)] = debug.getconstant(Value, 62)
                    Parry_Key = debug.getupvalue(Value, 17)
                    Remotes[debug.getupvalue(Value, 18)] = debug.getconstant(Value, 64)
                    Remotes[debug.getupvalue(Value, 19)] = debug.getconstant(Value, 65)
                    break
                end
            end
        end
    end
end)

-- Improved ball detection
local function GetBall()
    local balls = workspace:FindFirstChild("Balls")
    if not balls then return nil end

    -- First try to find the real ball by attribute
    for _, Ball in ipairs(balls:GetChildren()) do
        if Ball:GetAttribute("realBall") then
            return Ball
        end
    end

    -- If no ball with attribute found, try to find by velocity
    for _, Ball in ipairs(balls:GetChildren()) do
        if Ball:IsA("BasePart") and Ball:FindFirstChild("zoomies") then
            return Ball
        end
    end

    return nil
end

local function ResetConnection()
    if Connection then
        Connection:Disconnect()
        Connection = nil
    end
end

-- Enhanced ball monitoring
workspace:WaitForChild("Balls").ChildAdded:Connect(function(ball)
    task.wait(0.1) -- Wait for attributes to be set
    local Ball = GetBall()
    if not Ball then return end

    ResetConnection()
    Connection = Ball:GetAttributeChangedSignal("target"):Connect(function()
        IsParried = false
    end)
end)

-- Improved ball position prediction with anti-curve
local function PredictBallPosition(Ball, TimeAhead)
    local Velocity = (Ball:FindFirstChild("zoomies") and Ball.zoomies.VectorVelocity) or Vector3.new(0, 0, 0)

    -- Anti-curve logic
    if AntiCurveEnabled then
        -- Calculate the direction to the player
        local HRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if HRP then
            local dirToPlayer = (HRP.Position - Ball.Position).Unit
            local currentVelDir = Velocity.Unit
            
            -- Calculate dot product to see if ball is curving
            local dotProduct = dirToPlayer:Dot(currentVelDir)
            
            -- If ball is curving (not directly heading to player)
            if dotProduct < 0.9 then
                -- Adjust velocity to account for curve
                local adjustedVelocity = Velocity:Lerp(dirToPlayer * Velocity.Magnitude, 0.5)
                return Ball.Position + adjustedVelocity * TimeAhead
            end
        end
    end

    return Ball.Position + Velocity * TimeAhead
end

-- Function to show visual feedback when parrying
local function ShowParryFeedback()
    if not VisualFeedbackEnabled then return end
    
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "ParryFeedback"
    ScreenGui.ResetOnSpawn = false
    ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
    
    local Flash = Instance.new("Frame")
    Flash.Size = UDim2.new(1, 0, 1, 0)
    Flash.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Flash.BackgroundTransparency = 0.7
    Flash.BorderSizePixel = 0
    Flash.Parent = ScreenGui
    
    -- Text indicator
    local SuccessText = Instance.new("TextLabel")
    SuccessText.Size = UDim2.new(0, 200, 0, 50)
    SuccessText.Position = UDim2.new(0.5, -100, 0.4, 0)
    SuccessText.BackgroundTransparency = 1
    SuccessText.Text = "PARRIED!"
    SuccessText.TextColor3 = Color3.fromRGB(0, 255, 0)
    SuccessText.TextStrokeTransparency = 0
    SuccessText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    SuccessText.TextSize = 36
    SuccessText.Font = Enum.Font.GothamBold
    SuccessText.Parent = ScreenGui
    
    -- Fade out effect
    TweenService:Create(Flash, TweenInfo.new(0.2), {BackgroundTransparency = 1}):Play()
    TweenService:Create(SuccessText, TweenInfo.new(0.5), {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
    
    Debris:AddItem(ScreenGui, 0.5)
end

-- Function to visualize hitbox
local function VisualizeHitbox(Ball, Radius)
    if not HitboxVisualizationEnabled or not Ball then return end
    
    local HitboxPart = Instance.new("Part")
    HitboxPart.Name = "ParryHitbox"
    HitboxPart.Shape = Enum.PartType.Ball
    HitboxPart.Size = Vector3.new(Radius * 2, Radius * 2, Radius * 2)
    HitboxPart.Position = Ball.Position
    HitboxPart.Anchored = true
    HitboxPart.CanCollide = false
    HitboxPart.Transparency = 0.8
    HitboxPart.Material = Enum.Material.ForceField
    HitboxPart.Color = Color3.fromRGB(0, 255, 0)
    HitboxPart.Parent = workspace
    
    Debris:AddItem(HitboxPart, 0.1)
end

-- Improved auto parry with better timing
local function AutoParry()
    if not IsAutoParryEnabled then return end

    local Ball = GetBall()
    local Character = LocalPlayer.Character
    if not Ball or not Character then return end

    local HRP = Character:FindFirstChild("HumanoidRootPart")
    if not HRP then return end

    -- Visualize hitbox if enabled
    VisualizeHitbox(Ball, ParryRadius)

    -- Check if ball is targeting the player
    if Ball:GetAttribute("target") == LocalPlayer.Name and not IsParried then
        local PredictedPosition = PredictBallPosition(Ball, PredictionTime)
        local DistanceToPredicted = (HRP.Position - PredictedPosition).Magnitude
        
        -- Calculate dynamic parry radius based on ball velocity
        local Velocity = (Ball:FindFirstChild("zoomies") and Ball.zoomies.VectorVelocity) or Vector3.new(0, 0, 0)
        local VelocityMagnitude = Velocity.Magnitude
        local DynamicRadius = ParryRadius + (VelocityMagnitude / 10)
        
        -- Apply ping compensation if enabled
        if PingCompensationEnabled then
            local Ping = LocalPlayer:GetNetworkPing() * 1000 -- Convert to ms
            DynamicRadius = DynamicRadius + (Ping / 100) -- Adjust radius based on ping
        end
        
        if DistanceToPredicted <= DynamicRadius then
            -- Fire all parry remotes
            for Remote, Args in pairs(Remotes) do
                Remote:FireServer(Args, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
            end
            
            IsParried = true
            Cooldown = tick()
            ParrySuccessCounter = ParrySuccessCounter + 1
            ShowParryFeedback()
        end
    end

    -- Reset parry state after cooldown
    if IsParried and (tick() - Cooldown) >= 1 then
        IsParried = false
    end
end

RunService.PreSimulation:Connect(AutoParry)

-- Update parry data based on selected curve type
local function updateParryData(parryType)
    local Vector3_Mouse_Location
    if Last_Input == Enum.UserInputType.MouseButton1 or
       Last_Input == Enum.UserInputType.MouseButton2 or
       Last_Input == Enum.UserInputType.Keyboard then
        local Mouse_Location = UserInputService:GetMouseLocation()
        Vector3_Mouse_Location = {Mouse_Location.X, Mouse_Location.Y}
    else
        Vector3_Mouse_Location = {Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2}
    end

    local Events = {}
    for _, v in pairs(Alive:GetChildren()) do
        if v:FindFirstChild("PrimaryPart") then
            Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
        end
    end

    local data  
    if parryType == "Custom" then  
        data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}  
    elseif parryType == "Backwards" then  
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.LookVector * 1000)), Events, Vector3_Mouse_Location}  
    elseif parryType == "Random" then  
        data = {0, CFrame.new(Camera.CFrame.Position, Vector3.new(math.random(-3000,3000), math.random(-3000,3000), math.random(-3000,3000))), Events, Vector3_Mouse_Location}  
    elseif parryType == "Straight" then  
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.LookVector * 1000)), Events, Vector3_Mouse_Location}  
    elseif parryType == "Up" then  
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.UpVector * 1000)), Events, Vector3_Mouse_Location}  
    elseif parryType == "Right" then  
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position + (Camera.CFrame.RightVector * 1000)), Events, Vector3_Mouse_Location}  
    elseif parryType == "Left" then  
        data = {0, CFrame.new(Camera.CFrame.Position, Camera.CFrame.Position - (Camera.CFrame.RightVector * 1000)), Events, Vector3_Mouse_Location}  
    else  
        data = {0, Camera.CFrame, Events, Vector3_Mouse_Location}  
    end  

    Parry_Data = data
end

-- Initialize parry data
updateParryData(Parry_Type)

-- Save and load configuration
local function SaveConfig()
    local ConfigData = HttpService:JSONEncode(Config)
    writefile("AutoParryConfig.json", ConfigData)
    ConfigSaved = true
end

local function LoadConfig()
    if isfile("AutoParryConfig.json") then
        local ConfigData = readfile("AutoParryConfig.json")
        local LoadedConfig = HttpService:JSONDecode(ConfigData)
        
        -- Update config with loaded values
        for key, value in pairs(LoadedConfig) do
            Config[key] = value
        end
        
        -- Apply loaded settings
        IsAutoParryEnabled = Config.AutoParry
        AntiCurveEnabled = Config.AntiCurve
        ParryRadius = Config.ParryRadius
        PredictionTime = Config.PredictionTime
        VisualFeedbackEnabled = Config.VisualFeedback
        HitboxVisualizationEnabled = Config.HitboxVisualization
        PingCompensationEnabled = Config.PingCompensation
        
        ConfigSaved = true
        return true
    end
    return false
end

-- Try to load config
pcall(LoadConfig)

-- Create UI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "EnhancedAutoParryUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Main frame
local MainFrame = Instance.new("Frame")
MainFrame.Name = "MainFrame"
MainFrame.Size = UDim2.new(0, 350, 0, 450)
MainFrame.Position = UDim2.new(0.5, -175, 0.5, -225)
MainFrame.BackgroundColor3 = Color3.fromRGB(10, 10, 15)
MainFrame.BackgroundTransparency = 0.2
MainFrame.BorderSizePixel = 0
MainFrame.Parent = ScreenGui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 10)
UICorner.Parent = MainFrame

-- Gradient background
local UIGradient = Instance.new("UIGradient")
UIGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 45)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(15, 15, 25))
})
UIGradient.Rotation = 45
UIGradient.Parent = MainFrame

-- Header
local Header = Instance.new("Frame")
Header.Name = "Header"
Header.Size = UDim2.new(1, 0, 0, 40)
Header.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
Header.BackgroundTransparency = 0.2
Header.BorderSizePixel = 0
Header.Parent = MainFrame

local HeaderCorner = Instance.new("UICorner")
HeaderCorner.CornerRadius = UDim.new(0, 10)
HeaderCorner.Parent = Header

-- Fix the bottom corners of header
local HeaderFix = Instance.new("Frame")
HeaderFix.Size = UDim2.new(1, 0, 0, 10)
HeaderFix.Position = UDim2.new(0, 0, 1, -10)
HeaderFix.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
HeaderFix.BackgroundTransparency = 0.2
HeaderFix.BorderSizePixel = 0
HeaderFix.Parent = Header

-- Title with glow effect
local Title = Instance.new("TextLabel")
Title.Size = UDim2.new(1, -20, 1, 0)
Title.Position = UDim2.new(0, 10, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "Unreleased niggerware | Blade Ball"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 18
Title.Font = Enum.Font.GothamBold
Title.TextXAlignment = Enum.TextXAlignment.Left
Title.Parent = Header

-- Glow effect for title
local TitleGlow = Instance.new("ImageLabel")
TitleGlow.Size = UDim2.new(1.2, 0, 1.2, 0)
TitleGlow.Position = UDim2.new(0.5, 0, 0.5, 0)
TitleGlow.AnchorPoint = Vector2.new(0.5, 0.5)
TitleGlow.BackgroundTransparency = 1
TitleGlow.Image = "rbxassetid://4996891970" -- Radial gradient
TitleGlow.ImageColor3 = Color3.fromRGB(100, 50, 255)
TitleGlow.ImageTransparency = 0.7
TitleGlow.ZIndex = -1
TitleGlow.Parent = Title

-- Stats display
local StatsFrame = Instance.new("Frame")
StatsFrame.Size = UDim2.new(1, -20, 0, 30)
StatsFrame.Position = UDim2.new(0, 10, 0, 45)
StatsFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 45)
StatsFrame.BackgroundTransparency = 0.5
StatsFrame.BorderSizePixel = 0
StatsFrame.Parent = MainFrame

local StatsCorner = Instance.new("UICorner")
StatsCorner.CornerRadius = UDim.new(0, 6)
StatsCorner.Parent = StatsFrame

local ParryCounterLabel = Instance.new("TextLabel")
ParryCounterLabel.Size = UDim2.new(0.5, -5, 1, 0)
ParryCounterLabel.BackgroundTransparency = 1
ParryCounterLabel.Text = "Parries: 0"
ParryCounterLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
ParryCounterLabel.TextSize = 14
ParryCounterLabel.Font = Enum.Font.GothamSemibold
ParryCounterLabel.TextXAlignment = Enum.TextXAlignment.Left
ParryCounterLabel.Parent = StatsFrame

local PingLabel = Instance.new("TextLabel")
PingLabel.Size = UDim2.new(0.5, -5, 1, 0)
PingLabel.Position = UDim2.new(0.5, 5, 0, 0)
PingLabel.BackgroundTransparency = 1
PingLabel.Text = "Ping: 0ms"
PingLabel.TextColor3 = Color3.fromRGB(200, 200, 255)
PingLabel.TextSize = 14
PingLabel.Font = Enum.Font.GothamSemibold
PingLabel.TextXAlignment = Enum.TextXAlignment.Right
PingLabel.Parent = StatsFrame

-- Scrolling content frame
local ScrollingFrame = Instance.new("ScrollingFrame")
ScrollingFrame.Size = UDim2.new(1, -20, 1, -85)
ScrollingFrame.Position = UDim2.new(0, 10, 0, 80)
ScrollingFrame.BackgroundTransparency = 1
ScrollingFrame.BorderSizePixel = 0
ScrollingFrame.ScrollBarThickness = 4
ScrollingFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 255)
ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 600) -- Will be updated based on content
ScrollingFrame.Parent = MainFrame

-- Create section header
local function CreateSectionHeader(text, position)
    local SectionHeader = Instance.new("Frame")
    SectionHeader.Size = UDim2.new(1, 0, 0, 30)
    SectionHeader.Position = position
    SectionHeader.BackgroundColor3 = Color3.fromRGB(60, 60, 90)
    SectionHeader.BackgroundTransparency = 0.7
    SectionHeader.BorderSizePixel = 0
    SectionHeader.Parent = ScrollingFrame
    
    local SectionCorner = Instance.new("UICorner")
    SectionCorner.CornerRadius = UDim.new(0, 6)
    SectionCorner.Parent = SectionHeader
    
    local SectionLabel = Instance.new("TextLabel")
    SectionLabel.Size = UDim2.new(1, -10, 1, 0)
    SectionLabel.Position = UDim2.new(0, 10, 0, 0)
    SectionLabel.BackgroundTransparency = 1
    SectionLabel.Text = text
    SectionLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    SectionLabel.TextSize = 14
    SectionLabel.Font = Enum.Font.GothamBold
    SectionLabel.TextXAlignment = Enum.TextXAlignment.Left
    SectionLabel.Parent = SectionHeader
    
    return SectionHeader
end

-- Create toggle switch
local function CreateToggle(text, position, defaultState, callback)
    local Container = Instance.new("Frame")
    Container.Size = UDim2.new(1, 0, 0, 40)
    Container.Position = position
    Container.BackgroundTransparency = 1
    Container.Parent = ScrollingFrame

    local Label = Instance.new("TextLabel")
    Label.Size = UDim2.new(0.7, 0, 1, 0)
    Label.BackgroundTransparency = 1
    Label.Text = text
    Label.TextColor3 = Color3.fromRGB(200, 200, 200)
    Label.TextSize = 14
    Label.Font = Enum.Font.GothamSemibold
    Label.TextXAlignment = Enum.TextXAlignment.Left
    Label.Parent = Container

    local ToggleBackground = Instance.new("Frame")
    ToggleBackground.Size = UDim2.new(0, 50, 0, 24)
    ToggleBackground.Position = UDim2.new(1, -60, 0.5, -12)
    ToggleBackground.BackgroundColor3 = defaultState and Color3.fromRGB(100, 100, 255) or Color3.fromRGB(60, 60, 60)
    ToggleBackground.BorderSizePixel = 0
    ToggleBackground.Parent = Container

    local ToggleCorner = Instance.new("UICorner")
    ToggleCorner.CornerRadius = UDim.new(1, 0)
    ToggleCorner.Parent = ToggleBackground

    local ToggleCircle = Instance.new("Frame")
    ToggleCircle.Size = UDim2.new(0, 18, 0, 18)
    ToggleCircle.Position = defaultState and UDim2.new(1, -21, 0.5, -9) or UDim2.new(0, 3, 0.5, -9)
    ToggleCircle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    ToggleCircle.BorderSizePixel = 0
    ToggleCircle.Parent = ToggleBackground

    local ToggleCircleCorner = Instance.new("UICorner")
    ToggleCircleCorner.CornerRadius = UDim.new(1, 0)
    ToggleCircleCorner.Parent = ToggleCircle

    local isEnabled = defaultState

    local ToggleButton = Instance.new("TextButton")
    ToggleButton.Size = UDim2.new(1, 0, 1, 0)
    ToggleButton.BackgroundTransparency = 1
    ToggleButton.Text = ""
    ToggleButton.Parent = ToggleBackground

    ToggleButton.MouseButton1Click:Connect(function()
        isEnabled = not isEnabled
        
        local targetPosition = isEnabled and UDim2.new(1, -21, 0.5, -9) or UDim2.new(0, 3, 0.5, -9)
        local targetColor = isEnabled and Color3.fromRGB(100, 100, 255) or Color3.fromRGB(60, 60, 60)
        
        TweenService:Create(ToggleCircle, TweenInfo.new(0.2), {Position = targetPosition}):Play()
        TweenService:Create(ToggleBackground, TweenInfo.new(0.2), {BackgroundColor3 = targetColor}):Play()
        
        if callback then
            callback(isEnabled)
        end
    end)

    return Container, isEnabled, ToggleButton
end

-- Create keybind
local function CreateKeybind(text, position, defaultKey, callback)
    local Container = Instance.new("Frame")
    Container.Size = UDim2.new(1, 0, 0, 40)
    Container.Position = position
    Container.BackgroundTransparency = 1
    Container.Parent = ScrollingFrame

    local Label = Instance.new("TextLabel")
    Label.Size = UDim2.new(0.6, 0, 1, 0)
    Label.BackgroundTransparency = 1
    Label.Text = text
    Label.TextColor3 = Color3.fromRGB(200, 200, 200)
    Label.TextSize = 14
    Label.Font = Enum.Font.GothamSemibold
    Label.TextXAlignment = Enum.TextXAlignment.Left
    Label.Parent = Container

    local KeyBackground = Instance.new("Frame")
    KeyBackground.Size = UDim2.new(0, 100, 0, 30)
    KeyBackground.Position = UDim2.new(1, -110, 0.5, -15)
    KeyBackground.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    KeyBackground.BackgroundTransparency = 0.5
    KeyBackground.BorderSizePixel = 0
    KeyBackground.Parent = Container

    local KeyCorner = Instance.new("UICorner")
    KeyCorner.CornerRadius = UDim.new(0, 6)
    KeyCorner.Parent = KeyBackground

    local KeyLabel = Instance.new("TextLabel")
    KeyLabel.Size = UDim2.new(1, 0, 1, 0)
    KeyLabel.BackgroundTransparency = 1
    KeyLabel.Text = defaultKey.Name
    KeyLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    KeyLabel.TextSize = 14
    KeyLabel.Font = Enum.Font.Gotham
    KeyLabel.Parent = KeyBackground

    local KeyButton = Instance.new("TextButton")
    KeyButton.Size = UDim2.new(1, 0, 1, 0)
    KeyButton.BackgroundTransparency = 1
    KeyButton.Text = ""
    KeyButton.Parent = KeyBackground

    local currentKey = defaultKey
    local isListening = false

    KeyButton.MouseButton1Click:Connect(function()
        if isListening then return end
        
        isListening = true
        KeyLabel.Text = "Press any key..."
        
        local connection
        connection = UserInputService.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.Keyboard then
                currentKey = input.KeyCode
                KeyLabel.Text = input.KeyCode.Name
                isListening = false
                
                if callback then
                    callback(currentKey)
                end
                
                connection:Disconnect()
            end
        end)
    end)

    return Container, currentKey
end

-- Create slider
local function CreateSlider(text, position, min, max, default, callback)
    local Container = Instance.new("Frame")
    Container.Size = UDim2.new(1, 0, 0, 50)
    Container.Position = position
    Container.BackgroundTransparency = 1
    Container.Parent = ScrollingFrame

    local Label = Instance.new("TextLabel")
    Label.Size = UDim2.new(1, 0, 0, 20)
    Label.BackgroundTransparency = 1
    Label.Text = text
    Label.TextColor3 = Color3.fromRGB(200, 200, 200)
    Label.TextSize = 14
    Label.Font = Enum.Font.GothamSemibold
    Label.TextXAlignment = Enum.TextXAlignment.Left
    Label.Parent = Container

    local ValueLabel = Instance.new("TextLabel")
    ValueLabel.Size = UDim2.new(0, 50, 0, 20)
    ValueLabel.Position = UDim2.new(1, -60, 0, 0)
    ValueLabel.BackgroundTransparency = 1
    ValueLabel.Text = tostring(default)
    ValueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    ValueLabel.TextSize = 14
    ValueLabel.Font = Enum.Font.Gotham
    ValueLabel.TextXAlignment = Enum.TextXAlignment.Right
    ValueLabel.Parent = Container

    local SliderBackground = Instance.new("Frame")
    SliderBackground.Size = UDim2.new(1, -70, 0, 6)
    SliderBackground.Position = UDim2.new(0, 0, 0.8, 0)
    SliderBackground.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
    SliderBackground.BackgroundTransparency = 0.5
    SliderBackground.BorderSizePixel = 0
    SliderBackground.Parent = Container

    local SliderBackgroundCorner = Instance.new("UICorner")
    SliderBackgroundCorner.CornerRadius = UDim.new(1, 0)
    SliderBackgroundCorner.Parent = SliderBackground

    local SliderFill = Instance.new("Frame")
    SliderFill.Size = UDim2.new((default - min) / (max - min), 0, 1, 0)
    SliderFill.BackgroundColor3 = Color3.fromRGB(100, 100, 255)
    SliderFill.BorderSizePixel = 0
    SliderFill.Parent = SliderBackground

    local SliderFillCorner = Instance.new("UICorner")
    SliderFillCorner.CornerRadius = UDim.new(1, 0)
    SliderFillCorner.Parent = SliderFill

    local SliderKnob = Instance.new("Frame")
    SliderKnob.Size = UDim2.new(0, 16, 0, 16)
    SliderKnob.Position = UDim2.new((default - min) / (max - min), -8, 0.5, -8)
    SliderKnob.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    SliderKnob.BorderSizePixel = 0
    SliderKnob.ZIndex = 2
    SliderKnob.Parent = SliderBackground

    local SliderKnobCorner = Instance.new("UICorner")
    SliderKnobCorner.CornerRadius = UDim.new(1, 0)
    SliderKnobCorner.Parent = SliderKnob

    local SliderButton = Instance.new("TextButton")
    SliderButton.Size = UDim2.new(1, 0, 1, 0)
    SliderButton.BackgroundTransparency = 1
    SliderButton.Text = ""
    SliderButton.Parent = SliderBackground

    local value = default

    local function updateSlider(input)
        local pos = math.clamp((input.Position.X - SliderBackground.AbsolutePosition.X) / SliderBackground.AbsoluteSize.X, 0, 1)
        value = math.floor(min + ((max - min) * pos))
        ValueLabel.Text = tostring(value)
        SliderFill.Size = UDim2.new(pos, 0, 1, 0)
        SliderKnob.Position = UDim2.new(pos, -8, 0.5, -8)
        
        if callback then
            callback(value)
        end
    end

    SliderButton.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local connection
            connection = RunService.RenderStepped:Connect(function()
                local mousePos = UserInputService:GetMouseLocation()
                local input = {Position = Vector2.new(mousePos.X, mousePos.Y)}
                updateSlider(input)
            end)
            
            UserInputService.InputEnded:Connect(function(inputEnd)
                if inputEnd.UserInputType == Enum.UserInputType.MouseButton1 then
                    if connection then
                        connection:Disconnect()
                    end
                end
            end)
            
            updateSlider(input)
        end
    end)

    return Container, value
end

-- Create sections and controls
local CoreSection = CreateSectionHeader("Core Features", UDim2.new(0, 0, 0, 0))
local AutoParryToggle, _, AutoParryButton = CreateToggle("Auto Parry", UDim2.new(0, 0, 0, 40), Config.AutoParry, function(state)
    IsAutoParryEnabled = state
    Config.AutoParry = state
end)

local AntiCurveToggle, _, AntiCurveButton = CreateToggle("Anti Curve", UDim2.new(0, 0, 0, 90), Config.AntiCurve, function(state)
    AntiCurveEnabled = state
    Config.AntiCurve = state
end)

local VisualSection = CreateSectionHeader("Visual Settings", UDim2.new(0, 0, 0, 140))
local VisualFeedbackToggle, _, VisualFeedbackButton = CreateToggle("Visual Feedback", UDim2.new(0, 0, 0, 180), Config.VisualFeedback, function(state)
    VisualFeedbackEnabled = state
    Config.VisualFeedback = state
end)

local HitboxVisualizationToggle, _, HitboxVisualizationButton = CreateToggle("Hitbox Visualization", UDim2.new(0, 0, 0, 230), Config.HitboxVisualization, function(state)
    HitboxVisualizationEnabled = state
    Config.HitboxVisualization = state
end)

local AdvancedSection = CreateSectionHeader("Advanced Settings", UDim2.new(0, 0, 0, 280))
local PingCompensationToggle, _, PingCompensationButton = CreateToggle("Ping Compensation", UDim2.new(0, 0, 0, 320), Config.PingCompensation, function(state)
    PingCompensationEnabled = state
    Config.PingCompensation = state
end)

local ParryRadiusSlider, _ = CreateSlider("Parry Radius", UDim2.new(0, 0, 0, 370), 5, 50, Config.ParryRadius, function(value)
    ParryRadius = value
    Config.ParryRadius = value
end)

local PredictionTimeSlider, _ = CreateSlider("Prediction Time", UDim2.new(0, 0, 0, 430), 0.1, 1, Config.PredictionTime * 10, function(value)
    PredictionTime = value / 10
    Config.PredictionTime = value / 10
end)

local KeybindSection = CreateSectionHeader("Keybinds", UDim2.new(0, 0, 0, 490))
local ToggleUIKeybind, _ = CreateKeybind("Toggle UI", UDim2.new(0, 0, 0, 530), Config.Keybinds.ToggleUI, function(key)
    Config.Keybinds.ToggleUI = key
end)

local ToggleAutoParryKeybind, _ = CreateKeybind("Toggle Auto Parry", UDim2.new(0, 0, 0, 580), Config.Keybinds.ToggleAutoParry, function(key)
    Config.Keybinds.ToggleAutoParry = key
end)

local ManualParryKeybind, _ = CreateKeybind("Manual Parry", UDim2.new(0, 0, 0, 630), Config.Keybinds.ManualParry, function(key)
    Config.Keybinds.ManualParry = key
end)

-- Save config button
local SaveConfigButton = Instance.new("TextButton")
SaveConfigButton.Size = UDim2.new(1, -20, 0, 40)
SaveConfigButton.Position = UDim2.new(0, 10, 0, 680)
SaveConfigButton.BackgroundColor3 = Color3.fromRGB(80, 80, 200)
SaveConfigButton.BackgroundTransparency = 0.2
SaveConfigButton.BorderSizePixel = 0
SaveConfigButton.Text = "Save Configuration"
SaveConfigButton.TextColor3 = Color3.fromRGB(255, 255, 255)
SaveConfigButton.TextSize = 14
SaveConfigButton.Font = Enum.Font.GothamBold
SaveConfigButton.Parent = ScrollingFrame

local SaveConfigCorner = Instance.new("UICorner")
SaveConfigCorner.CornerRadius = UDim.new(0, 6)
SaveConfigCorner.Parent = SaveConfigButton

SaveConfigButton.MouseButton1Click:Connect(function()
    pcall(SaveConfig)
    
    -- Show save confirmation
    local SaveConfirm = Instance.new("TextLabel")
    SaveConfirm.Size = UDim2.new(1, 0, 0, 20)
    SaveConfirm.Position = UDim2.new(0, 0, 1, 5)
    SaveConfirm.BackgroundTransparency = 1
    SaveConfirm.Text = "Configuration Saved!"
    SaveConfirm.TextColor3 = Color3.fromRGB(100, 255, 100)
    SaveConfirm.TextSize = 12
    SaveConfirm.Font = Enum.Font.GothamBold
    SaveConfirm.Parent = SaveConfigButton
    
    Debris:AddItem(SaveConfirm, 2)
end)

-- Update canvas size based on content
ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 730)

-- Close button
local CloseButton = Instance.new("TextButton")
CloseButton.Size = UDim2.new(0, 30, 0, 30)
CloseButton.Position = UDim2.new(1, -35, 0, 5)
CloseButton.BackgroundTransparency = 1
CloseButton.Text = "×"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 24
CloseButton.Font = Enum.Font.GothamBold
CloseButton.Parent = Header

CloseButton.MouseButton1Click:Connect(function()
    MainFrame.Visible = false
end)

-- Make the UI draggable
local dragging
local dragInput
local dragStart
local startPos

local function update(input)
    local delta = input.Position - dragStart
    MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
end

Header.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

Header.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input == dragInput and dragging then
        update(input)
    end
end)

-- Update stats display
RunService.Heartbeat:Connect(function()
    ParryCounterLabel.Text = "Parries: " .. ParrySuccessCounter
    PingLabel.Text = "Ping: " .. math.floor(LocalPlayer:GetNetworkPing() * 1000) .. "ms"
end)

-- Keybind handling
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Config.Keybinds.ToggleUI then
        MainFrame.Visible = not MainFrame.Visible
    elseif input.KeyCode == Config.Keybinds.ToggleAutoParry then
        IsAutoParryEnabled = not IsAutoParryEnabled
        Config.AutoParry = IsAutoParryEnabled
        
        -- Update toggle visually
        local targetPosition = IsAutoParryEnabled and UDim2.new(1, -21, 0.5, -9) or UDim2.new(0, 3, 0.5, -9)
        local targetColor = IsAutoParryEnabled and Color3.fromRGB(100, 100, 255) or Color3.fromRGB(60, 60, 60)
        
        TweenService:Create(AutoParryButton:FindFirstChildOfClass("Frame"), TweenInfo.new(0.2), {Position = targetPosition}):Play()
        TweenService:Create(AutoParryButton, TweenInfo.new(0.2), {BackgroundColor3 = targetColor}):Play()
    elseif input.KeyCode == Config.Keybinds.ManualParry then
        -- Manual parry
        for Remote, Args in pairs(Remotes) do
            Remote:FireServer(Args, Parry_Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
        end
    end
end)

-- Remote event listeners
ReplicatedStorage:WaitForChild("Remotes").ParrySuccess.OnClientEvent:Connect(function()
    if LocalPlayer.Character and LocalPlayer.Character.Parent ~= Alive then
        return
    end
    
    ParrySuccessCounter = ParrySuccessCounter + 1
    if VisualFeedbackEnabled then
        ShowParryFeedback()
    end
end)

-- Make the UI visible with a fade-in effect
MainFrame.BackgroundTransparency = 1
Header.BackgroundTransparency = 1

TweenService:Create(MainFrame, TweenInfo.new(0.5), {BackgroundTransparency = 0.2}):Play()
TweenService:Create(Header, TweenInfo.new(0.5), {BackgroundTransparency = 0.2}):Play()
